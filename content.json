{"meta":{"title":"Tianen","subtitle":"搞事情，搞事情","description":"","author":null,"url":"https://www.lauyongyi.cn","root":"/"},"pages":[{"title":"关于这个小站点","date":"2018-11-15T15:04:43.000Z","updated":"2021-05-10T14:34:36.395Z","comments":false,"path":"about/index.html","permalink":"https://www.lauyongyi.cn/about/index.html","excerpt":"","text":"关于本人 这个站点主要用于记录个人的一些学习过程，主要是工作中用到的工具，框架、接触到的新知识等。记录内容来源主要是个人操作、学习记录以及网上其他大神的分享摘录。 如果文章中有不实、侵权以及错误的地方，可以通过邮件告诉我，我会及时处理修正。 欢迎一起来玩，ヾﾉ≧∀≦)o来啊，快活啊!"},{"title":"分类","date":"2018-11-15T14:56:50.000Z","updated":"2021-04-24T00:45:38.900Z","comments":false,"path":"categories/index.html","permalink":"https://www.lauyongyi.cn/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2021-07-18T14:53:03.856Z","updated":"2021-04-24T00:45:38.950Z","comments":true,"path":"project/index.html","permalink":"https://www.lauyongyi.cn/project/index.html","excerpt":"","text":""},{"title":"能快速找到文章的地方","date":"2018-11-15T15:03:58.000Z","updated":"2021-04-24T00:45:38.950Z","comments":false,"path":"tags/index.html","permalink":"https://www.lauyongyi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"安卓界面渲染检查","slug":"安卓界面渲染检查","date":"2021-07-30T15:00:00.000Z","updated":"2021-07-31T05:51:20.000Z","comments":true,"path":"安卓界面渲染检查.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A3%80%E6%9F%A5.html","excerpt":"​ Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。","text":"​ Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。 ​ Android 上的“设置”应用包含一个名为开发者选项的设置，您可以使用该屏幕配置一些系统行为来帮助您分析和调试应用性能。例如，您可以启用 USB 调试、捕获错误报告、启用点按的视觉反馈、在窗口 surface 更新时刷写 surface、使用 GPU 渲染 2D 图形，等等。 开启GPU渲染分析​ GPU 渲染模式分析工具可以显示渲染流水线的每个阶段渲染前一帧所用的相对时间。这些信息有助于您确定流水线中的瓶颈所在，从而了解应该优化哪些方面来提高应用的渲染性能。 在设备上，转到 Settings（设置） 点击 Developer Options（开发者选项）。 在 Monitoring（监控） 部分，选择 Profile GPU Rendering（HWUI呈现模式分析）。 在“HWUI呈现模式分析”对话框中，选择在屏幕上显示为竖条，以在设备的屏幕上叠加图形。 打开您要分析的应用。 在屏幕显示成条形图​ 染模式分析工具以图表（以颜色编码的直方图）的形式显示各个阶段及其相对时间。图1显示了此图表的一个示例。 下面是有关输出的几点注意事项： 对于每个可见应用，该工具将显示一个图形。 沿水平轴的每个竖条代表一个帧，每个竖条的高度表示渲染该帧所花的时间（以毫秒为单位）。 水平绿线表示 16 毫秒。要实现每秒 60 帧，代表每个帧的竖条需要保持在此线以下。当竖条超出此线时，可能会使动画出现暂停。 该工具通过加宽对应的竖条并降低透明度来突出显示超出 16 毫秒阈值的帧。 每个竖条都有与渲染管道中某个阶段对应的彩色区段。区段数因设备的 API 级别不同而异。 渲染和流畅概念​ Google 定义：界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与应用互动，应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是 60fps？）。如果应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉应用不流畅，我们将这种情况称为卡顿。 为什么是 60fps 或 16ms？​ 16ms 意味着 1000/60hz，相当于 60fps。这是因为人眼与大脑之间的协作无法感知超过 60fps 的画面更新。12fps 大概类似手动快速翻动书籍的帧率， 这明显是可以感知到不够顺滑的。24fps 使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。 24fps 是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。 但是低于 30fps 是 无法顺畅表现绚丽的画面内容的，此时就需要用到 60fps 来达到想要的效果，超过 60fps 就没有必要了。如果我们的应用没有在 16ms 内完成屏幕刷新的全部逻辑操作，就会发生卡顿。 渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。图 2 说明了显示的每种颜色所代表的含义。 图3介绍了使用运行 Android 6.0 及更高版本的设备时分析器输出中某个竖条的每个区段 使用ADB命令分析先开坑，后面再填 呈现 GPU 过度绘制过渡绘制 所谓过渡绘制，就是指一帧画面上，某一个像素区域被绘制了多次。 危害 过度绘制会浪费大量的CPU以及GPU资源，最直观的影响就是会导致APP卡顿。 呈现 GPU 过度绘制是开发者选项中的另一个功能，通过对界面进行彩色编码来帮助识别过度绘制。当应用在同一帧中多次绘制相同像素时，便会发生过度绘制。 开启步骤： 在设备上，转到 Settings（设置） 点击 Developer Options（开发者选项）。 向下滚动到硬件加速渲染部分，并选择调试 GPU 过度绘制。 在调试 GPU 过度绘制对话框中，选择显示过度绘制区域。 Android 会按照如下图所示的方式为界面元素着色，以确定过度绘制的次数： 这些颜色是半透明的，因此在屏幕上看到的确切颜色取决于界面的内容。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"工具的使用","slug":"工具的使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"常用的Git命令","slug":"常用的Git命令","date":"2021-07-23T14:37:00.000Z","updated":"2021-07-30T15:43:00.000Z","comments":true,"path":"常用的Git命令.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4.html","excerpt":"​ Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。 git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自wikipedia。","text":"​ Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。 git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自wikipedia。 安装Git在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &#39;git&#39; is currently not installed. You can install it by typing:sudo apt-get install git 如果碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; （windows推荐使用Git自带的命令行工具：GitBash，可以避免很多问题。其次文件夹尽量避免使用中文或特殊符号） ​ 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 常用的Git命令创建本地仓库123Documents % mkdir GitEx #创建一个目录Documents % cd GitEx #进入到目录GitEx % git init #把这个目录变成Git可以管理的仓库 ​ 执行之后，瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 1234567891011hint: Using &#x27;master&#x27; as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; andhint: &#x27;development&#x27;. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Initialized empty Git repository in /Users/tinenlau/Documents/GitEx/.git/ ​ 通过ls -a可以看到目录结构。如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 12GitEx % ls -a. .. .git 添加文件​ 把一个文件放入到 “GitEx” 目录下，一定要放到 “GitEx” 目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 ​ 第一步：用命令git add告诉Git，把文件添加到仓库，例如一张图片： 1GitEx % git add wallhaven-57ge21.jpeg ​ 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 ​ 第二步：用命令git commit告诉Git，把文件提交到仓库 1234GitEx % git commit -m &quot;add new pic&quot;[master (root-commit) 1983ca0] add new pic 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 wallhaven-57ge21.jpeg ​ 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 ​ 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 ​ git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的wallhaven-57ge21.jpeg文件）；0 insertions：没有插入内容（因为上传的是图片）。 ​ 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123GitEx % git add file1.txtGitEx % git add file2.txt file3.txtGitEx % git commit -m &quot;add 3 files.&quot; 总结一下 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 Git版本管理​ 在Git中，用git log命令可以显示从最近到最远的提交日志： 12345678910111213141516GitEx % git log commit 81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master)Author: &lt;&gt;Date: Sun Jul 25 20:41:42 2021 +0800 版本演示管理commit 3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774Author: &lt;&gt;Date: Sun Jul 25 20:33:02 2021 +0800 Git说明commit 1983ca011b008cda324a3c5d6da21571c8825857Author: &lt;&gt;Date: Fri Jul 23 23:41:13 2021 +0800 ​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数 1234GitEx % git log --pretty=oneline81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master) 版本演示管理3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774 Git说明1983ca011b008cda324a3c5d6da21571c8825857 add new pic ​ 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。 ​ 要把仓库还原到上一版本，就必须先知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 ​ 要把当前版本回退到上一个版本就可以使用git reset命令： 1234GitEx % git reset --hard HEAD^HEAD is now at 3dbfc11 Git说明GitEx % git reset --hard HEAD^HEAD is now at 1983ca0 add new pic ​ 查看文件夹的内容，从返回的结果来看，新建的文件夹被删除了。 123GitEx % ls -a. .git.. wallhaven-57ge21.jpeg ​ 用git log再看看现在版本库的状态： 1234567GitEx % git logcommit 1983ca011b008cda324a3c5d6da21571c8825857 (HEAD -&gt; master)Author: &lt;&gt;Date: Fri Jul 23 23:41:13 2021 +0800 add new pic ​ 新提交的版本已经看不到了。但在不关闭命令行窗口的前提下，还是可以还原的，方法是：找到那个需要还原版本的commit id： 12345GitEx % git reset --hard 81eca4214c46c22aHEAD is now at 81eca42 版本演示管理tinenlau@TinendeAir GitEx % ls -a. .git wallhaven-57ge21.jpeg.. readme.rtf ​ 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 用git log可以查看提交历史，以便确定要回退到哪个版本。 用git reflog查看命令历史，以便确定要回到未来的哪个版本。 暂存区工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 所以，git commit就是往master分支上提交更改。 可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 对工作区进行了文件操作，然后用git status查看一下状态： 12345678910111213 GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: readme.rtfUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) newreadme.txt readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚的显示了：readme.rtf被删除了，新增了两个文件，状态为Untracked即：没有被添加过。 分别使用git add添加新文件，然后使用git rm删除状态为delete的文件，然后再次使用git status查看状态： 1234567GitEx % git status On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: newreadme.txt deleted: readme.rtf new file: readme.txt git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。 123456789GitEx % git commit -m &quot;修改和新增多个文件&quot; [master 892a394] 修改和新增多个文件 3 files changed, 2 insertions(+), 10 deletions(-) create mode 100644 newreadme.txt delete mode 100644 readme.rtf create mode 100644 readme.txttinenlau@TinendeAir GitEx % git status On branch masternothing to commit, working tree clean 撤销修改人非圣贤孰能无过，虽然写错或者修改错了文档的情况不一定会发生，但如果发生了，又还没有提交到暂存区的时候，就可以用git checkout -- file来丢弃一些修改。 123456789101112131415161718GitEx % vi newreadme.txt GitEx % cat newreadme.txt 添加一个新的readme文档checkout 演示用GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: newreadme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)GitEx % git checkout -- newreadme.txtGitEx % cat newreadme.txt 添加一个新的readme文档% 从演示的代码可以看出，添加的内容被删除了，但原内容还在，又可以开心的搞事情了。 但是，你不小心修改或者写错了，还手贱的git add了，这时候git checkout -- file是救不了你了，这时候，不就需要用到git reset HEAD &lt;file&gt;把暂存区的修改撤销掉（unstage）。 1234567891011121314151617181920212223242526272829303132333435GitEx % vi newreadme.txt GitEx % cat newreadme.txt 添加一个新的readme文档llaklshjdakjhsdkjakjf asdhksdbkbsdfasjkfksljhdfjkshfsjdfljkshdfkljklasdjsfjksfhvoixclvn se;fksp[fcvaksdjkfvoics dv GitEx % git add newreadme.txt GitEx % git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: newreadme.txtGitEx % git reset Head newreadme.txtUnstaged changes after reset:M newreadme.txtGitEx % git status On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: newreadme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)GitEx % git checkout -- newreadme.txt GitEx % git status On branch masternothing to commit, working tree cleanGitEx % cat newreadme.txt 添加一个新的readme文档% 嘿嘿，一顿操作之后，又可以愉快的搞事情了。 小结。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 删除文件在Git中，删除也是一个修改操作，可以先模拟添加一个文件，然后将它删除。 1234567891011121314151617GitEx % touch delete.txtGitEx % git add delete.txt GitEx % git commit -m &quot;add delete.txt&quot;[master 88b28c9] add delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 delete.txttinenlau@TinendeAir GitEx % ls -a. delete.txt wallhaven-57ge21.jpeg.. newreadme.txt.git readme.txtGitEx % git logcommit 88b28c9840bd9730816437b4d4710c5e86b3a449 (HEAD -&gt; master)Author: &lt;&gt;Date: Thu Jul 29 23:45:15 2021 +0800 add delete.txt 现在有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 12345678910111213141516171819202122232425tinenlau@TinendeAir GitEx % rm delete.txt tinenlau@TinendeAir GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: delete.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) GitEx % git rm delete.txt rm &#x27;delete.txt&#x27;GitEx % git commit -m &quot;del delete.txt&quot;[master b383f57] del delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 delete.txtGitEx % ls -a. .git readme.txt.. newreadme.txt wallhaven-57ge21.jpegtinenlau@TinendeAir GitEx % git logcommit b383f57e0ada97541d6757f918994d86c199d7bc (HEAD -&gt; master)Author: &lt;&gt;Date: Thu Jul 29 23:49:14 2021 +0800 del delete.txt 先手动删除文件，然后使用git rm 和git add效果是一样的。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 12345678910GitEx % git reset HEAD^Unstaged changes after reset:D delete.txtGitEx % git checkout delete.txtUpdated 1 path from the indexGitEx % ls -a. delete.txt wallhaven-57ge21.jpeg.. newreadme.txt.git readme.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 创建SSHkey由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 需要把youremail@example.com换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。当然了，你也可以选择设置密码，只要你不嫌麻烦。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登录GitHub或者Gitee，打开“Setting–SSH”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容就可以了。这里应该要有配图的但我懒得截图了，就这样吧。 答疑时间为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。 创建远程仓库Git的在线仓库推荐：GitHub，Gitee，还有腾讯云旗下的Coding等。 关于账号、仓库的创建可以进入这两个网站，然后按照相关指示进行操作，GitHub最好自带梯子。Gitee是国内的，可以多多支持。 关联/添加远程仓库在线Git仓库创建好之后，需要和本地原有的仓库进行关联，需要使用的命令是： git remote add origin git@github.com:[username]/[gitname].git 下面是关联远程仓库后拉取的操作过程记录： 1234567891011121314151617181920212223242526272829303132333435Documents % mkdir GitLocalDocuments % cd GitLocal GitLocal % git inithint: Using &#x27;master&#x27; as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; andhint: &#x27;development&#x27;. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Initialized empty Git repository in /Users/xxxxxxx/Documents/GitLocal/.git/GitLocal % ls -a. .. .gitGitLocal % git remote add origin git@gitee.com:lauyongyi/git-examples.gittinenlau@TinendeAir GitLocal % git pull origin masterhint: Pulling without specifying how to reconcile divergent branches ishint: discouraged. You can squelch this message by running one of the followinghint: commands sometime before your next pull:hint: hint: git config pull.rebase false # merge (the default strategy)hint: git config pull.rebase true # rebasehint: git config pull.ff only # fast-forward onlyhint: hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a defaulthint: preference for all repositories. You can also pass --rebase, --no-rebase,hint: or --ff-only on the command line to override the configured default perhint: invocation.From gitee.com:lauyongyi/git-examples * branch master -&gt; FETCH_HEADGitLocal % ls -a. .git README.en.md ly.txt.. .gitignore README.md 这个是关联后推送的操作记录（因为懒得操作，所以直接从网上抄的） 12345678910git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes&#x2F;no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 删除远程仓库如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息： 123GitLocal % git remote -vorigin git@gitee.com:lauyongyi/git-examples.git (fetch)origin git@gitee.com:lauyongyi/git-examples.git (push) 然后，根据名字删除，比如删除origin： 123GitLocal % git remote rm originGitLocal % git remote -v 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 远程仓库操作仓库克隆：git clone 仓库地址 推送提交：git push 拉取新的内容：git pull","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"adb 命令播放音视频","slug":"adb播放音视频","date":"2021-06-26T14:50:00.000Z","updated":"2021-06-26T15:01:52.047Z","comments":true,"path":"adb播放音视频.html","link":"","permalink":"https://www.lauyongyi.cn/adb%E6%92%AD%E6%94%BE%E9%9F%B3%E8%A7%86%E9%A2%91.html","excerpt":"android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下","text":"android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下 播放音乐1adb shell am start -n com.android.music/com.android.music.MediaPlaybackActivity -d /sdcard/test.mp3 /sdcard/timian.mp3为音乐地址 或 1adb shell am start -a &quot;android.intent.action.VIEW&quot; -t &quot;audio/mp3&quot; -d &quot;file:///storage/sdcard0/Music/hello.mp3&quot; /storage/sdcard0/Music/hello.mp3为音乐地址 播放视频1adb shell am start -a android.intent.action.VIEW -d &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; /mnt/sdcard/DCIM/Camera/test.3gp为视频文件地址 或 1adb shell am start -a android.intent.action.VIEW -d &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; -n &quot;com.alensw.PicFolder/.PlayerActivity&quot; /mnt/sdcard/DCIM/Camera/test.3gp为视频文件地址 com.alensw.PicFolder/.PlayerActivity是播放器的播放页面 模拟操作对屏幕进行操作，可以用ADB命令模拟按键 12345adb shell input keyevent 24 #增加音量adb shell input keyevent 25 #降低音量adb shell input keyevent 85 #暂停/播放adb shell input keyevent 126 #恢复播放adb shell input keyevent 127 #停止播放 关闭可以采用杀死进程的方式进行 123ps -A | grep music#找到music的pidkill pid","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Mac OS 运行npm报错","slug":"Mac OS npm报错","date":"2021-06-22T15:17:00.000Z","updated":"2021-06-22T15:36:30.000Z","comments":true,"path":"Mac OS npm报错.html","link":"","permalink":"https://www.lauyongyi.cn/Mac%20OS%20npm%E6%8A%A5%E9%94%99.html","excerpt":"​ 使用Mac OS 运行npm install -g npm 出现如下图所示错误","text":"​ 使用Mac OS 运行npm install -g npm 出现如下图所示错误 报错如下： 图中，方框圈起的报错信息，主要是说没有权限，关键词：permission denied 底部椭圆圈起的内容，大概翻译一下，意思是 123permissions of the file and its containing directories, or try runningnpm ERR! the command again as root&#x2F;Administrator. 文件及其包含的目录的权限，或尝试运行npm犯错!再次以root&#x2F;管理员的身份执行该命令。 会报错是因为执行命令没有获取管理员权限，只需要在原有的命令前面加上sudo获取权限，然后回车时候需要输入管理员密码即可。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"使用python编写Uiautomator2.0脚本","slug":"Uiautomatou 2.0 python篇","date":"2021-06-19T10:29:00.000Z","updated":"2021-06-21T15:57:00.000Z","comments":true,"path":"Uiautomatou 2.0 python篇.html","link":"","permalink":"https://www.lauyongyi.cn/Uiautomatou%202.0%20python%E7%AF%87.html","excerpt":"​ 近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目Uiautomaotr2.0，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。","text":"​ 近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目Uiautomaotr2.0，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。 环境安装首先，必须确保本地安装了python环境，然后按照[README][https://github.com/openatx/uiautomator2/blob/master/README.md]的说明进行安装。 安装命令如下：pip3 install -U uiautomator2或者pip install -U uiautomator2， pip3 针对的是python2和python3共存的环境，例如自带python2.x的Mac os，Linux。 测试是否安装成功可以执行 uiautomator2 --help 脚本运行打开pycharm，新建一个工程，创建python文件 1234import uiautomator2d = uiautomator2.connect()print(d.info) 运行python文件，在控制台会有一个倒计时输出。从打印信息可以看出，是在安装需要用到的APP 12345[D 210619 18:46:21 __init__:634] kill process(ps): uiautomator[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator.apk-d3f17174fb/app-uiautomator.apk[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator.apk[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator-test.apk-652bf9e13c/app-uiautomator-test.apk[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator-test.apk 安装结束后，就会打印出连接的设备的信息 1&#123;&#x27;currentPackageName&#x27;: &#x27;net.oneplus.launcher&#x27;, &#x27;displayHeight&#x27;: 2297, &#x27;displayRotation&#x27;: 0, &#x27;displaySizeDpX&#x27;: 384, &#x27;displaySizeDpY&#x27;: 853, &#x27;displayWidth&#x27;: 1080, &#x27;productName&#x27;: &#x27;OnePlus8T_CH&#x27;, &#x27;screenOn&#x27;: True, &#x27;sdkInt&#x27;: 30, &#x27;naturalOrientation&#x27;: True&#125; 启动和停止APP运行来源于[原文档][https://github.com/openatx/uiautomator2#launch-an-app] Launch an app123456789# 默认的这种方法是先通过atx-agent解析apk包的mainActivity，然后调用am start -n $package/$activity启动d.app_start(&quot;com.example.hello_world&quot;)# 使用 monkey -p com.example.hello_world -c android.intent.category.LAUNCHER 1 启动# 这种方法有个副作用，它自动会将手机的旋转锁定给关掉d.app_start(&quot;com.example.hello_world&quot;, use_monkey=True) # start with package name# 通过指定main activity的方式启动应用，等价于调用am start -n com.example.hello_world/.MainActivityd.app_start(&quot;com.example.hello_world&quot;, &quot;.MainActivity&quot;) Stop an app1234# 相当于 `am force-stop`, 可能会丢失部分数据d.app_stop(&quot;com.example.hello_world&quot;) # 相当于 `pm clear`，清理APP相关的数据d.app_clear(&#x27;com.example.hello_world&#x27;) Stop all running apps1234# 停止所有APP的运行，但不清空后台任务d.app_stop_all()# 停止除了 com.examples.demo 以外的其他APPd.app_stop_all(excludes=[&#x27;com.examples.demo&#x27;]) 获取APP详情123456789101112info = d.app_info(&quot;com.oneplus.gallery&quot;)print(info)# expect output&#123; &#x27;packageName&#x27;: &#x27;com.oneplus.gallery&#x27;, &#x27;mainActivity&#x27;: &#x27;com.oneplus.gallery2.OPGalleryActivity&#x27;, &#x27;label&#x27;: &#x27;Gallery&#x27;, &#x27;versionName&#x27;: &#x27;4.0.180&#x27;, &#x27;versionCode&#x27;: 24190720, &#x27;size&#x27;: 137659606&#125; 打印正在运行的APP1234import uiautomator2d = uiautomator2.connect()print(d.app_list_running()) 运行结果是： 1[&#x27;net.oneplus.odm.provider&#x27;, &#x27;com.heytap.market&#x27;, &#x27;org.ifaa.aidl.manager&#x27;, &#x27;com.tencent.mm&#x27;, &#x27;com.android.cellbroadcastreceiver&#x27;, &#x27;com.numberrecognition&#x27;, &#x27;com.qualcomm.qti.workloadclassifier&#x27;, &#x27;com.oneplus.opbugreportlite&#x27;, &#x27;com.google.android.gms&#x27;, &#x27;com.oneplus.coreservice&#x27;, &#x27;com.heytap.mcs&#x27;, &#x27;com.oneplus.sound.tuner&#x27;, &#x27;com.redteamobile.virtual.softsim&#x27;, &#x27;com.oneplus.instant.local.service&#x27;, &#x27;com.oneplus.communication.sync&#x27;, &#x27;com.github.uiautomator&#x27;, &#x27;com.qualcomm.qcrilmsgtunnel&#x27;, &#x27;com.android.permissioncontroller&#x27;, &#x27;com.oneplus.orm&#x27;, &#x27;org.codeaurora.ims&#x27;, &#x27;com.oneplus.camera&#x27;, &#x27;com.android.se&#x27;, &#x27;com.android.nfc&#x27;, &#x27;com.android.settings&#x27;, &#x27;com.oneplus.gamespace&#x27;, &#x27;com.oneplus.brickmode&#x27;, &#x27;com.amap.android.location&#x27;, &#x27;com.google.android.ext.services&#x27;, &#x27;com.oneplus.config&#x27;, &#x27;com.oneplus.account&#x27;, &#x27;com.android.systemui&#x27;, &#x27;com.qualcomm.qti.devicestatisticsservice&#x27;, &#x27;com.qualcomm.qtil.aptxals&#x27;, &#x27;com.oneplus.camera.service&#x27;, &#x27;com.nearme.instant.platform&#x27;, &#x27;com.oneplus.permissionutil&#x27;, &#x27;com.oneplus.share&#x27;, &#x27;com.tencent.soter.soterserver&#x27;, &#x27;com.oneplus&#x27;, &#x27;com.google.android.providers.media.module&#x27;, &#x27;com.heytap.cloud&#x27;, &#x27;com.oneplus.screenrecord&#x27;, &#x27;com.oneplus.gallery&#x27;, &#x27;net.oneplus.weather&#x27;, &#x27;com.qualcomm.location&#x27;, &#x27;com.google.android.inputmethod.latin&#x27;, &#x27;com.android.cellbroadcastservice&#x27;, &#x27;com.qualcomm.qti.telephonyservice&#x27;, &#x27;com.android.providers.calendar&#x27;, &#x27;com.oneplus.camera.pictureprocessing&#x27;, &#x27;com.oneplus.mms&#x27;, &#x27;com.android.vending&#x27;, &#x27;com.android.phone&#x27;, &#x27;com.dolby.daxservice&#x27;, &#x27;net.oneplus.launcher&#x27;, &#x27;com.oneplus.voicewakeup&#x27;, &#x27;com.qualcomm.qti.uim&#x27;, &#x27;com.heytap.openid&#x27;] 等待指定app运行1234567891011import uiautomator2d = uiautomator2.connect()pid = d.app_wait(&quot;com.oneplus.camera&quot;)if not pid: print(&quot;com.oneplus.camera is not running&quot;)else: print(&quot;com.oneplus.camera pid is %d&quot; % pid)d.app_wait(&quot;com.oneplus.camera&quot;, front=True) # 等待应用前台运行# d.app_wait(&quot;com.oneplus.camera&quot;, timeout=20.0) #app_wait 默认等待时间就是20s 运行结果如下 1234com.oneplus.camera pid is 5577 #app运行时的打印com.oneplus.camera is not running #app没有运行时的打印","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"Fiddler的使用","slug":"Fiddler 过滤","date":"2021-06-04T14:37:00.000Z","updated":"2021-06-14T07:26:00.000Z","comments":true,"path":"Fiddler 过滤.html","link":"","permalink":"https://www.lauyongyi.cn/Fiddler%C2%A0%E8%BF%87%E6%BB%A4.html","excerpt":"​ 使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能Filters。","text":"​ 使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能Filters。 User Filters启用​ 一般情况下，User Filter 是没有启动，状态如下图所示 点击选择后，状态变成已启用，如下图所示 Action的功能Action：Run Filterset now是否运行，Load Filterset加载，Save Filterset保存； Hosts 过滤Zone：指定只显示内网（Intranet）或互联网（Internet）的内容； Host：指定显示某个域名下的会话； -No Host Filter：无HOST过滤；Hide the following Hosts：隐藏以下HOST；Show only the following Hosts：仅显示以下HostsFlag the following Hosts：标记以下HOST；输入多个HOST，多个之前用 ; 或 , 或 回车键 分隔；支持通配符如：*,baidu.com； 步骤：选择Hosts—&gt;输入过滤条件单条件ir.baidu.com或多条件ir.baidu.com;www.baidu.com或通配符*.baidu.com—&gt;Changes not yet saved—&gt;选择Ations中Run Filterset now； Client Process 过滤客户端进程过滤规则： Show only traffic from：你可以指定只捕获哪个Windows进程中的请求； Show only Internet Explorer traffic：只显示IE发出的请求； Hide Windows RSS platform traffic：隐藏Windows RSS平台发出的请求； Request Headers 过滤Request header过滤规则： 经常使用：Show only if URL contains：只显示包含特定字符的请求； Hide if URL contains：隐藏包含特定字符的请求； Flag requests with headers：标记带有特定header的请求； Delete request headers：删除请求header； Set request header：设置请求的header； Breakpoints断点设置规则： Break request on HTTP POST：给所有POST请求设置断点； Break request on HTTP GET with QueryString：给所有带参数的GET请求设置断点； Break on XMLHttpRequest：给所有XML请求设置断点； Break response on Content-Type：给包含特定的Content-Type返回设置断点； Response Status Code 过滤响应HTTP状态过滤规则： Hide success(2xx)：隐藏响应成功的session(2xx)； Hide Authentication demands(401,407)：隐藏未经授权被拒绝的session(401,407； Hide redirects(300,301,302,303,307)：隐藏重定向的session(300,301,302,303,307)； Hide Not Modified(304)：隐藏无变更的session(304)； Response HeadersResponse header过滤规则： Flag response that set cookies：标记会设置cookie的响应； Flag response with headers：标记带有特定header的响应； Delete response headers：删除响应header； Set response header：设置响应的header； Response Type and Size响应类型和大小过滤规则： Show all Content-Type：显示所有响应类型； Hide smaller than ？KB：隐藏小于指定大小的session； Hide larger than ？KB：隐藏大于指定大小的session； Time HeatMap：获得即时数据（绿色阴影代表响应时间在50毫秒以内；超过50毫秒但在300毫秒之内的响应条目没有颜色；响应时间在300至500毫秒之间的会涂以黄色；超过500毫秒的用红色底纹显示）； Block script files：阻止脚本文件，显示为404； Block image files：阻止图片文件； Block SWF files：阻止SWF文件； Block CSS files：阻止CSS文件； 鼠标右键菜单过滤功能","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"常见的运行异常","slug":"常见的运行异常","date":"2021-05-28T15:37:00.000Z","updated":"2021-06-18T15:37:00.000Z","comments":true,"path":"常见的运行异常.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8.html","excerpt":"​ 安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。","text":"​ 安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。 NullPointerException（空指针异常）​ 俗称NPE。调用了未经初始化的对象或者是不存在的对象。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 目前，客户端页面显示很多需要依赖服务端返回数据，当网络异常时，没有获取到对象，此时为null，就很容易出现nullpointerException异常。有可能也是代码错误，没有new造成的。 如何检测java.lang.NullPointerException检测NullPointerException非常简单，只需查看异常跟踪，它将显示异常的类名和行号。然后查看代码并查看可能为null。只要看一下上面的所有例子，从堆栈跟踪中可以清楚地看出是什么导致了null指针异常。 错误示例1. 调用实例方法时出现NullPointerException 示例代码 - 123456789101112131415161718public class Temp &#123; public static void main(String[] args) &#123; Temp t = initT(); t.foo(&quot;Hi&quot;); &#125; private static Temp initT() &#123; return null; &#125; public void foo(String s) &#123; System.out.println(s.toLowerCase()); &#125;&#125; 当运行上面的程序时，它会抛出NullPointerException异常错误消息。 123Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 在语句t.foo(&quot;Hi&quot;)中抛出NullPointerException异常; 因为t在这里为null。 2. 访问/修改null对象的字段时出现NullPointerException 示例代码 - 123456789101112131415161718public class Temp &#123; public int x = 10; public static void main(String[] args) &#123; Temp t = initT(); int i = t.x; &#125; private static Temp initT() &#123; return null; &#125;&#125; 执行上面示例代码，得到以下结果 - 123Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:9) 语句int i = t.x中抛出NullPointerException异常; 因为t在这里为null。 3. 在方法参数中传递null时NullPointerException 示例代码 - 123456789101112public class Temp &#123; public static void main(String[] args) &#123; foo(null); &#125; public static void foo(String s) &#123; System.out.println(s.toLowerCase()); &#125;&#125; 这是java.lang.NullPointerException最常见的情况之一，因为它传递null参数给调用者。错误信息如下： 123Exception in thread &quot;main&quot; java.lang.NullPointerException at NPE.foo(NPE.java:9) at NPE.main(NPE.java:4) 4. 抛出null时抛出java.lang.NullPointerException 示例代码 12345public class Temp &#123; public static void main(String[] args) &#123; throw null; &#125;&#125; 下面是上面程序的异常堆栈跟踪，由于throw null所以抛出NullPointerException异常。 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:5) 5. 获取null数组的长度时抛出java.lang.NullPointerException 1234567public class Temp &#123; public static void main(String[] args) &#123; int[] data = null; int len = data.length; &#125;&#125; 执行上面示例代码，得到以下结果 - 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 6. 访问null数组的索引值时出现NullPointerException 示例代码 - 1234567public class Temp &#123; public static void main(String[] args) &#123; int[] data = null; int len = data[2]; &#125;&#125; 执行上面示例代码，得到以下结果 - 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 7. 在null对象上同步时出现java.lang.NullPointerException 1234567891011public class Temp &#123; public static String mutex = null; public static void main(String[] args) &#123; synchronized(mutex) &#123; System.out.println(&quot;synchronized block&quot;); &#125; &#125;&#125; synchronized(mutex)将抛出NullPointerException，因为mutex对象为null。 8. java.lang.NullPointerException引发HTTP状态500 有时会将错误页面作为java Web应用程序响应发送，错误消息为“HTTP状态500 - 内部服务器错误”，根本原因就是java.lang.NullPointerException异常。 下面是一段编辑了Spring MVC Example项目并更改了HomeController方法，如下所示。 12345678@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) public String user(@Validated User user, Model model) &#123; System.out.println(&quot;User Page Requested&quot;); System.out.println(&quot;User Name: &quot;+user.getUserName().toLowerCase()); System.out.println(&quot;User ID: &quot;+user.getUserId().toLowerCase()); model.addAttribute(&quot;userName&quot;, user.getUserName()); return &quot;user&quot;; &#125; 下图显示了Web应用程序响应引发的错误消息。 下面是异常堆栈跟踪 - 12345678910111213141516171819202122232425HTTP Status 500 – Internal Server ErrorType Exception ReportMessage Request processing failed; nested exception is java.lang.NullPointerExceptionDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982) org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.NullPointerException com.journaldev.spring.controller.HomeController.user(HomeController.java:38) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:498) 根本原因是语句user.getUserId().toLowerCase()中引发了NullPointerException，因为user.getUserId()返回null。 解决方案​ 这种异常通常是调用一个对象的接口方法抛出的，在调用接口方法之前，要进行判空或者进行try-catch，这样基本可以规避大部分空指针异常。​ 最常见是在 回调接口, 如 网络请求回调，第三方登录回调 返回的时候 调用 context.startActivity 时 context 为空导致。可以在 context 为空的时候使用 Application Context， 加上 if (!(context instanceof Activity)) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); } ArrayindexOutOfBoundsExceptions（数组越界异常）出现的原因​ 如果访问数组元素的时候，索引编号并不存在 错误示例 使用不合法的索引访问数组时会报数组越界这种错误，数组arr的合法错误范围是[0, arr.length-1];当你访问这之外的索引时会报这个错。例如： 12345678public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3&#125;; for (int i = 0; i &lt;= arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 控制台输出的错误提示： 1234567java.lang.ArrayIndexOutOfBoundsException: 3at Test.main(Test.java:5)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:606)at edu.rice.cs.drjava.model.compiler.JavacCompiler.runCommand(JavacCompiler.java:272) 解决方案​ 这种情况一般要在数组循环前做好length判断，index超出length上限和下限时都会报错。举例如下：一个数组int test[N]，一共有N个元素分别是test[0]~test[N-1]，如果调用test[N]，将会报错。建议读取时，不要超过数组的长度（array.length）。参考链接Android中一种常见情形就是上拉刷新中header也会作为listview的第0个位置，如果判断失误很容易造成越界。 indexOutOfBoundsException（越界异常）出现的原因​ 该异常表示不合法下标，通常是因为访问了list不合法的位置，建议检查数据是否越界。 解决方案 1.遍历数组/字符串等集合前，要判断遍历对象的长度； 2.操作数组/字符串等集合前，要检查角标是否在长度允许范围内； 3.ListView操作不当也会引起该异常，这种情况下一般是由于List渲染的时候，外面的数据源发生变化导致的。举例如ListView滚动时点击刷新将会报错，解决方法是ListView滚动时将刷新置为不可点击。 outOfMemory（内存溢出）​ 指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存，俗称OOM 出现的原因​ （1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；​ （2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；​ （3）代码中存在死循环或循环产生过多重复的对象实体；​ （4）使用的第三方软件中的BUG；​ （5）启动参数内存值设定的过小； ​ 通俗解释：系统已经不能再分配出你所需要的空间，比如系统现在只有1G的空间，但是你偏偏要2个G空间，这就叫内存溢出 例子：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。 常见错误提示​ [相关例子说明][https://segmentfault.com/a/1190000017226359] ​ 1、OOM fo heap ：java.lang:OutOfMemoryError: Java heap space，此OOM是由于JVM中heap的最大值不满足需要，将设置heap的最大值调高即可。 ​ 2、OOM for Perm：java.lang:OutOfMemoryError: Java perm space，此OOM是由于JVM中perm的最大值不满足需要，将设置perm的最大值调高即可，参数样例为：-XX:MaxPermSize=512M ​ 3、OOM for GC=&gt;例如：java.lang:OutOfMemoryError: GC overhead limit exceeded，此OOM是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略 ​ 4、OOM for native thread created：java.lang.OutOfMemoryError: unable to create new native threa，此OOM是由于进程剩余的空间不足，导致创建进程失败 ​ 5、OOM for allocate huge array：Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: Requested array size exceeds VM limit，此类信息表明应用程序（或者被应用程序调用的APIs）试图分配一个大于堆大小的数组 ​ 6、OOM for small swap：Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?,抛出这类错误，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽 ​ 7、OutOfMemoryError： thrown while trying to throw OutOfMemoryError; no stack trace available，抛出这类错误，一般是由于方法重复调用、死循环引起，直至内存耗尽 内存泄漏： (Memory Leak)​ 指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 以产生的方式来分类，内存泄漏可以分为四类：（1）常发性内存泄漏：发生内存泄漏的代码会被多次执行到，每次被执行时都会导致一块内存泄漏。（2）偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。（3）一次性内存泄漏：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏。（4）隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。 memory leak会最终会导致out of memory！ 内存泄漏和内存溢出的相关说明例子：[博客园][https://www.cnblogs.com/xiaoxi/p/7354857.html]，[百度百科：内存泄漏][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA]，[百度百科：内存溢出][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F] 拓展知识​ jvm管理的内存大致包括三种不同类型的内存区域：Permanent Generation space（永久保存区域）、Heap space(堆区域)、Java Stacks(Java栈）。其中永久保存区域主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGen space区域，Class需要存储的内容主要包括方法和静态属性。堆区域用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。而Java栈跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。\u0010 illegalStateException（非法状态异常）常见错误提示java.lang.IllegalStateException：Cannot forward a response that is already committed IllegalStateException：response already commited IllegalStateException：getOutputStream() has already been called for this request 出现原因 ​ 该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。 ​ 这里涉及到java的io流：flush()，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中，然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行清空输出，因此flush()的作用就是保证缓存清空输出。 response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。 illegalArguementException（非法参数异常）常见错误提示 java.lang.IllegalArgumentException 出现原因​ 参数不匹配异常，通常由于传递了不正确的参数导致。 常见于： Activity、Service状态异常； 非法URL； UI线程操作 Fragment中嵌套了子Fragment，Fragment被销毁，而内部Fragment未被销毁，所以导致再次加载时重复，在onDestroyView() 中将内部Fragment销毁即可 在请求网络的回调中使用了glide.into(view),view已经被销毁会导致该错误 解决方法​ 因为参数不合法导致抛出IllegalArgumentException，请根据堆栈信息描述的出错的函数参数，按照要求传入正确的参数。 举例错误堆栈信息 123456789101112131415161718192021java.lang.IllegalArgumentException: Cannot locate declared field class org.apache.http.impl.client.HttpClientBuilder.sslContext at org.apache.commons.lang3.Validate.isTrue(Validate.java:155) at org.apache.commons.lang3.reflect.FieldUtils.readDeclaredField(FieldUtils.java:512) at com.gargoylesoftware.htmlunit.HttpWebConnection.getField(HttpWebConnection.java:1095) at com.gargoylesoftware.htmlunit.HttpWebConnection.createConnectionManager(HttpWebConnection.java:1017) at com.gargoylesoftware.htmlunit.HttpWebConnection.getResponse(HttpWebConnection.java:174) at com.gargoylesoftware.htmlunit.WebClient.loadWebResponseFromWebConnection(WebClient.java:1397) at com.gargoylesoftware.htmlunit.WebClient.loadWebResponse(WebClient.java:1315) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:394) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:315) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:463) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:448) at com.epoint.dzdamanager.login.DnetDefaultLoginForUrlImpl.doLogin(DnetDefaultLoginForUrlImpl.java:87) at com.epoint.ztb.htmlutil.HtmlToPdf.getHtmlPageFromUrlF9(vb:80) at com.epoint.dzdamanager.domain.DownZtbData.pageToPdf(DownZtbData.java:446) at com.epoint.dzdamanager.domain.DownZtbData.genFileList(DownZtbData.java:319) at com.epoint.dzdamanager.domain.DownZtbData.workForBarStep(DownZtbData.java:152) at com.epoint.dzdamanager.pack.job.DoPackServiceImp.doPack(DoPackServiceImp.java:87) at com.epoint.dzdamanager.pack.job.DoPackJob.execute(DoPackJob.java:35) at org.quartz.core.JobRunShell.run(JobRunShell.java:202) at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) 例子分析重点提示Cannot locate declared field class org.apache.http.impl.client.HttpClientBuilder.sslContext经排查，htmlunit.jar包在4.4.1版本中HttpClientBuilder该类无sslContext属性，属性名称为sslcontext，从而引发参数报错。 ClassCastException（类型强制转换异常）常见错误提示java.lang.ClassCastException 出现原因​ 当试图将对某个对象强制执行向下转型，但该对象又不可转换为其子类的实例时将引发该异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。例子 java.lang.ArithmeticException （算术条件异常）​ 异常算术条件时抛出。 例如，“除以零”的整数会抛出。 错误示例123456789public class EXDemo &#123; public static void main(String[] args)&#123; int x = 10; int y = 0; int temp = x/y; //此处出现异常 System.out.println(x/y); System.out.println(&quot;计算结束&quot;); &#125;&#125; 运行结果如下： 12Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at EXDemo.main(EXDemo.java:5) 在以上例子中,因为被除数为0,所以程序中出现了异常,从运行结果可以发现,如果不对异常进行处理,则一旦出现了异常后,程序就立刻推出,所以后面的语句并没有打印输出. 在计算机的发展中有两大计算机”杀手”,一个是断电,另外一个是被除数为0;因为被除数为0在数学上的解是无穷大,对于计算机来说,意味着内存将被全部占满.","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"adb shell pm 命令解析","slug":"adb pm 命令","date":"2021-05-16T02:42:00.000Z","updated":"2021-05-21T13:57:00.000Z","comments":true,"path":"adb pm 命令.html","link":"","permalink":"https://www.lauyongyi.cn/adb%20pm%20%E5%91%BD%E4%BB%A4.html","excerpt":"​ pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。","text":"​ pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。 pm命令格式pm &lt;command&gt; pm命令实的实现方式在Pm.java，最后大多数都是调用PackageManagerService相应的方法来完成的。 pm命令概览：pm命令详情和翻译放在文末 命令 功能 实现方法 list packages 列举app包信息 PMS.getInstalledPackages install [options] 安装应用 PMS.installPackageAsUser uninstall [options] 卸载应用 IPackageInstaller.uninstall enable &lt;包名或组件名&gt; enable PMS.setEnabledSetting disable &lt;包名或组件名&gt; disable PMS.setEnabledSetting hide 隐藏应用 PMS.setApplicationHiddenSettingAsUser unhide 显示应用 PMS.setApplicationHiddenSettingAsUser get-install-location 获取安装位置 PMS.getInstallLocation set-install-location 设置安装位置 PMS.setInstallLocation path 查看App路径 PMS.getPackageInfo clear 清空App数据 AMS.clearApplicationUserData get-max-users 最大用户数 UserManager.getMaxSupportedUsers force-dex-opt dex优化 PMS.forceDexOpt dump dump信息 AM.dumpPackageStateStatic trim-caches &lt;目标size&gt; 紧缩cache目标大小 PMS.freeStorageAndNotify pm命令详情123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396$ pm -h Package manager (package) commands: help Print this help text. path [--user USER_ID] PACKAGE Print the path to the .apk of the given PACKAGE. dump PACKAGE Print various system state associated with the given PACKAGE. has-feature FEATURE_NAME [version] Prints true and returns exit status 0 when system has a FEATURE_NAME, otherwise prints false and returns exit status 1 &#x2F;&#x2F; 列出所有硬件相关信息 list features Prints all features of the system. &#x2F;&#x2F; 列出所有的instrumentation测试包 list instrumentation [-f] [TARGET-PACKAGE] Prints all test packages; optionally only those targeting TARGET-PACKAGE Options: -f: dump the name of the .apk file containing the test package &#x2F;&#x2F; 打印当前设备所支持的所有库 list libraries Prints all system libraries. &#x2F;&#x2F; 包信息查询，可用参数如下： list packages [-f] [-d] [-e] [-s] [-3] [-i] [-l] [-u] [-U] [--show-versioncode] [--apex-only] [--uid UID] [--user USER_ID] [FILTER] Prints all packages; optionally only those whose name contains the text in FILTER. Options are: -f: see their associated file &#x2F;&#x2F;查看应用关联的文件信息。 -a: all known packages (but excluding APEXes) &#x2F;&#x2F;安装的所有包名，但不包括APEXes。 -d: filter to only show disabled packages &#x2F;&#x2F;只显示已禁用的软件包 -e: filter to only show enabled packages &#x2F;&#x2F;只显示已启用的软件包 -s: filter to only show system packages &#x2F;&#x2F;只显示系统应用 -3: filter to only show third party packages &#x2F;&#x2F;只显示第三方应用 -i: see the installer for the packages &#x2F;&#x2F;显示应用安装来源 -l: ignored (used for compatibility with older releases) &#x2F;&#x2F;被忽略（用于与旧版本兼容） -U: also show the package UID &#x2F;&#x2F;显示包名并显示UID -u: also include uninstalled packages &#x2F;&#x2F; 显示可卸载的软件包名 --show-versioncode: also show the version code &#x2F;&#x2F;显示包名和版本号 --apex-only: only show APEX packages &#x2F;&#x2F;只显示APEX包名 --uid UID: filter to only show packages with the given UID &#x2F;&#x2F;显示指定UID的包名 --user USER_ID: only list packages belonging to the given user &#x2F;&#x2F;仅列出属于指定用户的软件包 &#x2F;&#x2F; 权限组查询 list permission-groups Prints all known permission groups. &#x2F;&#x2F; 打印权限 list permissions [-g] [-f] [-d] [-u] [GROUP] Prints all known permissions; optionally only those in GROUP. Options are: -g: organize by group &#x2F;&#x2F;按组进行列出权限 -f: print all information &#x2F;&#x2F;打印所有信息 -s: short summary &#x2F;&#x2F;简短的摘要 -d: only list dangerous permissions &#x2F;&#x2F;只有危险的权限列表 -u: list only the permissions users will see &#x2F;&#x2F;只有权限的用户将看到列表用户自定义权限 &#x2F;&#x2F; 打印进行中的会话 list staged-sessions [--only-ready] [--only-sessionid] [--only-parent] Prints all staged sessions. --only-ready: show only staged sessions that are ready &#x2F;&#x2F;仅显示ready的会话 --only-sessionid: show only sessionId of each session &#x2F;&#x2F;只显示会话的sessionid --only-parent: hide all children sessions &#x2F;&#x2F;隐藏所有子级会话 &#x2F;&#x2F; 打印用户信息 list users Prints all users. resolve-activity [--brief] [--components] [--query-flags FLAGS] [--user USER_ID] INTENT Prints the activity that resolves to the given INTENT. query-activities [--brief] [--components] [--query-flags FLAGS] [--user USER_ID] INTENT Prints all activities that can handle the given INTENT. query-services [--brief] [--components] [--query-flags FLAGS] [--user USER_ID] INTENT Prints all services that can handle the given INTENT. query-receivers [--brief] [--components] [--query-flags FLAGS] [--user USER_ID] INTENT Prints all broadcast receivers that can handle the given INTENT. &#x2F;&#x2F;通过指定路径安装apk到手机中(与adb install不同的是adb install安装的.apk是在你的电脑上，而pm install安装的apk是存储在你的手机中) install [-rtfdgw] [-i PACKAGE] [--user USER_ID|all|current] [-p INHERIT_PACKAGE] [--install-location 0&#x2F;1&#x2F;2] [--install-reason 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4] [--originating-uri URI] [--referrer URI] [--abi ABI_NAME] [--force-sdk] [--preload] [--instant] [--full] [--dont-kill] [--enable-rollback] [--force-uuid internal|UUID] [--pkg PACKAGE] [-S BYTES] [--apex] [--wait TIMEOUT] [PATH [SPLIT...]|-] Install an application. Must provide the apk data to install, either as file path(s) or &#39;-&#39; to read from stdin. Options are: -R: disallow replacement of existing application &#x2F;&#x2F;禁止替换现有应用程序 -t: allow test packages &#x2F;&#x2F;运行测试包 -i: specify package name of installer owning the app &#x2F;&#x2F;指定安装包的包名 -f: install application on internal flash &#x2F;&#x2F;在内部闪存上安装应用程序 -d: allow version code downgrade (debuggable packages only) &#x2F;&#x2F;运行降级安装 -p: partial application install (new split on top of existing pkg) -g: grant all runtime permissions &#x2F;&#x2F;授予所有运行权限 -S: size in bytes of package, required for stdin --user: install under the given user. &#x2F;&#x2F;指定用户安装 --dont-kill: installing a new feature split, don&#39;t kill running app &#x2F;&#x2F;不停止当前APP运行的情况下，安装新功能。 --restrict-permissions: don&#39;t whitelist restricted permissions at install &#x2F;&#x2F;安装时不将受限权限列入白名单 --originating-uri: set URI where app was downloaded from &#x2F;&#x2F;设置APP下载的URI --referrer: set URI that instigated the install of the app &#x2F;&#x2F;设置应用安装的URI --pkg: specify expected package name of app being installed --abi: override the default ABI of the platform --instant: cause the app to be installed as an ephemeral install app --full: cause the app to be installed as a non-ephemeral full app --install-location: force the install location: 0&#x3D;auto, 1&#x3D;internal only, 2&#x3D;prefer external --install-reason: indicates why the app is being installed: 0&#x3D;unknown, 1&#x3D;admin policy, 2&#x3D;device restore, 3&#x3D;device setup, 4&#x3D;user request --force-uuid: force install on to disk volume with given UUID --apex: install an .apex file, not an .apk --wait: when performing staged install, wait TIMEOUT milliseconds for pre-reboot verification to complete. If TIMEOUT is not specified it will wait for 60000 milliseconds. &#x2F;&#x2F;执行分阶段安装 install-existing [--user USER_ID|all|current] [--instant] [--full] [--wait] [--restrict-permissions] PACKAGE Installs an existing application for a new user. Options are: --user: install for the given user. --instant: install as an instant app --full: install as a full app --wait: wait until the package is installed --restrict-permissions: don&#39;t whitelist restricted permissions install-create [-lrtsfdg] [-i PACKAGE] [--user USER_ID|all|current] [-p INHERIT_PACKAGE] [--install-location 0&#x2F;1&#x2F;2] [--install-reason 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4] [--originating-uri URI] [--referrer URI] [--abi ABI_NAME] [--force-sdk] [--preload] [--instant] [--full] [--dont-kill] [--force-uuid internal|UUID] [--pkg PACKAGE] [--apex] [-S BYTES] [--multi-package] [--staged] Like &quot;install&quot;, but starts an install session. Use &quot;install-write&quot; to push data into the session, and &quot;install-commit&quot; to finish. install-write [-S BYTES] SESSION_ID SPLIT_NAME [PATH|-] Write an apk into the given install session. If the path is &#39;-&#39;, data will be read from stdin. Options are: -S: size in bytes of package, required for stdin install-remove SESSION_ID SPLIT... Mark SPLIT(s) as removed in the given install session. install-add-session MULTI_PACKAGE_SESSION_ID CHILD_SESSION_IDs Add one or more session IDs to a multi-package session. install-commit SESSION_ID Commit the given active install session, installing the app. install-abandon SESSION_ID Delete the given active install session. set-install-location LOCATION Changes the default install location. NOTE this is only intended for debugging; using this can cause applications to break and other undersireable behavior. LOCATION is one of: 0 [auto]: Let system decide the best location 1 [internal]: Install on internal device storage 2 [external]: Install on external media get-install-location Returns the current install location: 0, 1 or 2 as per set-install-location. move-package PACKAGE [internal|UUID] move-primary-storage [internal|UUID] uninstall [-k] [--user USER_ID] [--versionCode VERSION_CODE] PACKAGE [SPLIT...] Remove the given package name from the system. May remove an entire app if no SPLIT names specified, otherwise will remove only the splits of the given app. Options are: -k: keep the data and cache directories around after package removal. --user: remove the app from the given user. --versionCode: only uninstall if the app has the given version code. clear [--user USER_ID] PACKAGE Deletes all data associated with a package. enable [--user USER_ID] PACKAGE_OR_COMPONENT disable [--user USER_ID] PACKAGE_OR_COMPONENT disable-user [--user USER_ID] PACKAGE_OR_COMPONENT disable-until-used [--user USER_ID] PACKAGE_OR_COMPONENT default-state [--user USER_ID] PACKAGE_OR_COMPONENT These commands change the enabled state of a given package or component (written as &quot;package&#x2F;class&quot;). hide [--user USER_ID] PACKAGE_OR_COMPONENT unhide [--user USER_ID] PACKAGE_OR_COMPONENT suspend [--user USER_ID] TARGET-PACKAGE Suspends the specified package (as user). unsuspend [--user USER_ID] TARGET-PACKAGE Unsuspends the specified package (as user). grant [--user USER_ID] PACKAGE PERMISSION revoke [--user USER_ID] PACKAGE PERMISSION These commands either grant or revoke permissions to apps. The permissions must be declared as used in the app&#39;s manifest, be runtime permissions (protection level dangerous), and the app targeting SDK greater than Lollipop MR1. reset-permissions Revert all runtime permissions to their default state. set-permission-enforced PERMISSION [true|false] get-privapp-permissions TARGET-PACKAGE Prints all privileged permissions for a package. get-privapp-deny-permissions TARGET-PACKAGE Prints all privileged permissions that are denied for a package. get-oem-permissions TARGET-PACKAGE Prints all OEM permissions for a package. set-app-link [--user USER_ID] PACKAGE &#123;always|ask|never|undefined&#125; get-app-link [--user USER_ID] PACKAGE trim-caches DESIRED_FREE_SPACE [internal|UUID] Trim cache files to reach the given free space. list users Lists the current users. create-user [--profileOf USER_ID] [--managed] [--restricted] [--ephemeral] [--guest] [--pre-create-only] [--user-type USER_TYPE] USER_NAME Create a new user with the given USER_NAME, printing the new user identifier of the user. USER_TYPE is the name of a user type, e.g. android.os.usertype.profile.MANAGED. If not specified, the default user type is android.os.usertype.full.SECONDARY. --managed is shorthand for &#39;--user-type android.os.usertype.profile.MANAGED&#39;. --restricted is shorthand for &#39;--user-type android.os.usertype.full.RESTRICTED&#39;. --guest is shorthand for &#39;--user-type android.os.usertype.full.GUEST&#39;. remove-user USER_ID Remove the user with the given USER_IDENTIFIER, deleting all data associated with that user set-user-restriction [--user USER_ID] RESTRICTION VALUE get-max-users get-max-running-users compile [-m MODE | -r REASON] [-f] [-c] [--split SPLIT_NAME] [--reset] [--check-prof (true | false)] (-a | TARGET-PACKAGE) Trigger compilation of TARGET-PACKAGE or all packages if &quot;-a&quot;. Options are: -a: compile all packages -c: clear profile data before compiling -f: force compilation even if not needed -m: select compilation mode MODE is one of the dex2oat compiler filters: assume-verified extract verify quicken space-profile space speed-profile speed everything -r: select compilation reason REASON is one of: first-boot boot install bg-dexopt ab-ota inactive shared --reset: restore package to its post-install state --check-prof (true | false): look at profiles when doing dexopt? --secondary-dex: compile app secondary dex files --split SPLIT: compile only the given split name --compile-layouts: compile layout resources for faster inflation force-dex-opt PACKAGE Force immediate execution of dex opt for the given PACKAGE. bg-dexopt-job Execute the background optimizations immediately. Note that the command only runs the background optimizer logic. It may overlap with the actual job but the job scheduler will not be able to cancel it. It will also run even if the device is not in the idle maintenance mode. reconcile-secondary-dex-files TARGET-PACKAGE Reconciles the package secondary dex files with the generated oat files. dump-profiles TARGET-PACKAGE Dumps method&#x2F;class profile files to &#x2F;data&#x2F;misc&#x2F;profman&#x2F;TARGET-PACKAGE.txt snapshot-profile TARGET-PACKAGE [--code-path path] Take a snapshot of the package profiles to &#x2F;data&#x2F;misc&#x2F;profman&#x2F;TARGET-PACKAGE[-code-path].prof If TARGET-PACKAGE&#x3D;android it will take a snapshot of the boot image set-home-activity [--user USER_ID] TARGET-COMPONENT Set the default home activity (aka launcher). TARGET-COMPONENT can be a package name (com.package.my) or a full component (com.package.my&#x2F;component.name). However, only the package name matters: the actual component used will be determined automatically from the package. set-installer PACKAGE INSTALLER Set installer package name get-instantapp-resolver Return the name of the component that is the current instant app installer. set-harmful-app-warning [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; [&lt;WARNING&gt;] Mark the app as harmful with the given warning message. get-harmful-app-warning [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; Return the harmful app warning message for the given app, if present uninstall-system-updates [&lt;PACKAGE&gt;] Removes updates to the given system application and falls back to its &#x2F;system version. Does nothing if the given package is not a system app. If no package is specified, removes updates to all system applications. get-moduleinfo [--all | --installed] [module-name] Displays module info. If module-name is specified only that info is shown By default, without any argument only installed modules are shown. --all: show all module info --installed: show only installed modules log-visibility [--enable|--disable] &lt;PACKAGE&gt; Turns on debug logging when visibility is blocked for the given package. --enable: turn on debug logging (default) --disable: turn off debug logging&lt;INTENT&gt; specifications include these flags and arguments: [-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;] [-t &lt;MIME_TYPE&gt;] [-i &lt;IDENTIFIER&gt;] [-c &lt;CATEGORY&gt; [-c &lt;CATEGORY&gt;] ...] [-n &lt;COMPONENT_NAME&gt;] [-e|--es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; ...] [--esn &lt;EXTRA_KEY&gt; ...] [--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; ...] [--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; ...] [--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; ...] [--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; ...] [--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; ...] [--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;] [--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]] (mutiple extras passed as Integer[]) [--eial &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]] (mutiple extras passed as List&lt;Integer&gt;) [--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]] (mutiple extras passed as Long[]) [--elal &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]] (mutiple extras passed as List&lt;Long&gt;) [--efa &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;[,&lt;EXTRA_FLOAT_VALUE...]] (mutiple extras passed as Float[]) [--efal &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;[,&lt;EXTRA_FLOAT_VALUE...]] (mutiple extras passed as List&lt;Float&gt;) [--esa &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;[,&lt;EXTRA_STRING_VALUE...]] (mutiple extras passed as String[]; to embed a comma into a string, escape it using &quot;\\,&quot;) [--esal &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;[,&lt;EXTRA_STRING_VALUE...]] (mutiple extras passed as List&lt;String&gt;; to embed a comma into a string, escape it using &quot;\\,&quot;) [-f &lt;FLAG&gt;] [--grant-read-uri-permission] [--grant-write-uri-permission] [--grant-persistable-uri-permission] [--grant-prefix-uri-permission] [--debug-log-resolution] [--exclude-stopped-packages] [--include-stopped-packages] [--activity-brought-to-front] [--activity-clear-top] [--activity-clear-when-task-reset] [--activity-exclude-from-recents] [--activity-launched-from-history] [--activity-multiple-task] [--activity-no-animation] [--activity-no-history] [--activity-no-user-action] [--activity-previous-is-top] [--activity-reorder-to-front] [--activity-reset-task-if-needed] [--activity-single-top] [--activity-clear-task] [--activity-task-on-home] [--activity-match-external] [--receiver-registered-only] [--receiver-replace-pending] [--receiver-foreground] [--receiver-no-abort] [--receiver-include-background] [--selector] [&lt;URI&gt; | &lt;PACKAGE&gt; | &lt;COMPONENT&gt;] 名词解释： APEX(Android Pony EXpress ) 是Google在Android 10中引进的一种用于管理较低级别系统模块的安装包管理器，用来更新一些不适用APK安装流程的系统组件，比如Bionic 、libnativebridge、libnativehelper、libnativeloader以及一些运行时类库。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Crash详解","slug":"Crash详解","date":"2021-05-10T13:59:00.000Z","updated":"2020-05-10T14:14:00.000Z","comments":true,"path":"Crash详解.html","link":"","permalink":"https://www.lauyongyi.cn/Crash%E8%AF%A6%E8%A7%A3.html","excerpt":"Android APP Crash通常是由未捕获的Exception或signal引起app异常退出。","text":"Android APP Crash通常是由未捕获的Exception或signal引起app异常退出。 如果app使用Java语言编写，那么，当Throwable抛出未处理的异常时，此时就会引起 app Crash。 如果app 使用native-code编写，那么，当执行时遇到未处理的signal（例如SIGSEGV）时，app就会 Crash并退出。 当应用程序崩溃时，Android终止应用程序的进程并显示一个对话框，让用户知道应用程序已经停止。如下图。 App Crash 不仅发生在前台进程，任何app组件，例如Broadcast Receivers,Content Providers,Service等在后台运行的组件，也可以引起App Crash。这些Crash很容易引起用户混淆，因为他们没有直接参与到你的app中。 分析App Crash解决崩溃可能很困难。 但是，如果您能够确定崩溃的根本原因，则很可能可以找到解决方案。 有很多情况可能会导致应用程序崩溃。 一些原因是显而易见的，比如检查一个空值或空字符串，而另外一些更微妙，比如将无效参数传递给API甚至是复杂的多线程交互。 读取堆栈信息解决App Crash，首先要找到在那些代码发生的。你可以通过logcat或者收集工具如play Console，bugly等输出的堆栈信息进行分析查看。 下面是一个Crash示例： 123456789101112131415--------- beginning of crash AndroidRuntime: FATAL EXCEPTION: main Process: com.android.developer.crashsample, PID: 3686 java.lang.NullPointerException: crash sample at com.android.developer.crashsample.MainActivity$1.onClick(MainActivity.java:27) at android.view.View.performClick(View.java:6134) at android.view.View$PerformClick.run(View.java:23965) at android.os.Handler.handleCallback(Handler.java:751) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:156) at android.app.ActivityThread.main(ActivityThread.java:6440) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:746) --------- beginning of system 上述Crash 堆栈信息包含 以下信息 1.Crash app 包名 2.Crash app PID 3.引起Crash的异常信息（此异常时引起Crash的重要原因） 4.引起Crash 的代码位置，行号，哪个函数调用等等 5.对于被调用的每个函数，另一行显示前面的调用站点（称为栈帧）。 通过走栈和检查代码，你可能会发现一个地方传递了一个不正确的值。 如果您的代码没有出现在堆栈跟踪中，则可能是在某处将异常操作传递给了一个无效的参数。 您可以经常通过检查堆栈跟踪的每一行，找到您使用的任何API类，并确认您传递的参数是正确的，并且从允许的地方调用该类来判断发生了什么。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"Android Uiantomator2.0脚本编写基础知识","slug":"Android Uiantomator2.0脚本编写基础","date":"2021-03-10T12:16:00.000Z","updated":"2021-06-18T10:33:00.000Z","comments":true,"path":"Android Uiantomator2.0脚本编写基础.html","link":"","permalink":"https://www.lauyongyi.cn/Android%20Uiantomator2.0%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80.html","excerpt":"UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。","text":"UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。 UiautomatorViewer工具​ uiautomatorviewer是android SDK自带的一个元素定位工具。通过截屏并分析XML布局文件的方式，为用户提供控件信息查看服务。使用uiautomatorviewer，你可以检查一个应用的UI来查看应用的布局和组件以及相关的属性。该工具位于SDK目录下的tools\\bin子目录下。 启动UiUiautomatorViewer​ 方法一：直接进入进入SDK目录下的tools\\bin目录下双击uiautomatorviewer.bat就可以启动。（旧版本的在SDK目录下的tools） ​ 方法二：将环境变量配置到SDK目录下的tools\\bin目录，在命令行工具执行：uiautomatorviewer 核心定位元素 属性 描述 resource-id 资源ID，需要操作的组件基本都会有ID text 文字属性，显示在组件上的文字 content-desc 描述，常用于提示操作 checken 选择属性，常见开关、单/复选和开关状态 focused 焦点属性，如输入框光标的闪动，说明焦点在输入框 搜索对象 属性 返回值 API By类 resource-id static BySelector res(java.lang.String resourceName) text static BySelector text(java.lang.String text) content-desc static BySelector decs(java.lang.String contentDescription) checken static BySelector checked(boolean isChecked) focused static BySelector focused(boolean isFocused) 常见组件操作 常见组件操作 类（UiObject2） 点击 public boolean click() 长按 public boolean longclick() 拖动 public void drag(Point dest) 输入 public boolean setText(String text) 常见设备操作 常见设备操作 类（UiDevice） 点击 click(int x, int y) 按键 pressKeyCode(int KeyCode) 滑动 swipe(int startX, int StartY, int endX, int endY, int steps) 1个steps等于5ms。 用例注释生命周期@Before 每次用例开始前都执行 @Test 测试用例 @After 每次用例结束后都执行","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"安卓shell脚本","slug":"安卓Shell脚本","date":"2021-02-15T09:30:00.000Z","updated":"2021-02-16T06:39:00.000Z","comments":true,"path":"安卓Shell脚本.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93Shell%E8%84%9A%E6%9C%AC.html","excerpt":"​ 在做测试Android应用时，经常需要执行某些重复的操作，如果设备支持adb调试，可以使用python、java等编写自动化脚本，以实现自动执行重复操作，解放人力。但如果遇到不支持ADB调试的设备时，只能使用串口工具，此时python、java就显得些乏力，这时候，就可以使用shell脚本。","text":"​ 在做测试Android应用时，经常需要执行某些重复的操作，如果设备支持adb调试，可以使用python、java等编写自动化脚本，以实现自动执行重复操作，解放人力。但如果遇到不支持ADB调试的设备时，只能使用串口工具，此时python、java就显得些乏力，这时候，就可以使用shell脚本。 1、脚本编写 ​ 安卓的shell脚本编写和Linux系统一样。但因为机制原因，要执行shell脚本，需要到/data目录下才可以。 ​ 使用串口工具链接设备和电脑。 ​ 选择端口 ​ 进入到设备 ​ su获取权限 ​ cd /data 进入到data目录 ​ vi shellscript.sh 12345678910111213#示例脚本。模拟打开一个应用，然后发送指定键值进行操作#!/system/bin/shwhile truedo&#123; am start PackageName input keyevent KeyCode input keyevent KeyCode input keyevent KeyCode sleep 3 am force-stop PackageName&#125;done ​ 按 Esc #进入vi命令模式 ​ 输入 :wq #写入并退出 ​ chmod 777 shellscript.sh #赋予权限 ​ ./shellscript.sh #执行脚本","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Centos安装Tomcat","slug":"Centos安装Tomcat","date":"2021-01-22T05:02:00.000Z","updated":"2021-01-22T05:30:00.000Z","comments":true,"path":"Centos安装Tomcat.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85Tomcat.html","excerpt":"​ 记录centos安装Tomcat的方法和配置过程","text":"​ 记录centos安装Tomcat的方法和配置过程 前提条件：已经配置好jdk环境 方法一：yum​ 可以直接使用 yum -y install tomcat 进行安装 优点： ​ 省事 缺点： ​ 不一定是最新版本 安装成功后，需要配置防火墙 firewall-cmd --zone=public --add-port=8080/tcp --permanent 进行8080端口开放配置； 如果没有出现 success （一般都是提示防火墙没有运行） ，就需要检查防火墙是否开启 防火墙开启命令 systemctl start firewalld ，防火墙开启之后，在进行配置，然后重启防火墙，命令如下 firewall-cmd --reload。防火墙重启之后，就可以通过IP:8080进行访问了。 通常，这个时候访问，提示无法访问，原因是缺少管理包，执行以下命令，安装成功之后，就可以正常访问了。 yum install -y tomcat-webapps tomcat-admin-webapps Tomcat相关的操作命令如下： 1234567891011121314151617查看tomcat的状态systemctl status tomcat.service配置开机启动systemctl enable tomcat.service删除开机启动systemctl disable tomcat.service启动tomcatsystemctl start tomcat.service停止tomcatsystemctl stop tomcat.service重启tomcatsystemctl restart tomcat.service 关于安装目录说明： 123456相关目录及作用说明 &#x2F;etc&#x2F;tomcatXX - 全局配置 &#x2F;usr&#x2F;share&#x2F;tomcatXX&#x2F; - 程序主目录 &#x2F;usr&#x2F;share&#x2F;tomcatXX&#x2F;conf&#x2F;Catalina&#x2F;localhost&#x2F; - 本机部署的 Catalina 配置 &#x2F;var&#x2F;lib&#x2F;tomcatXX&#x2F; - 工作主目录 &#x2F;var&#x2F;lib&#x2F;tomcatXX&#x2F;webapps - （应用文件实际存放于此） 方法二：手动安装配置​ 进入到一个目录下例如 cd /usr/local/ ，然后执行下载命令 wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.41/bin/apache-tomcat-9.0.41.tar.gz 这里用的是9.0版本，可以自己调整版本。 然后解压 tar -zxvf apache-tomcat-9.0.41.tar.gz 重命名 mv apache-tomcat-9.0.41 tomcat 然后启动就可以了 tomcat常用命令 12345&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;startup.sh(启动命令)&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;shutdown.sh(关闭命令)ps -ef|grep java(查看tomcat进程)kill -9 进程号(杀死经常)tail -f &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;logs&#x2F;catalina.out(查看tomcat日志)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"python基础--列表、字符串、字典、元组之间的转换","slug":"python基础--列表、元组等转换","date":"2021-01-05T08:14:00.000Z","updated":"2021-01-14T06:08:00.000Z","comments":true,"path":"python基础--列表、元组等转换.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E7%AD%89%E8%BD%AC%E6%8D%A2.html","excerpt":"列表与字符串的相互转换列表转字符串将列表中的元素用特定的符号连接成一个字符串： 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; str1 = &#x27;&#x27;.join(list1)&gt;&gt;&gt; str1&#x27;abc&#x27;&gt;&gt;&gt; str2 = &#x27;-&#x27;.join(list1)&gt;&gt;&gt; str2&#x27;a-b-c&#x27;","text":"列表与字符串的相互转换列表转字符串将列表中的元素用特定的符号连接成一个字符串： 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; str1 = &#x27;&#x27;.join(list1)&gt;&gt;&gt; str1&#x27;abc&#x27;&gt;&gt;&gt; str2 = &#x27;-&#x27;.join(list1)&gt;&gt;&gt; str2&#x27;a-b-c&#x27; 列表中如果包含有其它元素，可以采用以下形式 12345678&gt;&gt;&gt; list3 = [&#x27;a&#x27;,1,2,&#x27;b&#x27;]&gt;&gt;&gt; str3 = [str(i) for i in list3]&gt;&gt;&gt; str3[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; list4 = [&#x27;a&#x27;,1,[&#x27;e&#x27;,9]]&gt;&gt;&gt; str4 = [str(i) for i in list4]&gt;&gt;&gt; str4[&#x27;a&#x27;, &#x27;1&#x27;, &quot;[&#x27;e&#x27;, 9]&quot;] 上面的方法，在列表中包含有其它列表类型的元素时，可能需要脱去列表最外层的中括号，才能在实际业务中应用。 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,7,&#x27;b&#x27;,8,&#x27;c&#x27;,[&#x27;e&#x27;,9]]&gt;&gt;&gt; str1 = str(list1)&gt;&gt;&gt; str1&quot;[&#x27;a&#x27;, 7, &#x27;b&#x27;, 8, &#x27;c&#x27;, [&#x27;e&#x27;, 9]]&quot;&gt;&gt;&gt; str2 = str1[1:-1]&gt;&gt;&gt; str2&quot;&#x27;a&#x27;, 7, &#x27;b&#x27;, 8, &#x27;c&#x27;, [&#x27;e&#x27;, 9]&quot; 字符串转列表如果字符串没有额外分隔符，可以用直接用list转换 1234&gt;&gt;&gt; str1 = &#x27;abcde&#x27;&gt;&gt;&gt; list1 = list(str1)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] 若字符串中同样的分隔符重复出现，则用分割法返回列表： 1234&gt;&gt;&gt; str1 = &#x27;a,b,c,d,e&#x27;&gt;&gt;&gt; list1 = str1.split(&#x27;,&#x27;)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] 若字符串中是列表的形式，可获取字符串内容，从而得到列表： 1234&gt;&gt;&gt; str1 = &quot;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&quot;&gt;&gt;&gt; list1 = eval(str1)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 列表与字典的相互转换列表转字典两个列表一一对应，分别表示key和value 123456789101112&gt;&gt;&gt; key1= [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]&gt;&gt;&gt; val1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; dict1 = dict(zip(key1,val1))&gt;&gt;&gt; dict1&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; key1 = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]&gt;&gt;&gt; val1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; zip(key1,val1)&lt;zip object at 0x000001A6162E1380&gt;&gt;&gt;&gt; list(zip(key1,val1))[(&#x27;1&#x27;, &#x27;a&#x27;), (&#x27;2&#x27;, &#x27;b&#x27;), (&#x27;3&#x27;, &#x27;c&#x27;)] zip 函数其实就是将两个列表一一对应的元素放到一起，结果为[(‘1’, ‘a’), (‘2’ ,‘b’), (‘3’, ‘c’)]，python3为了节省内存压缩成一个对象，通过list转换可以看到实际的结果。 嵌套列表转字典列表中的元素均为列表，其中的每一个列表都是一对key-value。 1234&gt;&gt;&gt; list1 = [[&#x27;1&#x27;,&#x27;a&#x27;], [&#x27;2&#x27;,&#x27;b&#x27;], [&#x27;3&#x27;,&#x27;c&#x27;]]&gt;&gt;&gt; dic1 = dict(list1)&gt;&gt;&gt; dic1&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 字典转列表123456789101112&gt;&gt;&gt; dic1 = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; list(dic1)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; list(dic1.keys())[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; list(dic1.values())[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; dic1.keys()dict_keys([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;])&gt;&gt;&gt; dic1.values()dict_values([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])&gt;&gt;&gt; 字典与字符串的相互转换字符串转字典字符串内容是字典，则用 eval 获取字符串内容： 123&gt;&gt;&gt; str1 = &quot;&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&quot;&gt;&gt;&gt; eval(str1)&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 还有一种方法是用 json 包中的函数，将json格式字符串转为字典。 12345&gt;&gt;&gt; import json&gt;&gt;&gt; str1 = &#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;&gt;&gt;&gt; json.loads(str1)&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; 字典转字符串json.dumps转换： 123&gt;&gt;&gt; dic = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; json.dumps(dic)&#x27;&#123;&quot;1&quot;: &quot;a&quot;, &quot;2&quot;: &quot;b&quot;, &quot;3&quot;: &quot;c&quot;&#125;&#x27; str强制转换 123&gt;&gt;&gt; dic = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; str(dic)&quot;&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&quot; 元组与字符串的相互转换元组转字符串str强制转换 1234567&gt;&gt;&gt; tup1= (1,2,3)&gt;&gt;&gt; str(tup1)&#x27;(1, 2, 3)&#x27;&gt;&gt;&gt; type(tup1)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; type(str(tup1))&lt;class &#x27;str&#x27;&gt; 用字符分割： 123&gt;&gt;&gt; tup2 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; &#x27; &#x27;.join(tup2)&#x27;1 2 3&#x27; 字符串转元组直接用tuple强制转： 123&gt;&gt;&gt; str1 = &#x27;123&#x27;&gt;&gt;&gt; tuple(str1)(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;) 字符串中包含元组，用eval获取字符串 123456789&gt;&gt;&gt; str2 = &quot;(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&quot;&gt;&gt;&gt; tup1 = eval(str2)&gt;&gt;&gt; tup1(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&gt;&gt;&gt; type(str2)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(tup1)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; 元组与列表的相互转换元组转列表123&gt;&gt;&gt; tup1 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; list(tup1)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] 列表转元组123&gt;&gt;&gt; list = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; tuple(list)(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) 元组与字典的相互转换元组转字典类似列表转字典，用zip函数过渡，之后用dict转换： 1234&gt;&gt;&gt; tup3 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; tup4 = (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)&gt;&gt;&gt; dict(zip(tup3,tup4))&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 字典转元组字典的key和value分别用tuple转为元组： 12345&gt;&gt;&gt; dic1 = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;&gt;&gt;&gt; tuple(dic1.keys())(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)&gt;&gt;&gt; tuple(dic1.values())(1, 2, 3)","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--常用内置函数","slug":"python基础--常用内置函数","date":"2020-12-31T08:30:00.000Z","updated":"2021-01-14T06:14:00.000Z","comments":true,"path":"python基础--常用内置函数.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.html","excerpt":"​ 主要记录python常用的内置函数","text":"​ 主要记录python常用的内置函数 标准输出函数print()​ print() 函数是所有python使用者最先接触也是用得最多的一个函数。print()函数一次可以打印多个对象，对象可以是任意类型。print()函数有以下几个默认参数： sep：间隔多个输出对象，默认值是一个空格 end：设定结尾，默认值是换行符 file：要写入的文件对象，默认是标准输出控制台（sys.stdout) flush：是否立即输出缓存，默认内容不会立即被输出 123456789101112 print(3,[1,2,3],&#123;&#x27;name&#x27;:&#x27;joe&#x27;&#125;)3 [1, 2, 3] &#123;&#x27;name&#x27;: &#x27;joe&#x27;&#125;&gt;&gt;&gt; print(1,2,&#x27;x&#x27;,&#x27;y&#x27;, sep=&#x27;*&#x27;) #多个打印对象之间使用星号分隔1*2*x*y&gt;&gt;&gt; for item in [1,2,&#x27;x&#x27;,&#x27;y&#x27;]:... print(item,end=&#x27;,&#x27;) #不换行打印...1,2,x,y,&gt;&gt;&gt; with open(r&#x27;d:\\print_out.txt&#x27;,&#x27;w&#x27;) as fp: #打印到文件... print(1,2,&#x27;x&#x27;,&#x27;y&#x27;, sep=&#x27;*&#x27;,file=fp)...&gt;&gt;&gt; 下面的例子，就是利用print()函数的多参数，实现的各种效果 12345678910111213141516171819202122232425262728293031 # -*- coding:utf-8 -*-import timedef printer(text, delay=0.85): &quot;&quot;&quot;打字机效果&quot;&quot;&quot; for ch in text: print(ch,end=&#x27;&#x27;, flush=True) time.sleep(delay) print()def waiting(cycle=20, delay=0.1): &quot;&quot;&quot;旋转式进度指示&quot;&quot;&quot; for i in range(cycle): for ch in [&#x27;-&#x27;,&#x27;\\\\&#x27;,&#x27;|&#x27;,&#x27;/&#x27;]: print(&#x27;\\b%s&#x27;%ch,end=&#x27;&#x27;,flush=True) time.sleep(delay) print()def cover(cycle=100,delay=0.2): &quot;&quot;&quot;覆盖式打印效果&quot;&quot;&quot; for i in range(cycle): s = &#x27;\\r%d&#x27;%i print(s.ljust(3),end=&#x27;&#x27;,flush=True) time.sleep(delay) print()if __name__ == &#x27;__main__&#x27;: printer(&#x27;落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦&#x27;) waiting(cycle=20) cover(cycle=20) 标准输入函数input()​ input() 函数用于程序执行过程中接收键盘输入。按回车键，input() 函数即返回从键盘输入的字符串，但不包括回车符。因为 input()函数本身具备IO阻塞的功能，所以也可以在程序中作为调试断点来使用。input()函数没有默认参数，接收一个字符串作为输入提示信息。 示例代码： 1234567&gt;&gt;&gt; nums = input()1 2 3&gt;&gt;&gt; print(nums) #这里nums 是一个字符串，不是整数1 2 3&gt;&gt;&gt; [int(item) for item in nums.split()] #这里进行转换，变成整数[1, 2, 3]&gt;&gt;&gt; 可迭代对象长度函数len()​ len 是 length 的缩写，该函数可以返回列表、元组、字典、字符串等可迭代对象的长度（或称为元素数量）。 示例代码： 12345678910&gt;&gt;&gt; len(&#x27;asadasdasd&#x27;)10&gt;&gt;&gt; len([3,4,5])3&gt;&gt;&gt; len(&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2&#125;)2&gt;&gt;&gt; len(&#123;True,False,None&#125;)3&gt;&gt;&gt; len(range(5))5 序列生成器函数range()​ range() 函数可以返回一个整数序列，只是无法看到这个序列的全貌，也不能访问其中的某个元素。只能从头开始依次便利每一个元素。 range() 函数可以接受一个、两个、或者三个整型参数。 1234567891011121314151617&gt;&gt;&gt; type(range(5))&lt;class &#x27;range&#x27;&gt;&gt;&gt;&gt; for i in range(5): #默认从0开始，步长为1... print(i, end=&#x27;,&#x27;)...0,1,2,3,4,&gt;&gt;&gt; for i in range(5,10): #在[5,10]区间内生成序列，步长为1... print(i, end=&#x27;,&#x27;)...5,6,7,8,9,&gt;&gt;&gt; for i in range(1,10,2): #在[1,10]区间内生成序列，步长为2... print(i,end=&#x27;,&#x27;)...1,3,5,7,9,&gt;&gt;&gt; list(range(10)) #转换成list[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; 格式化输出函数format()Python中格式化输出字符串使用 format() 函数, 字符串的参数使用{NUM}进行表示, 0表示第一个参数, 1表示第二个参数, 以后顺次递加。 使用”:”, 指定代表元素需要的操作, 如”:.3”小数点三位, “:8”占8个字符空间等; 数字(0, 1, …)即代表format()里面的元素, 所以可以使用”.”调用元素的方法; 常用的格式化符号 符号 说明 {:.2f} 四舍五入，保留小数点后两位 {:.+2f} 四舍五入，保留小数点后两位，带符号 {:0&gt;2d} 整数左侧部0，总长度为2 {:X&lt;4d} 整数右侧补X，总长度未4 {:,} 为整数增加逗号分隔符 {:.2%} 百分比格式化，保留小数点后两位 {:.2e} 科学计数法，保留小数点后两位 {:&gt;10d} 长度为10以内右对齐 {:&lt;10d} 长度为10以内左对齐 {:^0d} 长度为10以内居中对齐 {:b} 转为二进制 {:#b} 转为带前缀0b {:o} 转为八进制 {:#o} 转为带前缀0o的八进制 {:x} 转为16进制 {:#x} 转为带前缀0x的十六进制 {:#X} 转为带前缀0X的十六进制 也可以使用% 实现格式化字符串输出 符号 说明 %d或%i 转为带符号的十进制形式的整数 %o 转为带符号的八进制形式整数 %x或%X 转为带符号的十六进制形式整数 %e或%E 转为科学计数法表示的浮点数 %f或%F 转为十进制形式的浮点数 %g或%G 智能选择使用%e、%E或%f、%F %c 格式化字符及其ASCII码 %r 使用repr()变量或表达式转为字符串 %s 使用str()变量或表达式转为字符串 示例代码12345&gt;&gt;&gt; Y,M,D,h,m,s = 2009, 2, 17, 10, 48, 39&gt;&gt;&gt; &#x27;&#123;:04d&#125;-&#123;:02d&#125;-&#123;:02d&#125; &#123;:02d&#125;:&#123;:02d&#125;:&#123;:02d&#125;&#x27;.format(Y,M,D,h,m,s)&#x27;2009-02-17 10:48:39&#x27;&gt;&gt;&gt; &#x27;%04d-%02d-%02d %02d:%02d:%02d&#x27;%(Y,M,D,h,m,s)&#x27;2009-02-17 10:48:39&#x27; 排序函数sorted()​ 排序函数 sorted() 不会改变排序列表的数据结构，而是返回一个新的排序结果。这一点和列表对象的 sort() 方法不同。列表对象的sort()方法改变了列表本身，且无返回值。 示例代码1234567&gt;&gt;&gt; sorted([3,7,2,8,5])[2, 3, 5, 7, 8]&gt;&gt;&gt; a = [[6, 5], [3, 7], [2, 8]]&gt;&gt;&gt; sorted(a, key=lambda x:x[0]) # 根据每一行的首元素排序，默认reverse=False[[2, 8], [3, 7], [6, 5]]&gt;&gt;&gt; sorted(a, key=lambda x:x[-1]) # 根据每一行的尾元素排序，设置reverse=True实现逆序[[6, 5], [3, 7], [2, 8]] 文件读写函数open()​ python open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。 函数语法1open(name[, mode[, buffering]]) 参数说明： name : 一个包含了你要访问的文件名称的字符串值。 mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 示例代码123456789101112&gt;&gt;&gt; data = [[1,2,3,4,5,6,7],[8,9,10,11,12,13,14,15]]&gt;&gt;&gt; with open (r&#x27;d:\\csv_data.csv&#x27;,&#x27;w&#x27;) as fp:... for line in data:... ok = fp.write(&#x27;%s\\n&#x27;%&#x27;,&#x27;.join([str(item) for item in line]))...&gt;&gt;&gt; result = list()&gt;&gt;&gt; with open(r&#x27;d:\\csv_data.csv&#x27;,&#x27;r&#x27;) as fp:... for line in fp.readlines():... result.append([float(f) for f in line.strip().split(&#x27;,&#x27;)])...&gt;&gt;&gt; result[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0], [8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0]] 补充说明： file 对象 **file.read([size])**：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。 **file.readline()**：返回一行。 file.readlines([size]) ：返回包含size行的列表, size 未指定则返回全部行。 for line in f: print line ：通过迭代器访问。 **f.write(“hello\\n”)**：如果要写入字符串以外的数据,先将他转换为字符串。 **f.tell()**：返回一个整数,表示当前文件指针的位置(就是到文件头的字节数)。 **f.seek(偏移量,[起始位置])**：用来移动文件指针。 偏移量: 单位为字节，可正可负 起始位置: 0 - 文件头, 默认值; 1 - 当前位置; 2 - 文件尾 f.close() 关闭文件 示例代码123&gt;&gt;&gt; f =open(&#x27;d:\\csv_data.csv&#x27;)&gt;&gt;&gt; f.read()&#x27;1,2,3,4,5,6,7\\n8,9,10,11,12,13,14,15\\n&#x27; 类型相关函数type()/isinstance()type()type() 函数如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。 语法12type(object)type(name, bases, dict) 参数 name – 类的名称。 bases – 基类的元组。 dict – 字典，类内定义的命名空间变量。 示例代码1234567891011&gt;&gt;&gt; type(1)&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&#x27;runoob&#x27;)&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; type([2])&lt;type &#x27;list&#x27;&gt;&gt;&gt;&gt; type(&#123;0:&#x27;zero&#x27;&#125;)&lt;type &#x27;dict&#x27;&gt;&gt;&gt;&gt; x = 1 &gt;&gt;&gt; type( x ) == int # 判断类型是否相等True isinstance()isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 语法1isinstance(object, classinfo) 参数 object – 实例对象。 classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。 示例代码1234567&gt;&gt;&gt;a = 2&gt;&gt;&gt; isinstance (a,int)True&gt;&gt;&gt; isinstance (a,str)False&gt;&gt;&gt; isinstance (a,(str,int,list)) # 是元组中的一个返回 TrueTrue isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 数学函数sum()sum() 方法对序列进行求和计算。 语法1sum(iterable[, start]) 参数 iterable – 可迭代对象，如：列表、元组、集合。 start – 指定相加的参数，如果没有设置这个值，默认为0。 示例代码123456&gt;&gt;&gt;sum([0,1,2]) 3 &gt;&gt;&gt; sum((2, 3, 4), 1) # 元组计算总和后再加 110&gt;&gt;&gt; sum([0,1,2,3,4], 2) # 列表计算总和后再加 212 max()/min()max() 方法返回给定参数的最大值，参数可以为序列。 min() 方法返回给定参数的最小值，参数可以为序列。 语法12max( x, y, z, .... )min( x, y, z, .... ) 参数 x – 数值表达式。 y – 数值表达式。 z – 数值表达式。 示例代码123456&gt;&gt;&gt; max(3,4,2,5,8)8&gt;&gt;&gt; min(5,2,2.1)2&gt;&gt;&gt; min([3,4,5]),max([9.99,0.1])(3, 9.99) abs()abs() 函数返回数字的绝对值。 语法1abs( x ) 参数 x – 数值表达式。 示例代码1234&gt;&gt;&gt; abs(-9.99)9.99&gt;&gt;&gt; abs(9)9 pow()pow() 方法返回 xy（x 的 y 次方） 的值。 语法以下是 math 模块 pow() 方法的语法: 123import mathmath.pow( x, y ) 内置的 pow() 方法 1pow(x, y[, z]) 函数是计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z。 注意： pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。 参数 x – 数值表达式。 y – 数值表达式。 z – 数值表达式。 123456789&gt;&gt;&gt; pow(2,3)8&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(100,2)10000.0&gt;&gt;&gt; pow(2,-2)0.25 divmod()python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 函数语法1divmod(a, b) 参数说明： a: 数字 b: 数字 123456&gt;&gt;&gt;divmod(7, 2)(3, 1)&gt;&gt;&gt; divmod(8, 2)(4, 0)&gt;&gt;&gt; divmod(1+2j,1+0.5j)((1+0j), 1.5j) round()round() 方法返回浮点数x的四舍五入值。 语法1round( x, n ) 参数 x – 数值表达式。 n – 数值表达式，表示从小数点位数。 123456&gt;&gt;&gt; round(80.4656541231,2)80.47&gt;&gt;&gt; round(80.4656541231,3)80.466&gt;&gt;&gt; round(-80.4656541231,3)-80.466 特殊功能函数zip()函数zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法1zip([iterable, ...]) 参数说明： iterabl – 一个或多个迭代器; 示例代码1234567891011121314151617&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt; eval() 函数eval() 函数用来执行一个字符串表达式，并返回表达式的值。 语法以下是 eval() 方法的语法: 1eval(expression[, globals[, locals]]) 参数 expression – 表达式。 globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。 locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。 示例代码12345678910&gt;&gt;&gt;x = 7&gt;&gt;&gt; eval( &#x27;3 * x&#x27; )21&gt;&gt;&gt; eval(&#x27;pow(2,2)&#x27;)4&gt;&gt;&gt; eval(&#x27;2 + 2&#x27;)4&gt;&gt;&gt; n=81&gt;&gt;&gt; eval(&quot;n + 4&quot;)85 ​ eval虽然方便，但是要注意安全性，可以将字符串转成表达式并执行，就可以利用执行系统命令，删除文件等操作。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--常用内置类","slug":"python基础--常用内置类","date":"2020-12-31T03:14:00.000Z","updated":"2020-12-31T05:55:00.000Z","comments":true,"path":"python基础--常用内置类.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%B1%BB.html","excerpt":"​ python 内置了 列表、字典、元组、集合和字符串等多种数据结构，每种数据结构都封装成为一个类。","text":"​ python 内置了 列表、字典、元组、集合和字符串等多种数据结构，每种数据结构都封装成为一个类。 列表​ 列表（list）是元素的有序集合，列表的元素可以是python语言支持的任意类型。惯用写法是用方括号([])来创建列表，标准写法是用 list() 来实例化 list 类。列表的方法有很多，可以实现列表末尾追加元素、指定位置插入元素、删除指定元素或指定索引位置的元素、返回元素索引、排序等操作。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; a = list() #创建一个空列表，可以传入列表、元组、字符串等迭代对象&gt;&gt;&gt; a.append(3) # 列表尾部追加元素3&gt;&gt;&gt; a.extend([4,5,6,7,8,7]) #列表后接列表[4,5,6,7,8,7]&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.insert(1,9) #在索引序号为1的位置插入元素9&gt;&gt;&gt; a[3, 9, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.index(9)1&gt;&gt;&gt; a.count(7) #返回列表中值为7的元素个数2&gt;&gt;&gt; a.pop(1) #删除并返回索引序号为1的元素，如果不指定索引，则删除最后一个元素9&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.remove(7) #删除列表中最靠前的元素7（无返回）&gt;&gt;&gt; a[3, 4, 5, 6, 8, 7]&gt;&gt;&gt; a.sort() #排序&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8]&gt;&gt;&gt; a[-1] #Python引入-1做末尾的元素索引8&gt;&gt;&gt; a[1:-1] #掐头去尾 切片[4, 5, 6, 7]&gt;&gt;&gt; a[::2] #从头开始，隔一个取一个元素[3, 5, 7] &gt;&gt;&gt; a[::-1] #逆序[8, 7, 6, 5, 4, 3] 字典​ 字典（dict）的本质是 无序的键值对。 12345678910111213141516171819202122232425262728&gt;&gt;&gt; d = dict()&gt;&gt;&gt; d = dict(a=1,b=2)&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; d = dict([(&#x27;a&#x27;,1),(&#x27;b&#x27;,2)])&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; d.update(&#123;&#x27;c&#x27;:3&#125;)&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;&gt;&gt;&gt; d.pop(&#x27;c&#x27;)3&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; list(d.items())[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2)]&gt;&gt;&gt; list(d.keys())[&#x27;a&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; list(d.values())[1, 2]&gt;&gt;&gt; for key in d:... print(key,d[key])...a 1b 2&gt;&gt;&gt; dict.fromkeys(&#x27;xyz&#x27;,0) #fromkeys 是字典类的静态方法，实例也可以调用&#123;&#x27;x&#x27;: 0, &#x27;y&#x27;: 0, &#x27;z&#x27;: 0&#125;&gt;&gt;&gt; 元组​ 元组（tuple）可以理解为限制版的列表，也是元素的有序集合，但这个集合一旦创建，就不允许增加、删除和修改元素。通常，元组用于表示特定的概念，如坐标、矩形区域等。 12345678910&gt;&gt;&gt; a =(3,4)&gt;&gt;&gt; a = tuple([3,4])&gt;&gt;&gt; a.count(3)1&gt;&gt;&gt; a.index(3)0&gt;&gt;&gt; a.append(1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;append&#x27; #不允许增加 集合​ 集合（set）有两个特点，一是集合内元素具有唯一性，二是集合内元素无需排列。集合有一个很经典的用法：去除列表内的重复元素。 123456789101112131415161718192021222324&gt;&gt;&gt; a = set()&gt;&gt;&gt; a.update(&#123;&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;)&gt;&gt;&gt; a&#123;&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;&gt;&gt;&gt; a.remove(&#x27;z&#x27;)&gt;&gt;&gt; a&#123;&#x27;x&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; a.add(&#x27;w&#x27;)&gt;&gt;&gt; a&#123;&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; a = &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;&#125;&gt;&gt;&gt; b = &#123;&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;&gt;&gt;&gt; a.difference(b) #返回a有b没有的元素集合&#123;&#x27;A&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; a - b #简写&#123;&#x27;A&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; a.union(b) #返回a和b的并集&#123;&#x27;D&#x27;, &#x27;B&#x27;, &#x27;E&#x27;, &#x27;A&#x27;, &#x27;C&#x27;&#125;&gt;&gt;&gt; a.intersection(b) #返回a和b重复元素的集合&#123;&#x27;C&#x27;&#125;&gt;&gt;&gt; a.symmetric_difference(b) #返回a和b非重复元素的集合&#123;&#x27;E&#x27;, &#x27;A&#x27;, &#x27;D&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; list(set([1,2,5,2,3,4,5,&#x27;x&#x27;,5,&#x27;x&#x27;])) #去除数组中的重复元素[1, 2, 3, 4, 5, &#x27;x&#x27;] 字符串​ 字符穿对象可以像列表那样进行索引和切片，但无法改变字符串对象的内容，这有点类似元组不可以增加、删除和修改元素。 123456789101112131415161718192021222324252627282930313233343536373839404142&gt;&gt;&gt; str(3.14)&#x27;3.14&#x27;&gt;&gt;&gt; str([&#x27;a&#x27;,1])&quot;[&#x27;a&#x27;, 1]&quot;&gt;&gt;&gt; str(&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;)&quot;&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&quot;&gt;&gt;&gt; s = &quot;hello world&quot;&gt;&gt;&gt; s[1:-1]&#x27;ello worl&#x27;&gt;&gt;&gt; s[::2]&#x27;hlowrd&#x27;&gt;&gt;&gt; s[::-1]&#x27;dlrow olleh&#x27;&gt;&gt;&gt; s.upper()&#x27;HELLO WORLD&#x27;&gt;&gt;&gt; s.lower()&#x27;hello world&#x27;&gt;&gt;&gt; s.capitalize()&#x27;Hello world&#x27;&gt;&gt;&gt; s.title()&#x27;Hello World&#x27;&gt;&gt;&gt; s.startswith(&#x27;hello&#x27;)True&gt;&gt;&gt; s.endswith(&#x27;world&#x27;)True&gt;&gt;&gt; s.find(&#x27;ll&#x27;)2&gt;&gt;&gt; s.split()[&#x27;hello&#x27;, &#x27;world&#x27;]&gt;&gt;&gt; s.replace(&#x27;world&#x27;, &#x27;python&#x27;)&#x27;hello python&#x27;&gt;&gt;&gt; &#x27;1&#x27;.isalpha()False&gt;&gt;&gt; &#x27;asd&#x27;.isalpha()True&gt;&gt;&gt; &#x27;asd12&#x27;.isalpha()False&gt;&gt;&gt; &#x27;asd12&#x27;.isalnum()True&gt;&gt;&gt; &#x27;\\t sasd1231 \\n&#x27;.strip()&#x27;sasd1231&#x27;&gt;&gt;&gt;","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--数据类型","slug":"python基础--数据类型","date":"2020-12-31T02:14:00.000Z","updated":"2020-12-31T02:55:00.000Z","comments":true,"path":"python基础--数据类型.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","excerpt":"​ python中，数据被分为四种类型，分别是：整型、浮点型、布尔型和字符串，并提供了 int 类，float 类，bool 类和 str 类这四个内置类与之相对应。使用 type() 函数可以看到他们各自的类名。","text":"​ python中，数据被分为四种类型，分别是：整型、浮点型、布尔型和字符串，并提供了 int 类，float 类，bool 类和 str 类这四个内置类与之相对应。使用 type() 函数可以看到他们各自的类名。 整型​ 整型数据就是数学上的整数，包括正整数，负整数和零。python不像C，C++把整型分为多种，所以不用担心超过系统限制。 一个整型的例子，可以区别python与其他的语言 1234567&gt;&gt;&gt; def factorial(n):... if n == 0:... return 1... return n*factorial(n-1)...&gt;&gt;&gt; factorial(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 浮点型​ 浮点型数据既可以表示很大的数，也可以表示很小的数。精度是浮点型数据最重要的指标，也是最容易出问题的。 一个特殊的例子（精度相关的）： 12345678&gt;&gt;&gt; 0.1+0.20.30000000000000004&gt;&gt;&gt; 0.1+0.2 ==0.3False&gt;&gt;&gt; 1.1+1.22.3&gt;&gt;&gt; 1.1+1.2 == 2.3True ​ 关于0.1+0.2 != 0.3 ，可以看链接里的回答。 布尔型​ python定义了两个常量：True 和 False ，用来表示布尔型的真和假。True 表示真、非空、非零等概念，False 表示 假、空、零等概念。 1234567891011121314&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool(&#x27;&#x27;)False&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool([&#x27;x&#x27;])True&gt;&gt;&gt; bool(&#x27;x&#x27;)True&gt;&gt;&gt; bool([False])True 字符串​ 字符串是python语言的处理对象之一。python将 单引号（&#39;&#39;）、双引号（&quot;&quot;）、三引号（&#39;&#39;&#39;或者&quot;&quot;&quot;） 前后封闭起来的字符集视为字符串对象，并提供了一系列的处理方法。 12345678&gt;&gt;&gt; &#x27;hello world&#x27;&#x27;hello world&#x27;&gt;&gt;&gt; &quot;hello world&quot;&#x27;hello world&#x27;&gt;&gt;&gt; &#x27;&#x27;&#x27;hello world&#x27;&#x27;&#x27;&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&quot;&quot;hello world&quot;&quot;&quot;&#x27;hello world&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--语句结构","slug":"python基础--语句结构","date":"2020-12-30T10:14:00.000Z","updated":"2020-12-30T10:55:00.000Z","comments":true,"path":"python基础--语句结构.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84.html","excerpt":"​ python和其他编程语言一样，支持：顺序、分支和循环三种语句结构。","text":"​ python和其他编程语言一样，支持：顺序、分支和循环三种语句结构。 顺序结构​ python 把缩进作为语法的一部分，缩进层次相同且连续的一段代码就是一个顺序结构的代码块。运行时，代码块内的代码从上到下，一次被解释执行。 分支结构​ python语言使用 if-else 描述分支结构，支持嵌套，并将 else if 简写成 elif 示例代码： 123456789101112131415161718192021222324252627&gt;&gt;&gt; a, b, c = 3, 4, 5&gt;&gt;&gt; if a &gt; b: #最简单的if-else分支结构... print(a)... else:... print(b)...4&gt;&gt;&gt; if a &gt; b and a &gt; c: #类似switch结构的分支结构... print(a)... elif b &gt; c:... print(b)... else:... print(c)...5&gt;&gt;&gt; if a &gt; b: #嵌套的 if-else 分支结构... if a &gt; c:... print(a)... else:... print(c)... else:... if b &gt; c:... print(b)... else:... print(c)...5 ​ 以上代码演示了三种最常见的分支结构。第一种是最简单的 if-else 分支结构，即使没有 else 分支也是合乎规则的；第二种是类似 switch 结构的分支结构；第三种是嵌套的 if-else 分支结构。 循环结构​ python的循环结构有两种： for 循环和 while 循环。for 循环一般用于循环次数确定的场合，如遍历列表、字典等。 while 循环一般用于循环次数不确定的场合，每次循环之后都要对循环条件进行判断。为了避免“死循环”，在 while 循环体内通常会存在影响循环条件的代码，除非希望while 循环永不停止。 ​ 循环体内有两个特殊语句会影响到 for 循环和 while 循环，这就是 continue 和 break 语句。 continue 语句可以立即结束本次循环，开始下一个循环；break 语句则是立即跳出循环，继续执行 for 或 while 循环后面的语句。 for循环示例：123456789101112131415161718192021222324&gt;&gt;&gt; for i in range(3): #这是 for循环最经典的用法... print(i)...012&gt;&gt;&gt; for i in [1,2,3,4,5,6,7,8,9,10]: #遍历数组是for循环最频繁的应用形式... if i%2 ==0:... continue... if i &gt; 8:... break... print(i*&#x27;*&#x27;)...****************&gt;&gt;&gt; d = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;&gt;&gt;&gt; for key in d: #遍历字典的标准写法... print(key, d[key])...a 1b 2&gt;&gt;&gt; while循环示例：123456789101112131415161718&gt;&gt;&gt; a = 3&gt;&gt;&gt; while a &gt; 0: #判断循环条件... print(a*&#x27;*&#x27;)... a -= 1 #影响循环的条件...******&gt;&gt;&gt; a = 0&gt;&gt;&gt; while True: #死循环... a += 1 #影响循环出口的条件... if a &gt; 3: #设置循环出口条件... break... print(a*&#x27;*&#x27;)...******","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--类和函数","slug":"python基础--类和函数","date":"2020-12-30T08:14:00.000Z","updated":"2020-12-30T10:03:00.000Z","comments":true,"path":"python基础--类和函数.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0.html","excerpt":"​ python有两个顶级的结构定义：函数和类。","text":"​ python有两个顶级的结构定义：函数和类。 函数定义（def）​ python的函数既可以有参数，也可以没有参数；既可以有返回值，也可以没有返回值。用关键字 def 来定义一个函数，用关键字 return 返回函数结果（如果需要返回）。 例子： 1234567891011&gt;&gt;&gt; def hello():... print(&quot;hello world&quot;)...&gt;&gt;&gt; hello()hello world&gt;&gt;&gt; def adder(x, y):... return x + y...&gt;&gt;&gt; adder (5, 6)11 ​ 以上的代码定义了两个函数，hello()函数没有参数，也没有返回指；adder()函数有两个参数，返回值市两个参数的和。 ​ !!! 定义和调用函数时，即使没有参数，函数名后面的圆括号也不能省略。 类定义（class）​ python类定义的规则非常灵活，既有强制性的，也有建议性的。关于类的定义，只需要了解以下几点,就能轻松应对各种 类: 使用关键字 class 定义类。 如果没有基类,类名之后不需要圆括号。 构造函数__init__()在类实例化时自动运行,类的属性要在这里定义或声明。 self不是关键词，虽可替换，但不建议。 类是属性和方法的混合体。 同一个类，可以生成很多实列。 类的各个实例之间是相互隔离的。 例子 12345678910111213141516171819202122232425class GameServer: def __init__(self, port): #构造函数 self.port = port #类属性：服务使用的端口 self.running = False #类属性：服务运行标志 def start(self): #定义类方法：启动服务 self.running = True def stop(self): #定义类方法：停止服务 self.running = False def status(self): #定义类方法：查看服务状态 if self.running: print(&#x27;服务运行于%d端口上。&#x27;%self.port) else: print(&#x27;服务已停止&#x27;)if __name__ == &#x27;__main__&#x27;: gs = GameServer(3721) #类实例化 print(gs.port) #对象属性，服务端口 gs.status() #对象方法，查看服务状态 gs.start() #对象方法：启动服务 gs.status() gs.stop() #对象方法：停止服务 gs.status()","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"Linux性能监控工具-Nmon","slug":"Linux监控工具-Nmon","date":"2020-12-29T06:00:00.000Z","updated":"2020-12-29T07:03:00.000Z","comments":true,"path":"Linux监控工具-Nmon.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-Nmon.html","excerpt":"​ Nmon是一种在AIX与各种Linux操作系统上广泛使用的监控与分析工具，相对于其它一些系统资源监控工具来说，nmon所记录的信息是比较全面的，它能在系统运行过程中实时地捕捉系统资源的使用情况，并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。","text":"​ Nmon是一种在AIX与各种Linux操作系统上广泛使用的监控与分析工具，相对于其它一些系统资源监控工具来说，nmon所记录的信息是比较全面的，它能在系统运行过程中实时地捕捉系统资源的使用情况，并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。 nmon所记录的数据包含以下一些方面： cpu占用率 内存使用情况 磁盘I/O速度、传输和读写比率 文件系统的使用率 网络I/O速度、传输和读写比率、错误统计率与传输包的大小 消耗资源最多的进程 计算机详细信息和资源 页面空间和页面I/O速度 用户自定义的磁盘组 网络文件系统 下载安装nmon1、下载安装包：http://nmon.sourceforge.net/pmwiki.php?n=Site.Download 选择下载相应的版本，我下载的是 nmon16m_helpsystems.tar.gz(截至目前最新的）。解压后里边有很多版本的nmon，我用的是nmon_x86_64_centos7，亲测可用。 2、直接在window中将解压好的nmon_x86_64_centos7通过sftp上传到要监控的linux系统中对应目录下 3、执行授权命令：# chmod +x nmon_x86_64_centos7 4、运行./nmon_x86_64_centos7，便可进入nmon的监控界面，如下图： 实时监控​ 在完成配置后，只需要“./nmon_x86_64_centos7”命令即可运行程序，通过一些快捷键调取关心的系统资源指标进行显示，如按键“C”可以查看CPU相 关信息；按键“D”可以查看磁盘信息；按键“T”可以查看系统的进程信息；“M”对应内存、“N”对应网络等等，完整的快捷键对应内容可以通过帮助（按键 “H”）查看，可以显示Linux系统CPU、内存、进程信息，包括了CPU的用户、系统、等待和空闲状态值，可用内存、缓存大小以及进程的CPU消耗等详细指标。该种方式显示信息实时性强，能够及时掌握系统承受压力下的运行情况，每颗CPU利用率是多少、内存使用多少、网络流量多少、磁盘读写……这些数据均是实时刷新，一目了然。 例如：“c“查看系统CPU使用情况 nmon数据采集数据采集为了实时监控系统在一段时间内的使用情况并将结果记录下来，可以通过运行以下命令实现： 1# .&#x2F;nmon_x86_64_centos7 -f -t -s 30 -c 180 -m &#x2F;home -f：按标准格式输出文件：_YYYYMMDD_HHMM.nmon； -t：输出中包括占用率较高的进程； -s 30：每30秒进行一次数据采集 -c 180：一共采集180次 -m 生成的数据文件的存放目录。 输入命令回车后，将在/home目录生成一个hostname_timeSeries.nmon的文件。 如果想停止该监控，需要通过#ps –ef|grep nmon查询进程号，然后杀掉该进程以停止监控。 生成图形化结果为了分析nmon监控获得的结果，IBM还提供了相应的图形化分析工具nmon_analyser，通过nmon analyser.xls工具可以把监控的结果文件转换成excel文件，方便分析系统的各项资源占用情况。下载nmon_analyser（生成性能报告的免费工具） nmon analyser.xls工具的使用方法如下： （1）打开nmonanalyser.xls工具； （2）调整excel宏安全性(office 2016以上版本可以在文件–选项–信任中心–信任中心设置–宏设置–勾选启用所有宏) （3）修改完后，确定-关闭nmon analyser.xls，重新打开； （4）点击Analyse nmondata按钮，加载之前下载的 nmon 文件。 生成的图形化结果如下图所示： 结束nmon运行nmon运行本身是会消耗系统资源，如需关闭nmon，直接kill掉 123# ps -ef | grep nmon (得到pid)# kill -9pid (安全kill) 定时任务除配合性能测试的短期监控，我们也可以实现对系统的定期监控，作为运营维护阶段的参考。定期监控实现如下：1) 执行命令：#crontab -e 在最后一行添加如下命令： 0 8 * * 1,2,3,4,5 /opt/nmon_x86_64_linux -f -N -m/nmon/log -s 30 -c 1200 **表示:**周一到周五，从早上08点开始，监控10个小时（到18:00整为止），输出到/nmon/log nmon关键指标列表系统汇总（对应excel标签的‘SYS_SUMM’）蓝线为cpu占有率变化情况；粉线为磁盘IO的变化情况； 磁盘读写情况汇总（对应excel标签的‘DISK_SUMM’）蓝色为磁盘读的速率KB/sec紫色为磁盘写的速率KB/sec 内存情况汇总（对应excel标签的‘MEM’）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"Linux常用监控命令","slug":"Linux常用监控命令","date":"2020-12-28T10:46:00.000Z","updated":"2020-12-29T05:46:00.000Z","comments":true,"path":"Linux常用监控命令.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4.html","excerpt":"​ 记录Linux下常用的监控命令","text":"​ 记录Linux下常用的监控命令 1、top –Linux 系统进程监控​ top 命令是性能监控程序，它可以在很多 Linux/Unix 版本下使用，并且它也是 Linux 系统管理员经常使用的监控系统性能的工具。Top 命令可以定期显示所有正在运行和实际运行并且更新到列表中，它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。它也会显示内存和 CPU 使用率过高的正在运行的进程。当我们对 Linux 系统需要去监控和采取正确的行动时，top 命令对于系统管理员是非常有用的。让我们看下 top 命令的实际操作。 1234567891011121314toptop - 19:23:49 up 10 days, 4:37, 1 user, load average: 0.37, 0.24, 0.13Tasks: 78 total, 2 running, 76 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.7 us, 0.3 sy, 0.0 ni, 99.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882012 total, 108880 free, 569200 used, 1203932 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 1124836 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2848 root 20 0 162452 11300 1980 S 0.3 0.6 10:13.25 barad_agent 2849 root 20 0 611544 13716 2248 S 0.3 0.7 44:27.48 barad_agent 3548 root 20 0 935212 20344 10396 S 0.3 1.1 1:20.46 YDService 3565 root 20 0 642092 12424 11060 S 0.3 0.7 0:26.83 YDEdr 23237 root 20 0 2636376 440476 7888 S 0.3 23.4 14:38.07 java 30663 root 20 0 160032 2180 1512 R 0.3 0.1 0:00.01 top 信息说明如下：1234567891011121314151617181920212223PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒COMMAND — 进程名称（命令名&#x2F;命令行） 2、vmstat –虚拟内存统计vmstat 命令是用于显示虚拟内存、内核线程、磁盘、系统进程、I/O 模块、中断、CPU 活跃状态等更多信息。在默认的情况下，Linux 系统是没有 vmstat 这个命令的，如果你要使用它，必须安装一个包名叫 sysstat 的程序包。 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如: 123456789# vmstat 2 10procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 108484 134740 1069640 0 0 2 34 33 16 1 1 99 0 0 0 0 0 109832 134740 1069648 0 0 0 36 589 1173 1 2 97 1 0 0 0 0 111460 134740 1069652 0 0 0 6 857 1721 1 1 98 0 0 0 0 0 111500 134740 1069660 0 0 0 48 752 1492 1 1 98 0 0 0 0 0 111464 134740 1069668 0 0 0 0 196 375 1 1 98 0 0 0 0 0 111516 134740 1069672 0 0 0 52 166 375 2 1 97 0 0 2表示每个两秒采集一次服务器状态，10表示采集10次。 实际上，在应用过程中，会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如: 12345678# vmstat 2 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 111268 134744 1069764 0 0 2 34 33 16 1 1 99 0 0 0 0 0 111020 134744 1069764 0 0 0 30 188 380 1 1 99 1 0 0 0 0 111004 134744 1069772 0 0 0 0 154 314 1 1 99 0 0 0 0 0 107632 134744 1069772 0 0 0 0 195 350 2 1 97 0 0 0 0 0 106712 134744 1069776 0 0 0 84 635 1276 2 2 96 1 0 这表示vmstat每2秒采集数据，一直采集，直到结束程序，这里采集了5次数据就结束了程序。 字段说明：12345678910111213141516171819202122232425262728293031323334353637383940414243Procs（进程）：r: 运行队列中进程数量b: 等待IO的进程数量Memory（内存）：swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小Swap：si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数系统：in: 每秒中断数，包括时钟中断。cs: 每秒上下文切换数。CPU（以百分比表示）：us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。wa: 等待IO时间 备注： 如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。如果pi，po 长期不等于0，表示内存不足。如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。Linux在具有高稳定性、可靠性的同时，具有很好的可伸缩性和扩展性，能够针对不同的应用和硬件环境调整，优化出满足当前应用需要的最佳性能。因此企业在维护Linux系统、进行系统调优时，了解系统性能分析工具是至关重要的。 3、losf –打开文件列表4、netstat –网络统计​ 参考另一篇笔记：Linux查看端口占用 5、tcpdump –网络数据包分析器​ tcpdump 是一种使用最广泛的命令行网络数据包分析器或数据包嗅探程序，主要用于捕获和过滤 TCP/IP 包收到或者转移在一个网络的特定借口信息。它也提供了一个选项参数去保存将捕获的包在一个文件中用于以后分析使用，tcpdump 几乎在所有的 Linux 版本中都是可用的。 默认启动1tcpdump 普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。 监视指定网络接口的数据包1tcpdump -i eth1 监视指定主机的数据包打印所有进入或离开sundown的数据包. 1tcpdump host sundown 也可以指定ip,例如截获所有192.168.10.1 的主机收到的和发出的所有的数据包 1tcpdump host 192.168.10.1 打印helios 与 hot 或者与 ace 之间通信的数据包 1tcpdump host helios and \\( hot or ace \\) 截获主机192.168.10.1 和主机192.168.10.2 或192.168.10.3 的通信 1tcpdump host 192.168.10.1 and \\ (192.168.10.2 or 192.168.10.3 \\) 打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包. 1tcpdump ip host ace and not helios 如果想要获取主机192.168.10.1除了和主机192.168.10.2之外所有主机通信的ip包，使用命令： 1tcpdump ip host 192.168.10.1 and ! 192.168.10.2 截获主机hostname发送的所有数据 1tcpdump -i eth0 src host hostname 监视所有送到主机hostname的数据包 1tcpdump -i eth0 dst host hostname 监视指定主机和端口的数据包如果想要获取主机192.168.10.1接收或发出的telnet包，使用如下命令 1tcpdump tcp port 23 and host 192.168.10.1 对本机的udp 123 端口进行监视 123 为ntp的服务端口 1tcpdump udp port 123 监视指定网络的数据包打印本地主机与Berkeley网络上的主机之间的所有通信数据包(nt: ucb-ether, 此处可理解为’Berkeley网络’的网络地址,此表达式最原始的含义可表达为: 打印网络地址为ucb-ether的所有数据包) 1tcpdump net ucb-ether 打印所有通过网关snup的ftp数据包(注意, 表达式被单引号括起来了, 这可以防止shell对其中的括号进行错误解析) 1tcpdump &#39;gateway snup and (port ftp or ftp-data)&#39; 打印所有源地址或目标地址是本地主机的IP数据包 (如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折,需补充).localnet 实际使用时要真正替换成本地网络的名字) 1tcpdump ip and not net localnet","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux查看端口占用","slug":"Linux查看端口占用","date":"2020-12-28T10:46:00.000Z","updated":"2020-12-28T09:09:00.000Z","comments":true,"path":"Linux查看端口占用.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.html","excerpt":"​ Linux查看端口占用得情况可以使用lsof和netstat 命令","text":"​ Linux查看端口占用得情况可以使用lsof和netstat 命令 lsof​ lsof(list open files) 是一个列出当前系统打开文件的工具。 lsf查看端口占用语法格式： lsof -i:端口号 实例1234# lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAMEjava 23237 root 57u IPv6 56034 0t0 TCP *:webcache (LISTEN) 可以看出8080端口已经被 java 服务占用。 lsof -i 需要 root 用户的权限来执行，如下图： 12345678910111213141516# lsof -iCOMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAMEdhclient 859 root 6u IPv4 14539 0t0 UDP *:bootpc sshd 1385 root 3u IPv4 16540 0t0 TCP *:ssh (LISTEN)ntpd 2343 ntp 16u IPv4 18157 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 17u IPv4 18158 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 18u IPv6 18159 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 19u IPv6 18162 0t0 UDP VM-0-12-centos:ntp YDService 3548 root 18u IPv4 15028196 0t0 TCP VM-0-12-centos:39406-&gt;169.254.0.55:lsi-bobcat (ESTABLISHED)sshd 17853 root 3u IPv4 15450643 0t0 TCP VM-0-12-centos:ssh-&gt;119.123.73.14:13428 (ESTABLISHED)sshd 18401 root 3u IPv4 15454393 0t0 TCP VM-0-12-centos:ssh-&gt;49.234.88.101:38420 (ESTABLISHED)sshd 18404 sshd 3u IPv4 15454393 0t0 TCP VM-0-12-centos:ssh-&gt;49.234.88.101:38420 (ESTABLISHED)sshd 18413 root 3u IPv4 15454481 0t0 TCP VM-0-12-centos:ssh-&gt;167.71.127.147:42390 (ESTABLISHED)sshd 18416 sshd 3u IPv4 15454481 0t0 TCP VM-0-12-centos:ssh-&gt;167.71.127.147:42390 (ESTABLISHED)java 23237 root 57u IPv6 56034 0t0 TCP *:webcache (LISTEN)java 23237 root 196u IPv6 56093 0t0 TCP VM-0-12-centos:mxi (LISTEN) lsof输出各列信息的意义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101COMMAND：进程的名称PID：进程标识符PPID：父进程标识符（需要指定-R参数）USER：进程所有者PGID：进程所属组FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序（3）lnn：library references (AIX);（4）er：FD information error (see NAME column);（5）jld：jail directory (FreeBSD);（6）ltx：shared library text (code and data);（7）mxx ：hex memory-mapped type number xx.（8）m86：DOS Merge mapped file;（9）mem：memory-mapped file;（10）mmap：memory-mapped device;（11）pd：parent directory;（12）rtd：root directory;（13）tr：kernel trace file (OpenBSD);（14）v86 VP&#x2F;ix mapped file;（15）0：表示标准输出（16）1：表示标准输入（17）2：表示标准错误一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等（1）u：表示该文件被打开并处于读取&#x2F;写入模式（2）r：表示该文件被打开并处于只读模式（3）w：表示该文件被打开并处于（4）空格：表示该文件的状态模式为unknow，且没有锁定（5）-：表示该文件的状态模式为unknow，且被锁定同时在文件状态模式后面，还跟着相关的锁（1）N：for a Solaris NFS lock of unknown type;（2）r：for read lock on part of the file;（3）R：for a read lock on the entire file;（4）w：for a write lock on part of the file;（文件的部分写锁）（5）W：for a write lock on the entire file;（整个文件的写锁）（6）u：for a read and write lock of any length;（7）U：for a lock of unknown type;（8）x：for an SCO OpenServer Xenix lock on part of the file;（9）X：for an SCO OpenServer Xenix lock on the entire file;（10）space：if there is no lock.TYPE：文件类型，如DIR、REG等，常见的文件类型（1）DIR：表示目录（2）CHR：表示字符类型（3）BLK：块设备类型（4）UNIX： UNIX 域套接字（5）FIFO：先进先出 (FIFO) 队列（6）IPv4：网际协议 (IP) 套接字DEVICE：指定磁盘的名称SIZE：文件的大小NODE：索引节点（文件在磁盘上的标识）NAME：打开文件的确切名称 更多 lsof 的命令如下123456789lsof -i:8080：查看8080端口占用lsof abc.txt：显示开启文件abc.txt的进程lsof -c abc：显示abc进程现在打开的文件lsof -c -p 1234：列出进程号为1234的进程所打开的文件lsof -g gid：显示归属gid的进程情况lsof +d &#x2F;usr&#x2F;local&#x2F;：显示目录下被进程开启的文件lsof +D &#x2F;usr&#x2F;local&#x2F;：同上，但是会搜索目录下的目录，时间较长lsof -d 4：显示使用fd为4的进程lsof -i -U：显示所有打开的端口和UNIX domain文件 netstat​ netstat -tunlp 用于显示tcp，udp 的端口和进程相关情况。 netstat 查看端口占用语法格式: netstat - tunlp | grep 端口号 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 例如查看 8080 端口的情况，使用以下命令： 12# netstat -tunlp | grep 8080tcp6 0 0 :::8080 :::* LISTEN 23237&#x2F;java 状态说明：123456789101112131415161718192021LISTEN：侦听来自远方的TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态 更多命令： 12netstat -ntlp &#x2F;&#x2F;查看当前所有tcp端口netstat -ntulp | grep 80 &#x2F;&#x2F;查看所有80端口使用情况 kill​ 在查到端口占用的进程后，如果要杀掉对应的进程，可以使用kill命令： 1kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;] 参数说明： -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称。 -s &lt;信息名称或编号&gt; 指定要送出的信息。 [程序] [程序]可以是程序的PID或是PGID，也可以是工作编号。 使用 kill -l 命令列出所有可用信号。最常用的信号是： 1 (HUP)：重新加载进程。 9 (KILL)：杀死一个进程。 15 (TERM)：正常停止一个进程。 如上实例，我们看到 8000 端口对应的 PID 为 26993，使用以下命令杀死进程： kill -9 23237 显示信号： 123456789101112131415# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux vi和vim","slug":"Linux vi和vim","date":"2020-12-22T02:09:00.000Z","updated":"2020-12-28T09:56:00.000Z","comments":true,"path":"Linux vi和vim.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%20vi%E5%92%8Cvim.html","excerpt":"​ 记录关于 Vi和Vim 相关的一些内容","text":"​ 记录关于 Vi和Vim 相关的一些内容 vi/vim 的使用vi/vim 的三种模式命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。 N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 **:q!**。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux查看日志","slug":"Linux查看日志","date":"2020-12-21T11:24:00.000Z","updated":"2020-12-22T02:06:00.000Z","comments":true,"path":"Linux查看日志.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html","excerpt":"​ 作为一名测试工程师，测试任务中和Linux打交道的地方有很多，比如查看日志、定位bug、修改文件、部署环境等。产品部署在linux上，如果某个功能发生错误，就需要去排查出错的原因，所以熟练的掌握查看log的方法显得尤为重要。","text":"​ 作为一名测试工程师，测试任务中和Linux打交道的地方有很多，比如查看日志、定位bug、修改文件、部署环境等。产品部署在linux上，如果某个功能发生错误，就需要去排查出错的原因，所以熟练的掌握查看log的方法显得尤为重要。 最常使用的命令1234567cat：由第一行开始显示文件内容tac：从最后一行开始显示，不知道你是否观察出来，tac是cat倒着写的，所以功能上两个是相反的nl：显示的时候，同时输出行号 more：一页一页地显示文件内容less：与more类似，相比于more，可以往前翻页head：只看前面几行tail：只看后面几行 cat、tac、nl想要直接查看一个文件的内容，可以使用cat，tac，nl命令 cat1234567891011121314151617cat --helpUsage: cat [OPTION]... [FILE]...Concatenate FILE(s), or standard input, to standard output. -A, --show-all 相当于-vET的整合，可列出一些特殊字符而不是空白而已； -b, --number-nonblank 列出行号，仅针对非空白行做出行号显示，空白行不标行号； -e 相当于 -vE -E, --show-ends 将结尾的换行符$显示出来； -n, --number 打印出行号，连同空白行也会有行号，与-b的选项不同； -s, --squeeze-blank 抑制重复的空输出行 -t 相当于 -vT -T, --show-tabs 将[tab]按键以^I显示出来 ； -u (ignored) -v, --show-nonprinting 列出一些看不出来的特殊字符； --help display this help and exit --version output version information and exit tac123456789101112tac --helpUsage: tac [OPTION]... [FILE]...Write each FILE to standard output, last line first.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too. -b, --before 在行前附加分隔符代替在行尾附加分隔符。 -r, --regex 将分隔符作为正则表达式来解析。 -s, --separator=STRING 使用指定字符串代替换行作为分隔标志。 --help display this help and exit --version output version information and exit nl12345678910111213141516171819202122232425262728293031323334353637383940414243nl --helpUsage: nl [OPTION]... [FILE]...Write each FILE to standard output, with line numbers added.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too. -b, --body-numbering=STYLE 指定行号指定的方式 -b a 表示不论是否为空行，也同样列出行号 -b t 如果有空行，空的那一行不要列出行号 -d, --section-delimiter=CC 使用指定的CC 分割逻辑页数 -f, --footer-numbering=STYLE 使用指定样式编号文件的页脚行目 -h, --header-numbering=STYLE 使用指定样式编号文件的页眉行目 -i, --line-increment=NUMBER 设置每一行遍历后的自动递增值 -l, --join-blank-lines=NUMBER 设置数值为多少的若干空行被视作一行 -n, --number-format=FORMAT 列出行号表示的方法 -n ln 行号在屏幕的最左方表示 -n rn 行号在自己栏位的最右方显示，且不加0 -n rz 行号在自己栏位的最右方显示，且加0 -p, --no-renumber 在逻辑页数切换时不将行号值复 -s, --number-separator=STRING 可能的话在行号后添加字符串 -v, --starting-line-number=NUMBER 每个逻辑页上的第一行的行 -w, --number-width=NUMBER 行号栏位的占用的字符数 --help display this help and exit --version output version information and exit默认的选项设置是-v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn。CC 是用于分隔逻辑页数的两个分界符，其中缺失的第二个字符暗含了&quot;:&quot;，如果您要指定&quot;\\&quot;，请输入&quot;\\\\&quot;。可用的样式如下： a 表示不论是否为空行，也同样列出行号 t 如果有空行，空的那一行不要列出行号 n 不编行号 pBRE 只对符合正则表达式BRE 的行编号FORMAT is one of: ln 行号在屏幕的最左方表示,且不加0 rn 行号在自己栏位的最右方显示，且不加0 rz 行号在自己栏位的最右方显示，且加0GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;For complete documentation, run: info coreutils &#x27;nl invocation&#x27; ​ nl可以将输出的文件内容自动地加上行号，其默认的结果与cat -n不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等的功能。 head、tail​ 只想关注日志内容的前一段或者最后一段的内容，可以使用 head、tail head（取出前面几行）12345head [-n number] 文件常用的选项与参数：-n : 后面接数字，代表显示几行的意思。# 默认情况下是显示前10行，如果想要显示前20行，使用head -n 20 文件# 行数可以为正数，也可以为负数。 tail（取出后面几行）12345tail [-n number] 文件选项与参数：-n : 后面接数字，代表显示几行的意思。-f : 表示持续刷新显示后面所接文件中的内容，按下ctrl -c 才会结束# 默认情况下是显示最后10行，如果想要显示最后20行，使用tail -n 20 文件 more、less​ 可以使用more和less命令，一页一页的查看文件的内容。 more(一页一页翻动)12345678more 文件--More--(52%) #这一行为重点，如果文件内容行数大于屏幕输出的行数时，就会展示出目前文件展示的百分比，此时光标也会停留在这里等待你输入信息，在more展示文件时，可以使用以下几个常用功能键：1. 空格键（space）: 代表向下翻一页2. Enter ：代表向下翻一行3. &#x2F;字符串 ：代表在这个显示的内容中，向下查找字符串这个关键词4. :f ：立刻显示出文件名以及当前显示的行数5. q : 代表立刻离开more，不再显示该文件内容6. b或[ctrl]-b ：代表往回翻页 less(一页一页翻动)123456789101112less 文件末行显示文件名 #这一行等待你输入信息,展示文件时，有几个功能按键可供使用：1. 空格键（space）: 代表往下翻动一页2. [pagedown] ：代表向下翻动一页3. [pageup] ：代表向上翻动一页4. &#x2F;字符串 ：向下查找字符串这个关键词5. ?字符串 ：向上查找字符串这个关键词6. n : 重复前一个查找（与&#x2F;或？有关）7. N：反向的重复前一个查找（与&#x2F;或？有关）8. g：前进到这个数据的第一行9. G：前进到这个数据的最后一行10. q : 退出 ​ 对比less和more，less的用法更加的灵活，more的缺点是没有办法向前翻页，只能往后翻，但是less既能往后翻也能往前翻页。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"mock工具moco","slug":"mock工具Moco","date":"2020-12-19T05:47:00.000Z","updated":"2021-06-24T15:29:30.000Z","comments":true,"path":"mock工具Moco.html","link":"","permalink":"https://www.lauyongyi.cn/mock%E5%B7%A5%E5%85%B7Moco.html","excerpt":"记录mock工具moco的一些基本操作","text":"记录mock工具moco的一些基本操作 项目地址与下载地址项目地址 https://github.com/dreamhead/moco 下载地址： https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/1.1.0/moco-runner-1.1.0-standalone.jar （此链接为2020.12.19日的版本） 如果需要最新的，可以到项目地址下，如图所示位置下载 Moco的优缺点：Moco的优点： 支持http、https、socket 支持设置headers、cookies、statuscode 支持GET、POST、PUT、DELETE请求 只需JRE环境即可运行 支持热更新 支持json、xml、text、file数据格式 能与JUnit、Maven、Gradle集成 Moco的缺点：​ Moco的使用很简单，配置也很方便。但也仅仅是能Stub出接口，模拟出简单的场景。 ​ 如果接收到请求后需要做一些处理，如需查询数据库、运算、或者一些复杂的操作，就无能为力了。 配置与启动：配置：​ 首先，下载好moco后，新建一个文件夹，用来存在 moco的jar和运行所需的json文件 这里暂时将接送文件名为 moce_test.json 启动命令：java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -c moce_test.json 命令解释：&lt;version&gt; 是指下载的moco jar的版本 -p 为端口，可以自行指定，指定端口没有占用即可 -c 是配置所需的文件 json配置：设定URIJSON中无法添加注释，利用description字段可以清楚的说明接口的功能。 带参数GET请求http://localhost:12306/getparam?id=1&amp;status=100，参数通过queries设置k-v对。 带参数POST请求，参数通过forms设置k-v对，需要通过工具发送POST请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ &#123; &quot;description&quot;: &quot;设定URI&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/uri&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;Hello Moco GET URI&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;无参GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/get&quot;, &quot;method&quot;: &quot;get&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;无参GET请求返回-success&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;带参GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/getparam&quot;, &quot;method&quot;: &quot;get&quot;, &quot;queries&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;带参GET请求返回-success&quot; &#125; &#125;,&#123; &quot;description&quot;: &quot;带参数POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/postparam&quot;, &quot;method&quot;: &quot;post&quot;, &quot;forms&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;带参POST请求返回-success&quot;, &quot;headers&quot;: &#123; &quot;Content-Type&quot;: &quot;text/html;charset=gbk&quot; &#125; &#125;&#125;] 设定Headers及请求返回为JSON 1234567891011121314151617181920[&#123; &quot;description&quot;: &quot;带headers信息POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/post/headers&quot;, &quot;method&quot;: &quot;post&quot;, &quot;headers&quot;: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, &quot;json&quot;: &#123; &quot;name&quot;: &quot;isisiwish&quot;, &quot;sex&quot;: &quot;male&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;json&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;&#125;] 设定Cookies如果不获取cookies，直接访问http://localhost:12306/get/with/cookies，则返回失败； 如果首先访问http://localhost:12306/getcookies，获取到服务器cookies，再访问http://localhost:12306/get/with/cookies，不用额外设定cookies也可以获得正确返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[&#123; &quot;description&quot;: &quot;返回cookies信息的GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/getcookies&quot;, &quot;method&quot;: &quot;get&quot; &#125;, &quot;response&quot;: &#123; &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125;, &quot;text&quot;: &quot;get cookies success&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;携带cookies信息的GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/get/with/cookies&quot;, &quot;method&quot;: &quot;get&quot;, &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;the cookies is okay&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;携带cookies信息的POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/post/with/cookies&quot;, &quot;method&quot;: &quot;post&quot;, &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125;, &quot;json&quot;: &#123; &quot;name&quot;: &quot;isisiwish&quot;, &quot;age&quot;: &quot;30&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;status&quot;: 200, &quot;json&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125; &#125;] 使用postman或jmeter等接口测试工具是，需要配置cookies信息 postman 添加cookies时一定要修改 Domain的值，需要对应的域名 jmeter 需要添加对应的域和路径。 路径默认 / 重定向123456789101112131415161718192021222324[&#123; &quot;description&quot;: &quot;绝对路径重定向&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect&quot; &#125;, &quot;redirectTo&quot;: &quot;https://www.baidu.com/&quot; &#125;, &#123; &quot;description&quot;: &quot;相对重定向&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect/top&quot; &#125;, &quot;redirectTo&quot;: &quot;/redirect/max&quot; &#125;, &#123; &quot;description&quot;: &quot;被重定向的请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect/max&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;top == max&quot; &#125; &#125;] 返回类型为file内容对于比较大的JSON，可以通过文件方式返回。 需要先创建一个 data.json 文件 12345678[&#123; &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/file&quot; &#125;, &quot;response&quot;: &#123; &quot;file&quot;: &quot;data.json&quot; &#125;&#125;]","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}]},{"title":"记某数据处理公司的面试记录","slug":"20201105面试题记录","date":"2020-11-05T09:30:00.000Z","updated":"2020-11-06T06:39:00.000Z","comments":true,"path":"20201105面试题记录.html","link":"","permalink":"https://www.lauyongyi.cn/20201105%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95.html","excerpt":"记录一下某数据处理公司的笔试题","text":"记录一下某数据处理公司的笔试题 什么是敏捷研发，测试在什么阶段介入，分别做什么？参考链接：阮一峰：敏捷开发入门教程，知乎敏捷测试宣言 敏捷开发是：迭代开发+增量开发 迭代开发：将一个大任务，分解成多次连续的开发，本质就是逐步改进 增量开发：指的是软件的每个版本，都会新增一个用户可以感知的完整功能 全程的测试介入敏捷测试提倡测试左移和右移，从软件生命周期的早期（左侧）一直到产品发布上线后的生产环境，都需要有测试的介入和测试活动的开展。 左移是为了更好的理解和澄清需求，以减少需求理解不一致导致的浪费；而右移是充分利用生产环境的数据来优化开发和测试流程，以增强软件系统应对各种不可预测性的能力。 左移和右移并不仅仅是将测试活动移到两侧端点，更强调的是每个环节的参与，也就是全程测试介入，这是从流程上保障高质量软件交付的关键。 如何写好测试用例？见仁见智的问题，可以从以下几方面去写： 1、要参与需求评审，评审需求的过程实际也是熟悉业务需求的过程 2、要多阅读文档，其中包括产品策划书、规格说明书、需求文档，接口文档等 3、尽量多参加项目组内的会议 4、要善于沟通，多和客户、开发、测试人员进行沟通 5、测试用例名称，也叫测试用例标题，一定要写得简洁、明了，需要用概括的语言描述该用例的出发点和关注点，使得测试人员第一眼看到测试用例名称就能够明白测试用例的目的 6、预置条件要明确，包括测试环境、测试数据、测试场景 7、测试步骤描述要简单、清晰，并且要清楚每一个步骤的描述 8、用例的预期结果要完整而且清晰，并且要将各个输出的结果写出来、 9、测试用例级别要划分清楚 10、测试用例的划分也要单一，一个测试用例只检查功能点的一种情况 11、召开测试用例评审会议 12、站在用户的角度来设计用例 13、测试用例需要不断更新和维护 Redis和MySQL有什么区别？分别用在什么场景？介绍​ MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。 ​ Redis 是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但保存时间有限。 区别​ 1、类型上：​ Mysql是关系型数据库，redis是非关系型数据库 ​ 2、作用上：​ MySQL用于持久化存储数据到硬盘，功能强大，但速度较慢​ Redis用于存储使用较为频繁的数据到缓存中，读取速度快 ​ 3、需求上：​ MySQL和Redis因为需求的不同，一般都是配合使用 ​ 4、数据存放位置：​ MySQL存储在硬盘。Redis存储在内存 ​ 5、场景选型：​ Redis适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。​ MySQL适用于需要持久化，大量存储数据的系统。​ Redis和MySQL都要要根据具体业务场景去选型. ​ 6、适合存放的数据类型：​ Redis适合放一些频繁使用的数据，例如：排行版，计数器，消息队列推送，好友关注，点赞等。​ MySQL适合存放一些持久化，且不需要频繁调用的数据，例如：家庭住址等。 数据库中什么是死锁？一般是什么原因导致的？参考来源百度百科：数据库死锁 死锁：多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程A等待进程B释放他的资源，B又等待A释放他的资源，这样就互相等待就形成死锁。 死锁产生必要条件1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 死锁产生的原因一般情况只发生锁超时，就是一个进程需要访问数据库表或者字段的时候，另外一个程序正在执行带锁的访问（比如修改数据），那么这个进程就会等待，当等了很久锁还没有解除的话就会锁超时，报告一个系统错误，拒绝执行相应的SQL操作。 发生死锁的情况比较少，比如一个进程需要访问两个资源（数据库表或者字段），当获取一个资源的时候进程就对它执行锁定，然后等待下一个资源空闲，这时候如果另外一个进程也需要两个资源，而已经获得并锁定了第二个资源，那么就会死锁，因为当前进程锁定第一个资源等待第二个资源，而另外一个进程锁定了第二个资源等待第一个资源，两个进程都永远得不到满足。 左内右连接有什么区别？什么是索引，通常哪些具体情况要加索引?​ 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。​ 左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。​ 右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。 ​ 索引用于在数据库中快速地创建和检索数据。 要加索引的情况： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 不需要加索引的情况： 对于那些在查询中很少使用或者参考的列不应该创建索引。 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 绝对路径和相对路径的区别，无权限执行的执行文件一般报错是什么？如何赋予执行权限？绝对路径和相对路径的区别​ 相对路径：以引用文件的文件所在位置为参考基础，而建立出的目录路径。 ​ 绝对路径：以根目录为参考基础的目录路径。 ​ 区别： ​ 绝对路径就是写死的路径,缺点是换设备会出现路径找不到问题 ​ 相对路径就是灵活的路径,优点是不会因为设备更换出现路径问题。 无权限执行的执行文件一般报错是什么？如何赋予执行权限？​ 在执行Linux命令式，报错为：permission denied ​ 执行命令：上调权限：chmod 777或者chmod -R +x 或者使用授权语句 chmod -R 755 * shell指令中与网络相关的有哪些？分别对应什么功能？​ 常用的网络相关的命令有以下几个： ifconfig：用于显示网络接口，子网掩码 host和nslookup：DNS查找工具，当执行host是，会列出某个域名所有IP；nslookup是一个类似于host的命令，它用于查询DNS相关的细节信息，以及名字解析 route：显示路由表 traceroute：显示分组途径的所有网关地址 补充问题：netstat、ping、ifconfig这三个的区别，分别是什么功能，netstat里面一般服务器启动后的端口状态是什么 netstat:显示网络状态，利用netstat可以让你得知整个Linux系统的网络情况，语法为netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] ping:功能是检测主机，因为执行ping命令会使用icmp传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常，语法为：ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址] ifconnfig：功能是显示或设置网络设备，其语法为：ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址] 服务器启动后一般为listening状态 怎么测试一种网络协议，可以假设HTTP或FTP？​ 协议测试主要关注三方面：一致性，互操作性，性能。 一致性测试：主要测试协议实现是否严格遵循相应的协议描述。 互操作性测试：对于同一个协议标准，不同协议时间之间的互联通问题。 性能测试：用实验的方法来观测被测协议实现葛总性能参数，如吞吐量和传输延迟。 如何测试一个系统的稳定性？参考链接测试教程网 压力测试（强度测试）压力测试方法测试系统在一定饱和状态下，例如CPU、内存在饱和使用情况下，系统能够处理的会话能力，以及系统是否会出现错误。 特点： 这种测试方法的主要目的是检查系统处于压力性能下时，应用的表现。 这种测试方法一般通过模拟负载等方法，使得系统的资源使用达到较高的水平。 这种测试方法一般用于测试系统的稳定性。 也就是说，这种测试是让系统处在很大强度的压力之下，看系统是否稳定，哪里会出问题。 配置测试配置测试方法通过对被测系统的软\\硬件环境的调整，了解各种不同对系统的性能影响的程度，从而找到系统各项资源的最优分配原则。 特点： 这种性能测试方法的主要目的是了解各种不同因素对系统性能影响的程度，从而判断出最值得进行的调优操作。 这种性能测试方法一般在对系统性能状况有初步了解后进行。 这种性能测试方法一般用于性能调优和规划能力。 也就是说，这种测试关注点是“微调”，通过对软硬件的不段调整，找出这他们的最佳状态，使系统达到一个最强的状态。 可靠性测试在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。 特点： 这种性能测试方法的主要目的是验证是否支持长期稳定的运行。 这种性能测试方法需要在压力下持续一段时间的运行。 测试过程中需要关注系统的运行状况。 也就是说，这种测试的关注点是“稳定”，不需要给系统太大的压力，只要系统能够长期处于一个稳定的状态。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.lauyongyi.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"session,cookie,token的区别","slug":"session，cookie，token","date":"2020-11-04T08:52:00.000Z","updated":"2020-11-04T09:31:30.000Z","comments":true,"path":"session，cookie，token.html","link":"","permalink":"https://www.lauyongyi.cn/session%EF%BC%8Ccookie%EF%BC%8Ctoken.html","excerpt":"Session，Cookie，token是测试工作中，经常听到的有关验证的方式，这里主要记录这三者的一些区别","text":"Session，Cookie，token是测试工作中，经常听到的有关验证的方式，这里主要记录这三者的一些区别 三者的作用Session 对象存储特定用户会话所需的属性及配置信息 Cookie 是“小型文本文件”，是网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常有加密），由用户客户端计算机暂时或永久保存的信息 Token 在计算机身份认证中是令牌（临时）的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。 三者的区别1、浏览器接受服务器的Set-Cookie 指令，并把cookie保存到电脑上，每个网站保存的cookie只作用于自己的网站 2、Session 就是数据存储到服务端，只把关联数据的一个加密串放到cookie中标记 3、凭借认证信息获取token，或者通过后台配置好token，在相关请求中使用token，多数是以query参数的形式提供 4、token 是一个用户请求时附带的请求字段，用于验证身份和权限 5、Session 可以基于cookie，也可以基于query参数，用于关联用户相关数据 6、Android 原生系统（除非使用webview）不支持cookie，需要用token识别用户身份，还需要把sessionid保存到http请求中的header或者query字段中。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.lauyongyi.cn/tags/http/"}]},{"title":"shell基础进阶","slug":"shell基础进阶","date":"2020-10-22T05:30:00.000Z","updated":"2020-10-22T08:20:30.000Z","comments":true,"path":"shell基础进阶.html","link":"","permalink":"https://www.lauyongyi.cn/shell%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6.html","excerpt":"记录shell相关的进阶知识","text":"记录shell相关的进阶知识 判断的类型❖ 算术判断1234567891011121314[root@VM-0-12-centos ~]# [ 2 -eq 2 ];echo $? #如果两个表达式相等，则结果为真0[root@VM-0-12-centos ~]# [ 2 -ne 2 ];echo $? #如果两个表达式不等，则结果为真1[root@VM-0-12-centos ~]# [ 3 -gt 1 ];echo $? #如果前⼀个表达式⼤于后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -ge 3 ];echo $? #如果前⼀个表达式&gt;=后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -lt 4 ];echo $? #如果前⼀个表达式&lt;后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -le 3 ];echo $? #如果前⼀个表达式&lt;=后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# ((8&gt;=10));echo $? #(())也可以表⽰算术⽐较。1 ❖ 字符串判断 [ string1 = string2 ]如果两字符串相同,则结果为真 \\ 1234[root@VM-0-12-centos test]# [ &#x27;aa&#x27; = &#x27;aa&#x27; ];echo $?0[root@VM-0-12-centos test]# [ &#x27;aa&#x27; = &#x27;aA&#x27; ];echo $?1 [ string1 != string2 ] 如果两字符串不相同,则结果为真 1234[root@VM-0-12-centos test]# [ &#x27;aa&#x27; != &#x27;aA&#x27; ];echo $?0[root@VM-0-12-centos test]# [ &#x27;aa&#x27; != &#x27;aa&#x27; ];echo $?1 [ -n string ] 如果字符串不是空,则结果为真 1234[root@VM-0-12-centos test]# [ -n &#x27;&#x27; ];echo $?1[root@VM-0-12-centos test]# [ -n &#x27;aaa&#x27; ];echo $?0 [ -z string ] 如果字符串是空,则结果为真 1234[root@VM-0-12-centos test]# [ -z &#x27;aaa&#x27; ];echo $?1[root@VM-0-12-centos test]# [ -z &#x27;&#x27; ];echo $?0 [[ “xxxx” == x* ]] 在表达式中表⽰0或者多个字符 12345678910[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == a* ]];echo $?0[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == b* ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == *a ]];echo $?0[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == *a ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a* ]];echo $?0 [[ xxx == x?? ]] 在表达式中表⽰单个字符 123456[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a? ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a??b ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a?b ]];echo $?0 ❖ 逻辑判断12345678910[root@VM-0-12-centos ~]# [ ! 100 -ge 1 ];echo $? #非1[root@VM-0-12-centos ~]# [ 2 -ge 1 -a 3 -ge 4 ];echo $? #与1[root@VM-0-12-centos ~]# [ 2 -ge 1 -o 3 -ge 4 ];echo $? #或0[root@VM-0-12-centos ~]# [[ 2 -ge 1 &amp;&amp; 3 -ge 4 ]];echo $? #与1[root@VM-0-12-centos ~]# [[ 2 -ge 1 || 3 -ge 4 ]];echo $? #或0 ❖ shell内置判断 -e file 如果⽂件存在，则结果为真 1234[root@VM-0-12-centos test]# ls1.sh newtest[root@VM-0-12-centos test]# [ -e 1.sh ];echo $?0 -d file 如果⽂件是⼀个⼦⽬录，则结果为真 12345[root@VM-0-12-centos test]# [ -d test ];echo $?1[root@VM-0-12-centos test]# [ -d newtest ];echo $?0 -f file 如果⽂件是⼀个普通⽂件，则结果为真 1234[root@VM-0-12-centos test]# [ -f newtest ];echo $?1[root@VM-0-12-centos test]# [ -f 1.sh ];echo $?0 -r file 如果⽂件可读，则结果为真 -s file 如果⽂件的长度不为0，则结果为真 12345678[root@VM-0-12-centos test]# lltotal 4--w--w--w- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# [ -s 1.sh ];echo $?1[root@VM-0-12-centos test]# [ -s newtest ];echo $?0 -w file 如果⽂件可写，则结果为真 -x file 如果⽂件可执⾏，则结果为真 12345678910[root@VM-0-12-centos test]# lltotal 4-rw-rw-rw- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# [ -x newtest ];echo $?0[root@VM-0-12-centos test]# [ -x 1.sh ];echo $?0[root@VM-0-12-centos test]# [ -x 1.sh ];echo $?1 [[]]是[]的扩展语法，在⽼的sh⾥并不⽀持。推荐⽤[] 逻辑控制条件 if❖ if [ condition ] ; then …;fi1234567[root@VM-0-12-centos test]# lltotal 4-rw-r--r-- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# if [ -e newtest ];then echo exist;fiexist[root@VM-0-12-centos test]# if [ -e test ];then echo exist;fi ❖ if [ condition ] ; then …;else …;fi1234[root@VM-0-12-centos test]# if [ -e test ];then echo exist;else echo not exist;finot exist[root@VM-0-12-centos test]# if [ -e newtest ];then echo exist;else echo not exist;fiexist ❖ if [ condition ] ; then …;elif …;fi12[root@VM-0-12-centos test]# if [ -e test ];then echo test;elif [ -e newtest ];then echo newtest;else echo null;finewtest ❖ 简单的逻辑可以使⽤ &amp;&amp; || 去替代123456789101112[root@VM-0-12-centos test]# [ -e newtest ]&amp;&amp;echo exist||echo not existexist[root@VM-0-12-centos test]# [ -e test ]&amp;&amp;echo exist||echo not existnot exist# 首先执行echo&quot;1&quot;,然后执行2，因为是选择2或3，已经执行2，所以忽略3。其他同理[root@VM-0-12-centos test]# echo &quot;1&quot; &amp;&amp; echo &quot;2&quot; || echo &quot;3&quot; &amp;&amp; echo &quot;4&quot; || echo &quot;5&quot; || echo &quot;6&quot; &amp;&amp; echo &quot;7&quot; &amp;&amp; echo &quot;8&quot; || echo &quot;9&quot;12478 ❖ 条件可以⽤命令返回值代替 分⽀ case⽤于条件太多的情况。每⼀个条件最后使⽤两个分号结尾，不可缺少。 1234567case $var in p1) … ;; p2) … ;; … pn) … ;; *) …;; esac for 循环格式：123for(( c1 ; c2 ; c3 )); do … ;done 例子：1234567891011[root@VM-0-12-centos test]# for ((i=0;i&lt;10;i++));do echo $i;done01...9[root@VM-0-12-centos test]# array=(1 2 3 4 5)[root@VM-0-12-centos test]# for ((i=0;i&lt;$&#123;#array[*]&#125;;i++))do echo $i;done01..4 for循环遍历⽤于递归数组，还可以递归以空格隔开的字符串序列。或者是某个命令的返回值。 格式123for f in $array[*];do …..done 例子12345678[root@VM-0-12-centos test]# for x in $&#123;array[@]&#125;;do echo $x;done1...5[root@VM-0-12-centos test]# ss=(aa bb cc &quot;sss dd&quot;);for x in &quot;$&#123;ss[@]&#125;&quot;;do echo $x;doneaabbcc while 循环格式 1234name=valuewhile [xxxxxx];do ....;done 例子 1234[root@VM-0-12-centos test]# i=0;while [ $i -lt 3 ];do echo $i;((i=i+1));done012 ⼀个有⽤的⼩技巧。⼀⾏⾏的读取⽂件内容 while read line;do echo $line;done &lt; /路径/文件名 等价于 cat untilselect Select var in var_list;do ….;done; 菜单选择，⼀般与case结构⼀起⽤ Break 和 continue break 退出当前循环。默认为1 break 2 退出两层循环。 continue 跳过当前的循环，进⼊下⼀次循环。 continue 2 跳到上层循环的下⼀次循环中 return 函数返回 exit 脚本退出","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"}]},{"title":"shell基础","slug":"shell基础","date":"2020-10-20T08:57:00.000Z","updated":"2020-10-22T06:20:30.000Z","comments":true,"path":"shell基础.html","link":"","permalink":"https://www.lauyongyi.cn/shell%E5%9F%BA%E7%A1%80.html","excerpt":"记录shell学习过程中的一些知识点","text":"记录shell学习过程中的一些知识点 Shell 运⾏环境概念 bash是⼀个进程 ​ bash下还可以再重新启动⼀个shell，这个shell是sub shell，原shell会复制 ⾃⾝给他 ​ 在sub shell中定义的变量，会随着sub shell的消亡⽽消失 () ⼦shell中运⾏ {} 当前shell中执⾏ $$ 当前脚本执⾏的pid &amp; 后台执⾏ $!运⾏在后台的最后⼀个作业的PID(进程ID) 常用命令​ echo 用于字符串的输出 ​ 使用 $var 或 ${var} 来访问变量。后者更为严谨。 ​ 变量不需要定义也可以使用。引用未定义的变量，默认为空值 1234567[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# echo $a1[root@VM-0-12-centos ~]# echo $a_1[root@VM-0-12-centos ~]# echo $&#123;a&#125;_11_1 变量定义变量定义方法/原则= 左右不能有空格12[root@VM-0-12-centos ~]# a = 1-bash: a: command not found 如果内容有空格，需要使用单引号或者双引号12345[root@VM-0-12-centos ~]# a=hello word-bash: word: command not found[root@VM-0-12-centos ~]# a=&#x27;hello word&#x27;[root@VM-0-12-centos ~]# echo $ahello word 双引号用于括起一段字符串值，支持$var 形式的变量替换​ 单引号也可以表示其内容是字符串值，不支持转义 12345[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# echo &#x27;hello $a&#x27;hello $a[root@VM-0-12-centos ~]# echo &quot;hello $a&quot;hello 1 \\反斜线， 某些情况下表示转义123[root@VM-0-12-centos ~]# a=&quot;hello world \\&quot;haha\\&quot;&quot;[root@VM-0-12-centos ~]# echo $ahello world &quot;haha&quot; ​ $开头的变量会被自动替换 大小写敏感123456[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# A=2[root@VM-0-12-centos ~]# echo $a1[root@VM-0-12-centos ~]# echo $A2 `反引号可以执行命令1234567[root@VM-0-12-centos ~]# a=`ls`[root@VM-0-12-centos ~]# echo $aapache-ant-1.9.15-bin.tar.gz apache-jmeter-5.3.tgz chromedriver_linux64.zip chromedriver_linux64.zip.1 employees_db employees_db-full-1.0.6.tar.bz2 gradle-6.3-all.zip jdk-8u261-linux-x64.tar.gz learning-API-test mysql-community-release-el7-5.noarch.rpm openssl openssl-1.1.1h openssl-1.1.1h.tar.gz Python-3.8.5 Python-3.8.5.tgz Python-3.8.5.tgz.1 sdk-tools-linux-3859397.zip[root@VM-0-12-centos ~]# dateTue Oct 20 17:47:24 CST 2020[root@VM-0-12-centos ~]# echo `date`Tue Oct 20 17:47:27 CST 2020 ({1..10}) 等价于 seq 1 10。表示1到10123[root@VM-0-12-centos ~]# a=(&#123;1..10&#125;)[root@VM-0-12-centos ~]# echo $&#123;a[*]&#125;1 2 3 4 5 6 7 8 9 10 $(()) 对变量进行操作。比如相加123456[root@VM-0-12-centos ~]# a=2;b=4[root@VM-0-12-centos ~]# echo $((a+b))6[root@VM-0-12-centos ~]# c=5;d=10;e=10[root@VM-0-12-centos ~]# echo $((c*d-e))40 变量类型 字符串： a=“xxxx”取值 $&#123;value:offset&#125; $&#123;value:offset:length&#125; 从变量中提取⼦串 123456789[root@VM-0-12-centos ~]# a=&quot;hello shell by linux&quot;[root@VM-0-12-centos ~]# echo $&#123;a:6&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a:6:6&#125;shell[root@VM-0-12-centos ~]# echo $&#123;a:6:3&#125;she[root@VM-0-12-centos ~]# echo $&#123;a:6:10&#125;shell by l $&#123;#value&#125; 字符串长度 123[root@VM-0-12-centos ~]# a=&quot;hello shell by linux&quot;[root@VM-0-12-centos ~]# echo $&#123;#a&#125;20 $&#123;#array[*]&#125;和$&#123;#array[@]&#125;表⽰数组中元素的个数 数组变量 括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 1数组名&#x3D;(值1 值2 ... 值n) 例如： 1array_name&#x3D;(value0 value1 value2 value3) 读取数组 读取数组元素值的一般格式是： ${数组名[下标[^1]]} [^1]: 从 0 开始 例如： 1valuen&#x3D;$&#123;array_name[n]&#125; 使用 @ 符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length&#x3D;$&#123;#array_name[@]&#125;# 或者length&#x3D;$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn&#x3D;$&#123;#array_name[n]&#125; 掐头去尾与内容替换 $&#123;value#pattern&#125; $&#123;value##pattern&#125; #表⽰掐头 12345678[root@VM-0-12-centos ~]# echo $&#123;a#hello&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a##hello&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a##*l&#125;inux[root@VM-0-12-centos ~]# echo $&#123;a#*l&#125;lo shell by linux $&#123;value%pattern&#125; $&#123;value%%pattern&#125; %表⽰去尾 12345678[root@VM-0-12-centos ~]# echo $&#123;a%linux&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%%linux&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%l*&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%%l*&#125;he $&#123;value/pattern/string&#125; $&#123;value//pattern/string&#125; /表⽰替换 123456[root@VM-0-12-centos ~]# echo $ahello shell by linux[root@VM-0-12-centos ~]# echo $&#123;a/by/to&#125;hello shell to linux[root@VM-0-12-centos ~]# echo $&#123;a//by/to&#125;hello shell to linux #与## %与%% /与//的区别：最短匹配模式VS最长匹配模式 $&#123;var/#Pattern/Replacement&#125; $&#123;var/%Pattern/Replacement&#125; 1234[root@VM-0-12-centos ~]# echo $&#123;a/#hello/good&#125;good shell by linux[root@VM-0-12-centos ~]# echo $&#123;a/%linux/to&#125;hello shell by to 数字：i=12132数字型变量操作123456[root@VM-0-12-centos ~]# i=1;echo $((i+1)) #计算2[root@VM-0-12-centos ~]# ((i=i+1));echo $i #更新2[root@VM-0-12-centos ~]# awk &#x27;BEGIN&#123;print 1/3&#125;&#x27; #浮点数运算0.333333 布尔： a=true;b=false​ $?，用于输出上一条命令的执行结果，成功为0，失败为1 1234567[root@VM-0-12-centos ~]# a=5;b=10[root@VM-0-12-centos ~]# ((a&gt;b))[root@VM-0-12-centos ~]# echo $?1[root@VM-0-12-centos ~]# ((a&lt;b))[root@VM-0-12-centos ~]# echo $?0 预定义变量12345678[root@VM-0-12-centos ~]# echo $PWD/root[root@VM-0-12-centos ~]# echo $USERroot[root@VM-0-12-centos ~]# echo $HOME/root[root@VM-0-12-centos ~]# echo $PATH/usr/local/jmeter/apache-jmeter-5.3/bin:/usr/local/java/jdk1.8/bin:/usr/local/ant/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk1.8/bin:/usr/local/java/jdk1.8/jre/bin:/opt/android/sdk:/opt/android/sdk/tools:/opt/android/sdk/platform-tools:/opt/android/sdk/emulator:/opt/android/sdk/tools/bin:/opt/gradle/gradle-6.3/bin:/root/bin:/root/bin","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"}]},{"title":"接口自动化学习中遇到的问题","slug":"python接口自动化学习","date":"2020-10-19T03:50:30.000Z","updated":"2020-10-19T03:05:30.000Z","comments":true,"path":"python接口自动化学习.html","link":"","permalink":"https://www.lauyongyi.cn/python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AD%A6%E4%B9%A0.html","excerpt":"记录python+requests学习中遇到的问题，原因和解决方法","text":"记录python+requests学习中遇到的问题，原因和解决方法 CookiesJar为空在做登录请求的时候，为了持续进行访问，需要保存cookie，对登录请求的cookies打印后，发现返回为空 原因： 使用fiddler抓包得出，在登录成功后，登录请求显示302（链接重定向），怀疑是requests默认重定向，导致cookies失效 解决方法：1allow_redirects=True 设为1allow_redirects=False 重定向链接为空场景同上，需要打印重定向链接，使用下面的代码进行重定向链接打印 12new_url &#x3D; r.headers[&quot;Location&quot;]print (new_url) 但提示KeyError: ‘location’ 原因：使用fiddler抓包得出，在登录成功后，登录请求自动重定向到登录后的页面 解决方法：1allow_redirects=True 设为 1allow_redirects=False","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python排序","slug":"python排序","date":"2020-10-16T05:50:30.000Z","updated":"2020-10-16T06:15:30.000Z","comments":true,"path":"python排序.html","link":"","permalink":"https://www.lauyongyi.cn/python%E6%8E%92%E5%BA%8F.html","excerpt":"记录python排序常用的方法和内置函数","text":"记录python排序常用的方法和内置函数 为了验证排序是否正确，采用python生成随机数的方式进行验证 123import randomlist_1 = random.sample(range(1, 50),20)) #随机取1-49之间的20个随机数，不重复print (list_1) 常用的排序算法冒泡排序：相邻两个元素比较，大的排后面，第一次把最大的数排在最后一位；继续排，把第二大的数排在倒数第二位… 冒泡排序总共排的次数为：1+2+3+…+n-1,共 n(n-1)/2，时间复杂度为n平方； 方法一1234567def dubble_sort(li): s = range(len(li))[::-1] #交换次数 for i in s: for j in range(i): if li[j] &gt; li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] # 交换元素 return li 方法二： 12345678910def dubble_sort(li): for i in range(len(li)-1):#i是索引，表示趟数 change=False for j in range(len(li)-i-1):#j是除去i个元素后的列表的索引（循环进行了几次就说明有几个元素已经被排好序） if li[j]&gt;li[j+1]: li[j],li[j+1]=li[j+1],li[j] change=True if not change: return li return li 快速排序：快速排序：选取数组的某一个数作为基准（一般选第一个最后一位）， 排列整个数值，比基准小的排到左边，比基准大的数 排在右边继续选取新生成的数值的第一个数 进行排序 方法一：123456789def quick_sort(list): if len(list) &lt; 2: # 基线条件（停止递归的条件） return list else: # 递归条件 basevalue = list[0] # 以第一个为基准值 less = [m for m in list[1:] if m &lt; basevalue] # 比基准小的 equal = [n for n in list if n == basevalue] greater = [s for s in list[1:] if s &gt; basevalue] # 比基准大的 return quick_sort(less) + equal + quick_sort(greater) 方法二：1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] 选择排序 选择排序的思路是：第一轮的时候，所有的元素都和第一个元素进行比较，如果比第一个元素大，就和第一个元素进行交换，在这轮比较完后，就找到了最小的元素；第二轮的时候所有的元素都和第二个元素进行比较找出第二个位置的元素，以此类推。 方法一：1234567def selection_sort(list): length = len(list) for i in range(length - 1, 0, -1): for j in range(i): if list[j] &gt; list[i]: list[j], list[i] = list[i], list[j] return list 方法二：1234567891011def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr 插入排序 插入排序的思想是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。 是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置）， 而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 方法： 1234567891011def insert_sort(list): count = len(list) for i in range(1, count): key = list[i] j = i - 1 while j &gt;= 0: if list[j] &gt; key: list[j + 1] = list[j] list[j] = key j -= 1 return list 希尔排序 希尔排序是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。 该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少， 每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 12345678910111213def shell_sort(lis): n = len(lis) gap = int(n / 2) while gap &gt; 0: for i in range(gap, n): temp = lis[i] j = i - gap while j &gt;= 0 and lis[j] &gt; temp: lis[j + gap] = lis[j] j = j - gap lis[j + gap] = temp gap = int(gap / 2) return lis Python内置函数排序：Python中拥有内置函数实现排序，可以直接调用它们实现排序功能 Python 列表有一个内置的 list.sort() 方法可以直接修改列表。还有一个 sorted() 内置函数，它会从一个可迭代对象构建一个新的排序列表。 sorted () 函数sorted() 函数可以对输入的迭代对象元素排序后生成新的列表。sorted(iterable, cmp=None, key=None, reverse=False) 其中： iterable – 可迭代对象。 cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 示例：12345678&gt;&gt;&gt; sorted([3,7,2,8,5])[2, 3, 5, 7, 8]&gt;&gt;&gt; a = [[6, 5], [3, 7], [2, 8]]&gt;&gt;&gt; sorted(a, key=lambda x:x[0]) # 根据每一行的首元素排序，默认reverse=False[[2, 8], [3, 7], [6, 5]]&gt;&gt;&gt; sorted(a, key=lambda x:x[-1]) # 根据每一行的尾元素排序，设置reverse=True实现逆序[[6, 5], [3, 7], [2, 8]] sort()函数1list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False) 其中参数的含义是： cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。 示例：123list = [1,6,7,8,2,4,3,5,9]list.sort()print(list) sort()和sorted()虽然相似，都可以实现排序功能，但是它们有很大的不同： sort ()与sorted()区别：sort() 是应用在 list 上的方法，sorted() 可以对所有可迭代的对象进行排序操作。 list 的 sort() 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted() 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"SQL连接","slug":"SQL连接查询","date":"2020-10-16T04:38:00.000Z","updated":"2020-10-16T04:38:00.000Z","comments":true,"path":"SQL连接查询.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.html","excerpt":"SQL 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。","text":"SQL 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。 考虑下面两个表，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一个表是 ORDERS 表： 12345678+-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这个两张表连接（JOIN）在一起： 123SQL&gt; SELECT ID, NAME, AGE, AMOUNT FROM CUSTOMERS, ORDERS WHERE CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句的运行结果如下所示： 12345678+----+----------+-----+--------+| ID | NAME | AGE | AMOUNT |+----+----------+-----+--------+| 3 | kaushik | 23 | 3000 || 3 | kaushik | 23 | 1500 || 2 | Khilan | 25 | 1560 || 4 | Chaitali | 25 | 2060 |+----+----------+-----+--------+ SQL 连接类型SQL 中有多种不同的连接： 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。 左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。 右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。 全连接（FULL JOIN）：只要某一个表存在匹配，就返回行。 笛卡尔连接（CARTESIAN JOIN）：返回两个或者更多的表中记录集的笛卡尔积。 内连接最常用也最重要的连接形式是内连接，有时候也被称作“EQUIJOIN”（等值连接）。 内连接根据连接谓词来组合两个表中的字段，以创建一个新的结果表。SQL 查询会比较逐个比较表 1 和表 2 中的每一条记录，来寻找满足连接谓词的所有记录对。当连接谓词得以满足时，所有满足条件的记录对的字段将会结合在一起构成结果表。 语法：内连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1INNER JOIN table2ON table1.common_field &#x3D; table2.common_field; 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用内连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+----+----------+--------+---------------------+ 左连接左链接返回左表中的所有记录，即是右表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在右表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自右表的字段都为 NULL。 这就意味着，左连接会返回左表中的所有记录，加上右表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：左连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1LEFT JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用左连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 123456789101112+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL || 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL |+----+----------+--------+---------------------+ 左连接右链接返回左表中的所有记录，即是左表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在左表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自左表的字段都为 NULL。 这就意味着，右连接会返回右表中的所有记录，加上左表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：右连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1RIGHT JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用右连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678+------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+------+----------+--------+---------------------+| 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+------+----------+--------+---------------------+ 全连接全连接将左连接和右连接的结果组合在一起。 语法：全连接的基本语法如下所受： 1234SELECT table1.column1, table2.column2...FROM table1FULL JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在让我们用全连接将两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS FULL JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678910111213141516+------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+------+----------+--------+---------------------+| 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL || 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+------+----------+--------+---------------------+ 如果你所用的数据库不支持全连接，比如 MySQL，那么你可以使用 UNION ALL子句来将左连接和右连接结果组合在一起： 123456789SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_IDUNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID 笛卡尔连接（交叉连接）笛卡尔连接或者交叉连接返回两个或者更多的连接表中记录的笛卡尔乘积。也就是说，它相当于连接谓词总是为真或者缺少连接谓词的内连接。 语法：笛卡尔连接或者说交叉连接的基本语法如下所示： 12SELECT table1.column1, table2.column2...FROM table1, table2 [, table3 ] 示例：123456789101112131415161718192021222324考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+（b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我用内连接将这两个表连接在一起： 12SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS, ORDERS; 上述语句将会产生如下结果： 1234567891011121314151617181920212223242526272829303132+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 1 | Ramesh | 3000 | 2009-10-08 00:00:00 || 1 | Ramesh | 1500 | 2009-10-08 00:00:00 || 1 | Ramesh | 1560 | 2009-11-20 00:00:00 || 1 | Ramesh | 2060 | 2008-05-20 00:00:00 || 2 | Khilan | 3000 | 2009-10-08 00:00:00 || 2 | Khilan | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 2 | Khilan | 2060 | 2008-05-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 3 | kaushik | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 2060 | 2008-05-20 00:00:00 || 4 | Chaitali | 3000 | 2009-10-08 00:00:00 || 4 | Chaitali | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | 3000 | 2009-10-08 00:00:00 || 5 | Hardik | 1500 | 2009-10-08 00:00:00 || 5 | Hardik | 1560 | 2009-11-20 00:00:00 || 5 | Hardik | 2060 | 2008-05-20 00:00:00 || 6 | Komal | 3000 | 2009-10-08 00:00:00 || 6 | Komal | 1500 | 2009-10-08 00:00:00 || 6 | Komal | 1560 | 2009-11-20 00:00:00 || 6 | Komal | 2060 | 2008-05-20 00:00:00 || 7 | Muffy | 3000 | 2009-10-08 00:00:00 || 7 | Muffy | 1500 | 2009-10-08 00:00:00 || 7 | Muffy | 1560 | 2009-11-20 00:00:00 || 7 | Muffy | 2060 | 2008-05-20 00:00:00 |+----+----------+--------+---------------------+","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"数据库基础知识","slug":"数据库基础知识","date":"2020-10-15T09:09:00.000Z","updated":"2020-10-15T09:09:30.000Z","comments":true,"path":"数据库基础知识.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html","excerpt":"什么是关系型数据库管理系统？RDBMS 是关系型数据库管理系统（Relational DataBase Management System)的缩写，它是 SQL 以及所有现代数据库系统，例如 MS SQL Server、IBM DB2、Oracle、MySQL 和 MS Access等的基础。 关系型数据库管理系统（RDBMS）是一种基于 E.F. 科德提出的关系模型的数据库管理系统。","text":"什么是关系型数据库管理系统？RDBMS 是关系型数据库管理系统（Relational DataBase Management System)的缩写，它是 SQL 以及所有现代数据库系统，例如 MS SQL Server、IBM DB2、Oracle、MySQL 和 MS Access等的基础。 关系型数据库管理系统（RDBMS）是一种基于 E.F. 科德提出的关系模型的数据库管理系统。 什么是表？RDBMS 中的数据存储在被称作表的数据库对象中。表是相互关联的数据记录的集合，由一系列的行和列组成。 谨记，表是关系型数据库中最常见也是最简单的数据存储形式。下面是一个客户信息表的例子： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ 什么是字段？每张表都能够划分成更小的实体——字段。例如，上面的客户信息表中有 ID、NAME、AGE、ADDRESS 和 SALARY 五个字段。 一个字段限定了数据表中的列，被用来维护表中所有记录的特定信息。 什么是记录或者数据行？记录或者说数据行是存在于数据表中的独立条目。例如，上面的客户信息表中有 7 条记录。下面是客户信息表中的一条记录： 123+----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | +----+----------+-----+-----------+----------+ 记录就是表中水平排列的数据构成的实体。 什么是列？列是表中竖直排列的实体，它包含了表中与某一特定字段相关的所有信息。 例如，上面的客户信息表中有字段为 ADDRESS 的列，存储了客户的地址，其内容如下所示： 1234567891011+-----------+ | ADDRESS | +-----------+ | Ahmedabad | | Delhi | | Kota | | Mumbai | | Bhopal | | MP | | Indore | +----+------+ 什么是 NULL 值？NULL 值是表中以空白形式出现的值，表示该记录在此字段处没有设值。 一定要明白 NULL 值同 0 值或者包含空格的字段是不同的。值为 NULL 的字段是在记录创建的时候就被留空的字段。 SQL 约束约束是表中的数据列必须遵守的规则，用于限制表中数据的类型。约束保证了数据库中数据的精确性和可靠性。 约束可以限制列或者表。列级的约束只限制单一的列，而表级的约束作用于整个表。 以下是 SQL 中常见的约束： NOT NULL 约束：保证列中数据不能有 NULL 值 DEFAULT 约束：提供该列数据未指定时所采用的默认值 UNIQUE 约束：保证列中的所有数据各不相同 主键：唯一标识数据表中的行/记录 外键：唯一标识其他表中的一条行/记录 CHECK 约束：此约束保证列中的所有值满足某一条件 索引：用于在数据库中快速创建或检索数据 NOT NULL 约束默认情况下，数据表中的字段接受 NULL 值。如果你不想让某个字段接受 NULL 值，那么请为该字段定义此约束，以指明该字段不接受 NULL 值。 NULL 并不是指没有数据，而是指该字段数据未知。 示例：例如，下述 SQL 语句创建了一个新的数据表 CUSTOMERS，并添加了五个字段，其中三个字段——ID、NAME 和 AGE——被指定为 NOT NULL： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 对于 Oracle 和 MySQL 来说，如果 CUSTOMERS 表已经存在，此时再要给 SALARY 字段添加 NOT NULL 约束的话，SQL 语句应当如下： 12ALTER TABLE CUSTOMERS MODIFY SALARY DECIMAL (18, 2) NOT NULL; DEFAULT 约束DEFAULT 约束在 INSERT INTO 语句没有提供的情况下，为指定字段设置默认值。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并添加了五个字段。这里，SALARY 字段的默认值为 5000。因此，如果 INSERT INTO 没有为该字段提供值的话，该字段就为默认值 5000。 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2) DEFAULT 5000.00, PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，此时再要给 SALARY 字段添加 DEFAULT 约束的话，你需要类似下面的语句： 12ALTER TABLE CUSTOMERS MODIFY SALARY DECIMAL (18, 2) DEFAULT 5000.00; 删除 DEFAULT 约束：要删除 DEFAULT 约束的话，请使用下面的 SQL 语句： 12ALTER TABLE CUSTOMERS ALTER COLUMN SALARY DROP DEFAULT; UNIQUE 约束UNIQUE 约束使得某一字段对任意两条记录来说都不能相同。例如，在 CUSTOMERS 表中，你或许想让任何人的年龄（age）都不相同。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并添加了五个字段，其中 AGE 字段被设为 UNIQUE，于是任意两条记录的 AGE 都不同： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL UNIQUE, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，再要为 AGE 字段添加 UNIQUE 约束的话，你需要像下面这样写 SQL 语句： 12ALTER TABLE CUSTOMERS MODIFY AGE INT NOT NULL UNIQUE; 还可以使用如下所示的语法，该语法还支持对作用于多个字段的约束进行命名： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT myUniqueConstraint UNIQUE(AGE, SALARY); 删除 UNIQUE 约束要删除 UNIQUE 约束的话，请使用如下 SQL 语句： 12ALTER TABLE CUSTOMERS DROP CONSTRAINT myUniqueConstraint; 如果你在使用 MySQL，那么下面的语法也是可行的： 12ALTER TABLE CUSTOMERS DROP INDEX myUniqueConstraint; 主键主键是数据表中唯一确定一条记录的字段。主键必须包含唯一值，并且不能为 NULL。 每张数据表只能有一个主键，不过一个主键可以包含一个或者多个字段。如果主键由多个字段组合而成，这些字段就被称作组合键。 如果一个字段被定义为了某表的主键，则任意两条记录在该字段处不能相同。 注意：在创建数据表的时候，需要用到这些概念。 创建主键：如下是将 ID 定义为 CUSTOMERS 表主键的语法： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在了，再要将 ID 定义为主键的话，请使用下面的语句： 1ALTER TABLE CUSTOMER ADD PRIMARY KEY (ID); 注意：如果你要使用 ALTER TABLE 语句来添加主键，那么主键所在的列必须已经被声明为 NOT NULL 了。 要用多个字段来定义主键的话，请使用如下 SQL 语法： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID, NAME)); 如果 CUSTOMERS 表已经存在，此时再要将 ID 和 NAMES 字段定义为主键的话，请使用如下 SQL 语法： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT PK_CUSTID PRIMARY KEY (ID, NAME); 删除主键你可以将主键约束从数据表中删除，语法如下： 1ALTER TABLE CUSTOMERS DROP PRIMARY KEY ; 外键外键用于将两个数据表连接在一起，有时候也被称作“参照键”。 外键为单一字段或者多个字段的组合，并与另外一个数据表的主键相匹配。 两个表之间的关系是：一个表的主键与另一个表的外键相匹配。 示例：考虑如下两个表的结构： CUSTOMERS 表： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); ORDERS 表： 1234567CREATE TABLE ORDERS ( ID INT NOT NULL, DATE DATETIME, CUSTOMER_ID INT references CUSTOMERS(ID), AMOUNT double, PRIMARY KEY (ID)); 如果 ORDERS 表已经存在，并且没有设置外键，那么可以使用下面的语法来修改数据表以指定外键。 12ALTER TABLE ORDERS ADD FOREIGN KEY (Customer_ID) REFERENCES CUSTOMERS (ID); 删除外键约束：要删除外键约束的话，语法如下所示： 12ALTER TABLE ORDERS DROP FOREIGN KEY; CHECK 约束CHECK 约束使用某一条件来对记录中的值进行检查。如果条件最终为假（false），即约束条件不能得到满足，则该记录不能写入数据表中。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并为其添加了五个字段。在此，我们为 AGE 字段设置了 CHECK 约束，以拒绝任何年龄低于 18 的顾客： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL CHECK (AGE &gt;&#x3D; 18), ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，再要为 AGE 字段设置 CHECK 约束的话，就需要像下面这样写 SQL 语句： 12ALTER TABLE CUSTOMERS MODIFY AGE INT NOT NULL CHECK (AGE &gt;&#x3D; 18 ); 或者也可以使用下面的语法，该语法还支持对作用于多个字段的约束命名： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT myCheckConstraint CHECK(AGE &gt;&#x3D; 18); 删除 CHECK 约束：要删除 CHECK 约束的话，请使用下面的 SQL 语句，不过该语句在 MySQL 中不起作用： 12ALTER TABLE CUSTOMERS DROP CONSTRAINT myCheckConstraint; 索引索引用于在数据库中快速地创建和检索数据。索引可以由表中的一个或者多个字段创建。创建索引时，每一行都会获得一个 ROWID（在数据进行排序之前）。 合理运用索引可以提高大型数据库的性能。但是，创建索引之前还是要三思而后行。为哪些字段创建索引，则取决于 SQL 查询最常用到到哪些字段。 示例：例如，下面的 SQL 语句创建了一个名为 CUSTOMERS 的新表，并为其添加了五个字段： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 现在，你就可以使用下面的语法来为一个或者多个字段创建索引了： 12CREATE INDEX index_name ON table_name ( column1, column2.....); 例如，可以在 AGE 字段上创建索引，以优化对特定年龄的顾客的查询，其语法如下所示： 12CREATE INDEX idx_age ON CUSTOMERS ( AGE ); 删除索引约束：要删除索引约束的话，可以使用下面的 SQL 语句： 12ALTER TABLE CUSTOMERS DROP INDEX idx_age; 数据完整性下面几类数据完整性存在于各个 RDBMS 中： 实体完整性：表中没有重复的行 域完整性：通过限制数据类型、格式或者范围来保证给定列的数据有效性 参照完整性：不能删除被其他记录引用的行 用户定义完整性：施加某些不属于上述三种完整性的业务规则","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"Centos安装Mysql","slug":"centos安装MySQL","date":"2020-10-15T07:57:00.000Z","updated":"2020-10-15T07:57:00.000Z","comments":true,"path":"centos安装MySQL.html","link":"","permalink":"https://www.lauyongyi.cn/centos%E5%AE%89%E8%A3%85MySQL.html","excerpt":"记录Centos安装MySQL的全程过程","text":"记录Centos安装MySQL的全程过程 安装MySQL安装前的准备工作：检测系统是否自带安装 MySQL 1rpm -qa | grep mysql 如果系统有安装，那可以选择进行卸载： 12rpm -e mysql // 普通删除模式rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 安装 MySQL：需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ 1234wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum updateyum install mysql-server 权限设置：1chown mysql:mysql -R &#x2F;var&#x2F;lib&#x2F;mysql 初始化 MySQL：1mysqld --initialize 启动 MySQL：1systemctl start mysqld 查看 MySQL 运行状态：1systemctl status mysqld 验证 MySQL 安装1mysqladmin --version Mysql安装后需要做的Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： 1[root@host]# mysqladmin -u root password &quot;new_password&quot;; 使用Navicat链接MySQL刚安装完成时，使用Navicat链接MySQL，有可能会出现1130 - Host XXX is not allowed to connect to this MySQL server。错误提示 原因是：在MySQL的host配置里，没有你机器的IP地址（没有授权外网访问），所以无法访问 解决方法1（改表法）：在安装Mysql数据库的主机上登录root用户： mysql -u root -p 输入密码后访问，执行 12use mysql;select host from user where user&#x3D;&#39;root&#39;; 会出现类似的结果： 12345678+----------------+| host |+----------------+| localhost || 127.0.0.1 || ::1 || vm-0-12-centos |+----------------+ 将Host设置为通配符**%** update user set host = &#39;%&#39; where user =&#39;root&#39;; Host修改完成后记得执行flush privileges使配置立即生效 1flush privileges; 再次链接就可以成功了。 此方法会引发的问题：一但把localhost改为通配符**%**，服务端将无法直接使用mysql -uroot -p进行数据库登录 解决方法2（授权法）： 例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO &#39;myuser&#39;@&#39;%&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.3&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION; 最后一定要执行 flush privileges;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.lauyongyi.cn/tags/MySQL/"}]},{"title":"SQL概览","slug":"SQL是什么","date":"2020-10-15T03:47:00.000Z","updated":"2020-10-15T04:11:00.000Z","comments":true,"path":"SQL是什么.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E6%98%AF%E4%BB%80%E4%B9%88.html","excerpt":"SQL 是用于访问和处理数据库的标准的计算机语言。","text":"SQL 是用于访问和处理数据库的标准的计算机语言。 SQL简介：SQL是结构化查询语言（Structured Query Language），一种用于存储、操作或者检索存储在关系型数据库中数据的计算机语言。 SQL是关系型数据库系统（Relation Database System）的标准语言。所有关系性数据库系统，例如MySQL、MSAccess、Oracle、Sybase、Informix、Postgres SQL和SQL Server，都是用SQL作为其标准数据库语言。 SQL 是一个 ANSI（American National Standard Institute，美国国家标准协会）标准。不过，SQL 语言有很多不同的版本存在。 SQL的用途： 允许用户访问关系型数据库中的数据 SQL 面向数据库执行查询 SQL 可从数据库取回数据 允许用户对数据做出描述 允许用于定义数据库中的数据，并对其进行操作 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 允许通过 SQL 模块、库或者预编译器的等方式，嵌入到其他语言中 允许用户创建或删除数据库和表 SQL 可创建新数据库 SQL 可在数据库中创建新表 允许用户在数据库中创建视图、存储过程和函数 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 允许用户对表、过程和视图设进行权限设置 SQL的流程：在任何一种 RDBMS 上执行 SQL 命令，数据库管理系统都会判断出执行请求的最佳方式，并由 SQL 引擎推算出具体如何完成任务。 这一流程涉及到了各种各样的组件，包括查询调度器（Query Dispatcher）、优化引擎（Optimization Engines）、经典查询引擎（Classic Query Engine）和 SQL 查询引擎（SQL Query Engine）等等。经典查询引擎用于处理所有的非 SQL 查询，而 SQL 查询引擎则不处理逻辑文件。 SQL 命令用于与关系型数据库交互的标准 SQL 命令有 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP，这些命令按用途分成如下几组： 数据定义语言 命令 描述 CREATE 创建新的表、视图或者其他数据库中的对象 ALTER 修改现存数据库对象，比如一张表 DROP 删除表、视图或者数据库中的其他对象 数据操纵语言 命令 描述 SELECT 从一张或者多张表中检索特定的数据 INSERT 创建一条新记录 UPDATE 修改记录 DELETE 删除记录 数据控制语言 命令 描述 GRANT 赋予用户特权 REVOKE 收回赋予用户的特权","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"SQL语事务","slug":"SQL事务","date":"2020-10-15T02:47:00.000Z","updated":"2020-10-15T03:11:00.000Z","comments":true,"path":"SQL事务.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E4%BA%8B%E5%8A%A1.html","excerpt":"事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。","text":"事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。 事务实际上就是对数据库的一个或者多个更改。当你在某张表上创建更新或者删除记录的时，你就已经在使用事务了。控制事务以保证数据完整性，并对数据库错误做出处理，对数据库来说非常重要。实践中，通常会将很多 SQL 查询组合在一起，并将其作为某个事务一部分来执行。 事务的属性/条件：一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制：有四个命令用于控制事务： COMMIT：提交更改； ROLLBACK：回滚更改； SAVEPOINT：在事务内部创建一系列可以 ROLLBACK 的还原点； SET TRANSACTION：命名事务； COMMIT 命令：COMMIT 命令用于保存事务对数据库所做的更改。 COMMIT 命令会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。 ROLLBACK 命令：ROLLBACK 命令用于撤销尚未保存到数据库中的事务。 ROLLBACK 命令只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。 SAVEPOINT 命令：SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。 RELEASE SAVEPOINT 命令：RELEASE SAVEPOINT 命令用于删除先前创建的保存点。 保存点一旦被释放，你就不能够再用 ROLLBACK 命令来撤销该保存点之后的事务了。 SET TRANSACTION 命令：SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"SQL语句进阶","slug":"SQL进阶","date":"2020-10-13T02:47:00.000Z","updated":"2020-10-13T10:11:00.000Z","comments":true,"path":"SQL进阶.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E8%BF%9B%E9%98%B6.html","excerpt":"记录一些在sqlzoo.net 遇到的不太理解的SQL语句知识","text":"记录一些在sqlzoo.net 遇到的不太理解的SQL语句知识 concat函數函數concat 可以用來合拼兩個或以上的字串。 例子： “Mexico 墨西哥”的首都是”Mexico City”。顯示所有國家名字,其首都是國家名字加上”City”。 SELECT name FROM world WHERE capital = concat(name, &#39;City&#39;) 找出所有首都和其國家名字,而首都要有國家名字中出現。 SELECT capital, name FROM world WHERE capital LIKE concat(&#39;%&#39;,name,&#39;%&#39;) 找出所有首都和其國家名字,而首都是國家名字的延伸。你應顯示 Mexico City,因它比其國家名字 Mexico 長。你不應顯示 Luxembourg,因它的首都和國家名相是相同的。 select name,capital from world where capital Like concat(&#39;%&#39;,name,&#39;%&#39;) and capital != name REPLACE()字符串替换函数replace函数定义replace(original-string，search-string，replace-string) 参数original-string： 被搜索的字符串。可为任意长度。search-string： 要搜索并被 replace-string 替换的字符串。该字符串的长度不应超过 255 个字节。如果 search-string 是空字符串，则按原样返回原始字符串。replace-string： 该字符串用于替换 search-string。可为任意长度。如果 replacement-string 是空字符串，则删除出现的所有 search-string。 说明 用字符串表达式3替换字符串表达式1中出现的所有字符串表达式2的匹配项。返回新的字符串。 如果有某个参数为 NULL，此函数返回 NULL。 例子： “Monaco-Ville”是合併國家名字 “Monaco” 和延伸詞”-Ville”.顯示國家名字，及其延伸詞，如首都是國家名字的延伸。 SELECT name,replace(capital, name, &#39;&#39;) FROM world WHERE capital LIKE concat(name,&#39;%_&#39;) ROUND() 函数​ ROUND() 函数用于把数值字段舍入为指定的小数位数。 SQL ROUND() 语法​ SELECT ROUND(column_name,decimals) FROM table_name; 参数 描述 column_name 必需。要舍入的字段。 decimals 必需。规定要返回的小数位数。 例子： ​ Germany德國（人口8000萬），在Europe歐洲國家的人口最多。Austria奧地利（人口850萬）擁有德國總人口的11％。 顯示歐洲的國家名稱name和每個國家的人口population。以德國的人口的百分比作人口顯示。 SELECT name, CONCAT(round(population/(SELECT population FROM world WHERE name =&#39;Germany&#39;)*100, 0), &#39;%&#39;) FROM world WHERE continent =&#39;Europe&#39;;。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"Jenkins自动打包","slug":"Jenkins编译安卓包","date":"2020-09-23T06:24:00.000Z","updated":"2020-09-23T06:30:00.000Z","comments":true,"path":"Jenkins编译安卓包.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93%E5%8C%85.html","excerpt":"记录一下，使用Jenkins进行安卓自动打包的操作过程。","text":"记录一下，使用Jenkins进行安卓自动打包的操作过程。 环境变量配置​ 首先，一定要先进行环境变量的配置，这里已经提前配置好了 JAVA_HOME 1、系统配置​ 路径：系统管理 – 系统配置 ​ 在全局属性添加ANDROID_HOME ​ 2、全局配置​ 路径：系统管理 – 全局工具配置 ​ 在 Gradle 添加 Gradle_HOME ​ 关于上面两个环境的安装，可以参考之前一篇笔记Centos配置SDK,gradle 项目配置​ 项目使用git进行源码管理，在源码管理选项里选择git，填写上对应的仓库地址。 ​ 可选项：构建触发器，可以根据项目需求，选择触发方式，由于这里时练手的个人项目，所以采用的是 轮询机制 ​ 项目的构建选择 ：Invoke Gradle script Gradle Version 选择手动配置的 Gradle_HOME Tasks 填写 clean assembleRelease #清除和构建（应该是清除之前的构建残余再重新构建的意思） 如果 clean assembleRelease 报错，可以先用 build 进行测试打包","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"jmeter参数化","slug":"jmeter参数化","date":"2020-09-18T09:24:00.000Z","updated":"2020-09-23T06:00:00.000Z","comments":true,"path":"jmeter参数化.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E5%8F%82%E6%95%B0%E5%8C%96.html","excerpt":"记录在使用jmeter进行测试时，常用的几种参数化方法","text":"记录在使用jmeter进行测试时，常用的几种参数化方法 用户参数​ 右键快捷菜单中：添加 – 前置处理器 – 用户参数。 用户参数可以设置多个值，以v2ex]的这个搜索链接为例https://www.v2ex.com/api/nodes/show.json?name=python 。 可以设置成以下参数 然后在HTTP请求，参数那里进行引用 然后将线程数设置为：3，运行，再查看结果树可以看到，请求了三次，每次请求都不同。 函数助手1、函数助手路径：点击菜单栏“选项”—-&gt;函数助手对话框，看下图 2、下面介绍一下常用系统函数： ​ time获取当前时间第一个参数为时间格式，第二个参数为存放获得当前时间值的参数名称，例在第一个参数输入yyyy-MM-dd HH:mm:ss，单击生成即可得到正确的函数表达式。 ​ Random随机数 ​ __StringFromFile从本地csv文件中读取记录存入参数与CSV Data Set Config相比，该函数的强大之处是它可以支持从多个文件中读取数据。第一个参数是文件名（使用绝对路径），第二个参数是存放取得数据的参数列表，第三个和第四个参数分别为数据文件的起始和终止顺序号。 3、举例 ​ 以https://api.apiopen.top/getJoke?count=20&amp;page=15&amp;type=all 为例。其中，count、page、type都可以参数化 ​ 1、Random随机数 ​ 如下图所示，将count，paga使用随机数作为参数 ​ 然后可以用用户参数的形式，将type进行参数化，配置好之后，如下图 将线程数设置成：10或以上，运行。从查看结果树可以看出，请求都是成功的，且请求链接都不相同。 ​ 2、CSVRead ​ 可以读取CSV文件里设置好的值，这里创建了一个名为：duanzi.csv的文件，用来存放参数值，具体参数值见下图： 打开函数助手CSV窗口，选择CSVRead，然后填写文件路径，以及取值的列（注：.csv文件第一列从0开始取），如下图所示 然后填写到测试链接里，线程数设置为：10，得到的结果都是正常运行，且链接里包含的参数值与csv里填写的值一样。 用户自定义变量右键快捷菜单中选择 添加-配置元件-用户自定义变量。 ​ 用户自定义变量中的定义的所有参数的值在测试计划的执行过程中不能发生取值的改变，因此一般仅将测试计划中不需要随迭代发生改变的参数（只取一次值的参数）设置在此处。以https://api.uomg.com/api/rand.music?sort=热歌榜&amp;format=json为例子。参数：sort、format 取样器中的sort和format用${sort}和${forma}代替，即使被测应用的部署服务器发生了变化，只需要简单地修改sort和format参数的取值即可。 正则表达式提取器右键快捷菜单中选择 添加-后置处理器-正则表达式提取器。 说明： ​ 引用名称：即变量名，后续请求中可以通过 ${引用名称} 来调用 ​ 正则表达式：按实际情况填写 ​ 模板：$$表示需要哪个正则表达式获取的值，1代表第一个，-1代表全部，0代表随机 ​ 匹配数字：1代表第一个，-1代表全部，0代表随机 ​ 缺省值：如果正则未匹配到，就会使用缺省值 正则说明： ​ . 表示除“\\r\\n”之外的任意字符 ​ ***** 表示匹配前面的子表达式任意次 ​ + 表示匹配前面的子表达式1次或多次 ​ ？ 表示匹配前面的子表达式0次或1次 ​ .*：贪婪匹配原则，即匹配到不能匹配为止 ​ .*?：非贪婪匹配，即在匹配成功的情况下尽可能少的匹配","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"jmeter-json断言","slug":"jmeter断言","date":"2020-09-18T09:04:00.000Z","updated":"2020-09-18T09:04:00.000Z","comments":true,"path":"jmeter断言.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E6%96%AD%E8%A8%80.html","excerpt":"记录jmeter使用过程中的断言使用情况","text":"记录jmeter使用过程中的断言使用情况 Json断言当相应结果为Json时，使用Json断言，会更加方便和快捷。 添加方式，右键快捷菜单 – 断言 –Json断言。界面如下： Assert JSON Path exists: #元素匹配 Additionally assert value # 等于特定值 Match as regular expression # 符合正则表达式 Expected Value： # 特定值 Expect null #预期空值 Invert assertion(will fail if abovew conditions met) #满足上面的条件则fail 判断方式： ​ 如果响应结果不是json格式的，fail ​ 如果json path找不到元素，fail ​ 如果json path找到元素，没有设置条件，pass ​ 如果json path找到元素了，不符合条件，fail ​ 如果json path找到元素，且符合条件，pass ​ 如果json path返回的是一个数组，迭代判断是否有元素符合条件，有则pass，无则fail 例子：使用随机的音乐推荐链接来进行验证：https://api.uomg.com/api/rand.music?sort=热歌榜&amp;format=json 响应结果如下： 123456789&#123; &quot;code&quot;: 1, &quot;data&quot;: &#123; &quot;name&quot;: &quot;你就不要想起我&quot;, &quot;url&quot;: &quot;http://music.163.com/song/media/outer/url?id=28018075&quot;, &quot;picurl&quot;: &quot;http://p3.music.126.net/aPnwHIJECLpQCoSV-qm_qA==/109951163571315498.jpg&quot;, &quot;artistsname&quot;: &quot;田馥甄&quot; &#125;&#125; json断言： 运行上面的断言，结果是成功的。 当去掉 Match as regular expression 断言是失败的 当加上了Invert assertion(will fail if abovew conditions met) 用例就会失败","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"jmeter相应编码转换","slug":"jmeter编码","date":"2020-09-18T03:24:00.000Z","updated":"2020-09-18T03:34:00.000Z","comments":true,"path":"jmeter编码.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E7%BC%96%E7%A0%81.html","excerpt":"使用jmeter进行测试的时候，有些情况下会出现相应内容乱码的情况。","text":"使用jmeter进行测试的时候，有些情况下会出现相应内容乱码的情况。 以v2ex为例响应结果有Unicode编码 需要添加后置处理器，编写脚本进行转码 添加下列代码即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556String s=new String(prev.getResponseData(),&quot;UTF-8&quot;);char aChar;int len= s.length();StringBuffer outBuffer=new StringBuffer(len);for(int x =0; x &lt;len;)&#123;aChar= s.charAt(x++);if(aChar==&#x27;\\\\&#x27;)&#123;aChar= s.charAt(x++);if(aChar==&#x27;u&#x27;)&#123;int value =0;for(int i=0;i&lt;4;i++)&#123;aChar= s.charAt(x++);switch(aChar)&#123;case&#x27;0&#x27;:case&#x27;1&#x27;:case&#x27;2&#x27;:case&#x27;3&#x27;:case&#x27;4&#x27;:case&#x27;5&#x27;:case&#x27;6&#x27;:case&#x27;7&#x27;:case&#x27;8&#x27;:case&#x27;9&#x27;:value=(value &lt;&lt;4)+aChar-&#x27;0&#x27;;break;case&#x27;a&#x27;:case&#x27;b&#x27;:case&#x27;c&#x27;:case&#x27;d&#x27;:case&#x27;e&#x27;:case&#x27;f&#x27;:value=(value &lt;&lt;4)+10+aChar-&#x27;a&#x27;;break;case&#x27;A&#x27;:case&#x27;B&#x27;:case&#x27;C&#x27;:case&#x27;D&#x27;:case&#x27;E&#x27;:case&#x27;F&#x27;:value=(value &lt;&lt;4)+10+aChar-&#x27;A&#x27;;break;default:throw new IllegalArgumentException(&quot;Malformed \\\\uxxxx encoding.&quot;);&#125;&#125;outBuffer.append((char) value);&#125;else&#123;if(aChar==&#x27;t&#x27;)aChar=&#x27;\\t&#x27;;else if(aChar==&#x27;r&#x27;)aChar=&#x27;\\r&#x27;;else if(aChar==&#x27;n&#x27;)aChar=&#x27;\\n&#x27;;else if(aChar==&#x27;f&#x27;)aChar=&#x27;\\f&#x27;;outBuffer.append(aChar);&#125;&#125;elseoutBuffer.append(aChar);&#125;prev.setResponseData(outBuffer.toString());","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"Centos配置ant","slug":"Centos配置ant","date":"2020-09-17T03:24:00.000Z","updated":"2020-09-17T09:54:00.000Z","comments":true,"path":"Centos配置ant.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E9%85%8D%E7%BD%AEant.html","excerpt":"Jenkins需要用到Ant，这里记录一下Ant配置的步骤","text":"Jenkins需要用到Ant，这里记录一下Ant配置的步骤 一、到官网下载Ant​ 方法1：找到下图所示的位置，选择.tar.gz 结尾的包，点击下载，然后通过xftp上传到服务器 ​ 方法2：通过wget命令下载：wget http://mirror.netinch.com/pub/apache//ant/binaries/apache-ant-1.9.15-bin.tar.gz 配置Ant执行tar -zxvf apache-ant-1.9.15-bin.tar.gz #解压命令 再执行 mv apache-ant-1.9.15 /usr/local/ant #重名了，并移动到指定位置 vim /etc/profile #编辑环境变量 输入一下内容 12export ANT_HOME=/usr/local/antexport PATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH source /etc/profile #更新配置文件 检查 ant -version #ant版本检查 出现以下文字，说明环境变量配置ok Apache Ant(TM) version 1.9.15 compiled on May 10 2020","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Jenkins+ant+jmeter","slug":"Jmeter+jenkins","date":"2020-09-17T03:24:00.000Z","updated":"2020-09-24T06:43:00.000Z","comments":true,"path":"Jmeter+jenkins.html","link":"","permalink":"https://www.lauyongyi.cn/Jmeter+jenkins.html","excerpt":"记录一下使用Jenkins+ant+jmeter的接口测试过程","text":"记录一下使用Jenkins+ant+jmeter的接口测试过程 创建文件目录这里可以使用Git进行管理，方便后续的持续更新，我的demo仓库 –主目录 ​ –result ​ –html（用来存放测试报告） ​ –jtl （存放jtl文件） ​ –script （存放脚本） ​ –build.xml （核心配置文件） 使用Jmeter编写脚本​ 先使用Jmeter编写脚本，然后保存到 script中 编写build.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;project name=&quot;jmeter_test&quot; default=&quot;all&quot; basedir=&quot;.&quot;&gt; &lt;tstamp&gt; &lt;format property=&quot;time&quot; pattern=&quot;MM-dd-hh-mm&quot; /&gt; &lt;/tstamp&gt; &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt; &lt;property name=&quot;jmeter.home&quot; value=&quot;/usr/local/jmeter/apache-jmeter-5.3/&quot; /&gt; &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; &lt;property name=&quot;jmeter.result.jtl.dir&quot; value=&quot;./result/jtl&quot; /&gt; &lt;!-- jmeter生成html格式的结果报告的路径--&gt; &lt;property name=&quot;jmeter.result.html.dir&quot; value=&quot;./result/html&quot; /&gt; &lt;!-- 生成的报告的前缀 --&gt; &lt;property name=&quot;ReportName&quot; value=&quot;TestReport&quot; /&gt; &lt;property name=&quot;jmeter.result.jtlName&quot; value=&quot;$&#123;jmeter.result.jtl.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.jtl&quot; /&gt; &lt;property name=&quot;jmeter.result.htmlName&quot; value=&quot;$&#123;jmeter.result.html.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.html&quot; /&gt; &lt;target name=&quot;all&quot;&gt; &lt;antcall target=&quot;test&quot; /&gt; &lt;antcall target=&quot;report&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;test&quot;&gt; &lt;taskdef name=&quot;jmeter&quot; classname=&quot;org.programmerplanet.ant.taskdefs.jmeter.JMeterTask&quot; /&gt; &lt;jmeter jmeterhome=&quot;$&#123;jmeter.home&#125;&quot; resultlog=&quot;$&#123;jmeter.result.jtlName&#125;&quot;&gt; &lt;!-- 声明要运行的脚本。&quot;*.jmx&quot;指包含此目录下的所有jmeter脚本 --&gt; &lt;testplans dir=&quot;./script/&quot; includes=&quot;*.jmx&quot; /&gt; &lt;property name=&quot;jmeter.save.saveservice.output_format&quot; value=&quot;xml&quot;/&gt; &lt;/jmeter&gt; &lt;/target&gt; &lt;path id=&quot;xslt.classpath&quot;&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/lib&quot; includes=&quot;xalan*.jar&quot;/&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/lib&quot; includes=&quot;serializer*.jar&quot;/&gt; &lt;/path&gt; &lt;target name=&quot;report&quot;&gt; &lt;tstamp&gt;&lt;format property=&quot;report.datestamp&quot; pattern=&quot;yyyy/MM/dd HH:mm&quot;/&gt;&lt;/tstamp&gt; &lt;xslt classpathref=&quot;xslt.classpath&quot; force=&quot;true&quot; in=&quot;$&#123;jmeter.result.jtlName&#125;&quot; out=&quot;$&#123;jmeter.result.htmlName&#125;&quot; style=&quot;$&#123;jmeter.home&#125;/extras/jmeter-results-detail-report_21.xsl&quot; &gt; &lt;param name=&quot;dateReport&quot; expression=&quot;$&#123;report.datestamp&#125;&quot;/&gt; &lt;/xslt&gt; &lt;!-- 因为上面生成报告的时候，不会将相关的图片也一起拷贝至目标目录，所以，需要手动拷贝 --&gt; &lt;copy todir=&quot;$&#123;jmeter.result.html.dir&#125;&quot;&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/extras&quot;&gt; &lt;include name=&quot;collapse.png&quot; /&gt; &lt;include name=&quot;expand.png&quot; /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;/target&gt;&lt;/project&gt; 运行前的配置​ 需要将 /usr/local/jmeter/apache-jmeter-5.3/extras/里的ant-jmeter-1.1.1.jar复制到ant的lib目录下 jenkins创建项目 在Jenkins上创建一个自由风格的项目 然后使用在配置里进行管理配置，选择使用git管理。 构建步骤选择“Invoke Ant”，见下图 构建后操作分别选择：Publish Performance test result report和Publish HTML reports 见下图： 注意事项！！1.Ant环境变量配置由于时依赖Ant的，所有Jenkins需要先配置好Ant，路径是 系统管理–全局工具配置 2.构建操作也要记得选择Ant。3.jmeter.log (Permission denied)构建时出现报错，如下图所示，关键词：jmeter.log (Permission denied) ​ 原因是：jmeter.log 没有权限，需要到jmeter的安装目录去修改权限 一般情况下的jmeter安装目录：/usr/local/jmeter/apache-jmeter-5.3/bin","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"Centos安装python3.8.x","slug":"Centos安装python3.8.x","date":"2020-09-15T09:02:00.000Z","updated":"2020-09-23T11:48:00.000Z","comments":true,"path":"Centos安装python3.8.x.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85python3.8.x.html","excerpt":"最近使用centos重装了服务器之后，运行之前的python脚本，都会出现一些怪异的报错，但本地PC没有任何问题，这里怀疑是Python版本导致的，所以找了一些文章，这里记录一下安装的过程.","text":"最近使用centos重装了服务器之后，运行之前的python脚本，都会出现一些怪异的报错，但本地PC没有任何问题，这里怀疑是Python版本导致的，所以找了一些文章，这里记录一下安装的过程. 下载python3.8.x wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz 安装编译所需要的开发包 yum -y install gcc zlib* libffi-devel 解压python的tgz文件 tar -zxvf Python-3.8.5.tgz 进入python文件：cd Python-3.8.5/ 配置python3.8.5：./configure --prefix=/usr/local/bin/python3 编译python：make 安装python：make install 备份python3软链接：mv /usr/bin/python3 /usr/bin/python3.bak 备份pip3软链接： mv /usr/bin/pip3 /usr/bin/pip3.bak 删除软链接：rm -rf /usr/bin/python3 添加python软链接：ln -s /usr/local/bin/python3/bin/python3 /usr/bin/python3 添加pip3软链接：ln -sf /usr/local/bin/python3/bin/pip3 /usr/bin/pip3 查看升级后的版本：python3 -V 安装完成后，python3可用了，但感觉怪怪的，后续再找其他的方法试试","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux安装jmeter","slug":"Linux安装jmeter","date":"2020-09-15T03:24:00.000Z","updated":"2020-09-15T03:24:00.000Z","comments":true,"path":"Linux安装jmeter.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E5%AE%89%E8%A3%85jmeter.html","excerpt":"记录Linux安装jmeter的步骤和方法。","text":"记录Linux安装jmeter的步骤和方法。 大前提：都需要安装好jdk，可以参考Linux下jenkins部署遇到的问题记录 Centos新建jmeter目录：mkdir /usr/local/jmeter 进入jmeter目录：cd /usr/local/jmeter 下载最新版安装包： wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.3.tgz 解压：tar -zxvf apache-jmeter-5.3.tgz 配置系统环境变量：vim /etc/profile 在最后添加： 123export JMETER_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jmeter&#x2F;apache-jmeter-5.3export CLASSPATH&#x3D;$JMETER_HOME&#x2F;lib&#x2F;ext&#x2F;ApacheJMeter_core.jar:$JMETER_HOME&#x2F;lib&#x2F;jorphan.jar:$JMETER_HOME&#x2F;lib&#x2F;logkit-2.0.jar:$CLASSPATHexport PATH&#x3D;$JMETER_HOME&#x2F;bin:$PATH:$HOME&#x2F;bin 使配置生效：source /etc/profile 查看JMeter 版本：jmeter -v","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"UI自动化常见两种框架与区别","slug":"UI自动化常见框架与区别","date":"2020-09-03T12:16:00.000Z","updated":"2020-09-03T12:28:38.000Z","comments":true,"path":"UI自动化常见框架与区别.html","link":"","permalink":"https://www.lauyongyi.cn/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%8C%BA%E5%88%AB.html","excerpt":"关于Unittest与pytest的特点与区别","text":"关于Unittest与pytest的特点与区别 一、Unittest ​ Unittest是Python标准库中自带的单元测试框架，Unittest有时候也被称为PyUnit，就像JUnit是Java语言的标准单元测试框架一样，Unittest则是Python语言的标准单元测试框架。Unittest支持自动化测试，测试用例的初始化、关闭和测试用例的聚合等功能，它有一个很重要的特性：它是通过类(class)的方式，将测试用例组织在一起。 二、Pytest Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。pytest的特性有： 支持用简单的assert语句实现丰富的断言，无需复杂的self.assert* 函数自动识别测试模块和测试函数 模块化夹具用以管理各类测试资源对 unittest 完全兼容，对 nose基本兼容 支持Python3和PyPy3丰富的插件生态，已有300多个各式各样的插件，社区繁荣 Unittest pytest 用例编写规则 1、测试文件必须先import unittest2)测试类必须继承unittest.TestCase3)测试方法必须以“test_”开头4)测试类必须要有unittest.main()方法 1)测试文件名必须以“test_”开头或者”_test”结尾（如：test_ab.py）2)测试方法必须以“test_”开头3)测试类命名以”Test”开头 用例分类执行 默认执行全部用例，也可以通过加载testsuit，执行部分用例 可以通过@pytest.mark来标记类和方法，pytest.main加入参数(“-m”)可以只运行标记的类和方法 用例前置和后置 提供了setUp/tearDown，只能针对所有用例 pytest中的fixture显然更加灵活。可以任意自定义方法函数，只要加上@pytest.fixture()这个装饰器，那么被装饰的方法就可以被使用 参数化 需依赖ddt库 使用@pytest.mark.parametrize装饰器 断言 很多断言格式(assertEqual、assertIn、assertTrue、assertFalse) 只有assert一个表达式，用起来比较方便 报告 使用HTMLTestRunner库 有pytest-HTML、allure插件 失败重跑 无此功能 pytest支持用例执行失败重跑，pytest-rerunfailures插件","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"},{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"apache bench参数解释","slug":"apache bench参数解释","date":"2020-08-31T06:19:00.000Z","updated":"2020-09-01T07:46:12.000Z","comments":true,"path":"apache bench参数解释.html","link":"","permalink":"https://www.lauyongyi.cn/apache%20bench%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A.html","excerpt":"记录一下了解到的apache bench相关的知识","text":"记录一下了解到的apache bench相关的知识 设备条件有限，只能先用Windows来做试验，等改天把服务器腾出来就来倒腾 Windows平台下，使用Xampp安装 Apache等。然后进入安装目录 xampp\\apache\\bin&gt;，执行命令.\\ab.exe，出现下面的内容 1234567891011121314151617181920212223242526272829303132333435363738C:\\xampp\\apache\\bin\\ab.exe: wrong number of argumentsUsage: C:\\xampp\\apache\\bin\\ab.exe [options] [http:&#x2F;&#x2F;]hostname[:port]&#x2F;pathOptions are: Options are: -n requests 要执行请求总数，默认会执行一个请求 -c concurrency 一次执行多个请求的数量，也就是并发数 -t timelimit 用于基准测试的最大秒数，使用它在固定的总时间内对服务器进行基准测试。默认情况下，没有时间限制。 -s timeout 超时之前等待的最大秒数。 默认值是30秒。 -b windowsize TCP发送&#x2F;接收缓冲区的大小，以字节为单位。 -B address 进行传出连接时要绑定的地址。 -p postfile 包含数据到POST的文件。 还请记住设置-T。 -u putfile 包含PUT数据的文件。 还请记住设置-T 。 -T content-type Content-type用于POST &#x2F; PUT数据的内容类型内容类型标题，例如：&#39;application&#x2F;x-www-form-urlencoded&#39; 默认是&#39; &#39;text&#x2F;plain&#39; -v verbosity verbosity 要打印多少个疑难解答信息，设置详细级别 - 4和以上打印标题信息，3和以上打印响应代码（404,200等），2和以上打印警告和信息。 -w 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。 -i 执行HEAD请求，而不是GET。 -x attributes 用作&lt;table&gt;的属性的字符串。 属性被插入&lt;table here&gt;。 -y attributes 用作&lt;tr&gt;的属性的字符串。 -z attributes 用作&lt;td&gt;的属性的字符串。 -C attribute 将cookie添加到请求。 参数通常采用名称&#x3D;值对的形式。 这个字段是可重复的。 -H attribute 例如 ‘Accept-Encoding: gzip’ 插入所有普通标题行之后 -A attribute 添加基本的WWW认证，该属性是一个冒号分隔的用户名和密码，auth-username:password -P attribute 添加基本代理验证，属性是一个冒号分隔的用户名和密码，proxy-auth-username:password -X proxy:port 使用代理服务器和端口号。 -V 打印版本号并退出。 -k 使用HTTP KeepAlive功能。 -d 不要显示百分点服务表。 -S 不要显示信心估计和警告。 -q 做超过150个请求时不要显示进度。 -g filename 将收集的数据输出到gnuplot格式文件。 -e filename 输出提供百分比的CSV文件。 -r 不要退出套接字接收错误。 -h 显示使用情况信息（此消息）。 -Z ciphersuite 密码套件指定SSL &#x2F; TLS密码套件（请参阅openssl密码） -f protocol 指定SSL &#x2F; TLS协议 (SSL3, TLS1, TLS1.1, TLS1.2 or ALL) 进行一次操作之后，发现了一些报告名词 ab -c 100 -n 100 -t 200 https://www.baidu.com/ 1234567891011121314151617181920212223242526272829303132333435Server Software: ##apache版本Server Hostname: ##请求的机子Server Port: ##请求端口Document Path: &#x2F;a.htmlDocument Length: ##页面长度Concurrency Level: ##并发数Time taken for tests: ##共使用了多少时间Complete requests: ##请求数Failed requests: ##失败请求Write errors: 0 Total transferred: ##总共传输字节数，包含http的头信息等HTML transferred: ##html字节数，实际的页面传递字节数Requests per second: ##每秒多少请求，这个是非常重要的参数数值，服务器的吞吐量Time per request: ##用户平均请求等待时间Time per request: ##服务器平均处理时间，也就是服务器吞吐量的倒数Transfer rate: ##每秒获取的数据长度Connection Times (ms) min mean[+&#x2F;-sd] median maxConnect: 25 50 19.3 51 81Processing: 7 20 24.7 9 73Waiting: 7 13 16.1 8 59Total: 33 70 25.3 73 108Percentage of the requests served within a certain time (ms) 50% 73 ## 50%的请求在73ms内返回 66% 86 ## 60%的请求在86ms内返回 75% 90 80% 98 90% 108 95% 108 98% 108 99% 108100% 108 (longest request)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"apache bench","slug":"apache-bench","permalink":"https://www.lauyongyi.cn/tags/apache-bench/"}]},{"title":"一个搜索输入框测试实例","slug":"一个搜索输入框测试实例","date":"2020-08-14T06:16:00.000Z","updated":"2020-08-14T06:28:38.000Z","comments":true,"path":"一个搜索输入框测试实例.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E8%BE%93%E5%85%A5%E6%A1%86%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B.html","excerpt":"记录一个关于搜索框相关的测试实例","text":"记录一个关于搜索框相关的测试实例 1）验证可获得结果的查询以及翻页：使用普通关键字，查看搜索结果是否符合预期，查询结果是否包含该关键字。 ​ 注意：找出能在电脑版上查询出结果的3个关键字，而且查询结果超过一页显示，这样能够同时测试翻页后的结果是否准确，例如“a”，“vic”等。 2）测试不同页面的搜索 3）检查系统定制的“404 Not Found”页面是否能正确显示，需要使用一个无法查到结果的关键字。这个点是查看对异常处理的流程是否正确。 例如：一个能显示出404的关键字，“error_found_aaa_bbb”。 4）测试特定文本查询 例如：淘宝、京东的”百亿补贴“。 5）特殊符号处理：一般文本输入框对特殊字符处理得不够好，如何区分特殊符号？区分特殊符号的基本原则如下。 ​ ▼特殊字符：在程序代码中被作为特殊符号、特殊用法去使用，例如“! @#$%”； 例如：测试人员可以快速使用“! @#$%^&amp;*（）_+{}|:”&lt;&gt;? ”这样的文本，输入后点击查询，看是否会出现异常。 ​ ▼界定文本范围：在数据库中被用来作为通配符，以及单引号和双引号等。 6）测试关键字联合查询：类似在Google里使用空格分开多个关键字进行联合查询一样 测试过程中，用多个关键字做联合查询，发现系统除了支持用空格、分号做分隔符，还自动把一些特殊符号作为分隔符（例如“!@#$%^&amp;*（）_+{}:”&lt;&gt;? ”等）。需要查看使用这些特殊符号做分隔符后，查询结果是否正常。 7）测试多语言支持：该网站是英文版，但不排除有人使用其他语种文字进行查询，这里需要测试输入其他语种文字的处理情况，不应该抛出500 ERROR页面。 除英文以外的字符，使用其他字符集的文本，例如“ﻡﻼﺴﻟﺍ ﻢﻜﻴﻠﻋ”和“中文”。 8）验证过长字符串：验证输入过长的字符串是否处理正确。 ​ 注意：这里可以 通过修改html代码限制实现更多的输入 9）多个输入域关联查询：除了关键字输入框外，该网页还有其他输入域，需要把它们都设置值后进行关联查询，看查询结果是否准确。10）在不同手机浏览器上查看界面显示：这主要在项目需要支持的各种真实手机上测试，可以有效避免模拟器漏掉Bug，横竖屏都进行测试，查看是否出现界面变形、难以点击与输入等问题，以及输入框内的背景文字等是否能正常显示等。 11）字段值回填功能：用户输入数据后，如果重新修改过滤条件，系统就会把用户最初填写过的数据回填到对应的输入框中，以便用户修改。 注意：这里主要注意英文大小写回填是否正常。 12）测试联合查询生成URL的情况：在已上线运行的电脑版网站中搜索关键字，并查询，页面会跳转到结果页面，URL也会做对应改变。开发已把电脑版网站上对应的URL拷贝到手机网站上打开，需要查询结果相同。测试过程就不能只简单针对一个关键字，而是需要考虑这个关键字输入框以及页面上其他输入域联合查询后生成的URL的情况。 13）安全问题：考虑会不会出现XSS或者Sql Injection的安全问题。","categories":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/categories/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}]},{"title":"安卓命令行打包","slug":"命令行打包apk","date":"2020-07-24T08:28:00.000Z","updated":"2020-07-24T09:03:55.000Z","comments":true,"path":"命令行打包apk.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%8C%85apk.html","excerpt":"为了配合Jenkins做持续集成，研究了安卓的打包方式。这里做个记录，方便后续查看。","text":"为了配合Jenkins做持续集成，研究了安卓的打包方式。这里做个记录，方便后续查看。 Android Apk 打包方式有两种 一种是使用Android Studio自带工具 build =&gt; debug/release. （签名包需要生成签名）另一种一中方式 是通过命令行使用gradlew命令打包。命令行在生成签名包同样需要在gradlew中 配置签名信息。 打包命令的配置，参考链接：简书cuzzyapp下gradle中配置手动配置方法File-&gt; Project Structure-&gt; module -&gt; app -&gt; Signing Configs（填写签名文件信息）-&gt;Default Config （选中debug/release）选择需要的Signing Config-&gt;Apply 同步后app下gradle文件会出现下方配置 1234567891011121314signingConfigs &#123; release &#123; storeFile file(&#x27;..\\\\testdemo.jks&#x27;) storePassword &#x27;aa123456&#x27; keyPassword &#x27;aa123456&#x27; keyAlias &#x27;key0&#x27; &#125; debug &#123; storeFile file(&#x27;..\\\\testdemo.jks&#x27;) storePassword &#x27;aa123456&#x27; keyPassword &#x27;aa123456&#x27; keyAlias &#x27;key0&#x27; &#125; &#125; terminal命令行中使用 gradlew assembleRelease 运行 即可生成签名包可简写为 gradlew aR 同理如果测试需要debug包则为gradlew aD apk自定义命名的配置为了回归测试，需要将包命名根据日期进行命名，找到了一下方法，参考链接：简书MonkeyLei 123456789101112android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; def date = new Date().format(&quot;yyyyMMddHHmm&quot;, TimeZone.getTimeZone(&quot;GMT+08&quot;)) if (variant.buildType.name.equals(&#x27;debug&#x27;)) &#123; ///&quot;commonui_$&#123;date&#125;_$&#123;versionName&#125;.apk&quot; outputFileName = &quot;commonpop.apk&quot; &#125; if (variant.buildType.name.equals(&#x27;release&#x27;)) &#123; outputFileName = &quot;commonpop_$&#123;date&#125;.apk&quot; &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"Centos配置SDK,gradle","slug":"centos配置SDK","date":"2020-07-24T02:28:00.000Z","updated":"2020-07-24T02:28:00.000Z","comments":true,"path":"centos配置SDK.html","link":"","permalink":"https://www.lauyongyi.cn/centos%E9%85%8D%E7%BD%AESDK.html","excerpt":"为了配合Jenkins做持续集成，找了一些关于Centos Android打包的环境变量配置，这里记录一下，方便后期的继续使用。","text":"为了配合Jenkins做持续集成，找了一些关于Centos Android打包的环境变量配置，这里记录一下，方便后期的继续使用。 Android SDK安装123456789101112131415161718192021# 下载sdk工具包$ wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip# 创建sdk工具文件夹和解压工具包$ mkdir -p /opt/android/sdk$ unzip sdk-tools-linux-3859397.zip -d /opt/android/sdk# 使用sdkmanager工具配置构建工具和平台版本$ cd /opt/android/sdk/tools/bin/$ ./sdkmanager --list #可以查看有哪些版本，自行选择对应的版本$ ./sdkmanager &quot;build-tools;29.0.3&quot; &quot;platforms;android-29&quot; &quot;platform-tools&quot; # 增加系统环境变量$ vim /etc/profileexport ANDROID_HOME=/opt/android/sdkPATH=$PATH:$ANDROID_HOME:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/emulator:$ANDROID_HOME/tools/bin$ adb versionAndroid Debug Bridge version 1.0.41Version 30.0.4-6686687Installed as /opt/android/sdk/platform-tools/adb 安装gradle12345678910111213141516171819$ wget https://downloads.gradle-dn.com/distributions/gradle-6.3-all.zip$ mkdir /opt/gradle$ unzip gradle-6.3-all.zip -d /opt/gradle/$ vim /etc/profileexport PATH=$PATH:/opt/gradle/gradle-6.3/bin$ source /etc/profile$ gradle -v------------------------------------------------------------Gradle 6.3------------------------------------------------------------Build time: 2020-03-24 19:52:07 UTCRevision: bacd40b727b0130eeac8855ae3f9fd9a0b207c60Kotlin: 1.3.70Groovy: 2.5.10Ant: Apache Ant(TM) version 1.10.7 compiled on September 1 2019JVM: 1.8.0_261 (Oracle Corporation 25.261-b12)OS: Linux 4.18.0-80.el8.x86_64 amd64","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"pytest脚本遇到 missing from arguments","slug":"pytest脚本missing from arguments","date":"2020-07-03T10:47:00.000Z","updated":"2020-07-03T10:47:30.000Z","comments":true,"path":"pytest脚本missing from arguments.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E8%84%9A%E6%9C%ACmissing%20from%20arguments.html","excerpt":"写自动化脚本的时候遇到了报错：“TypeError: required field “posonlyargs” missing from arguments”","text":"写自动化脚本的时候遇到了报错：“TypeError: required field “posonlyargs” missing from arguments” 原因：版本兼容问题，或者说allure插件版本的问题。 解决方法：建议降低python版本号（改为python 3.6）。如果不想卸载python，可以升allure：如果安装的是allure adaptor,此版本最新是1.7,不能继续往上升级，所以先把电脑里的allure卸载了，命令是：pip uninstall pytest-allure-adaptor然后再升级，直接安装allure-pytest，命令是：pip install allure-pytest","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"pytest前置和后置","slug":"pytest前置和后置","date":"2020-06-25T07:30:00.000Z","updated":"2020-09-16T10:24:21.000Z","comments":true,"path":"pytest前置和后置.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE.html","excerpt":"概 念 前置是指在用例执行前需要执行的代码，如连接数据库、打开浏览器等，后置是指用例执行完毕后需要执行的代码，比如关闭数据库连接、关闭浏览器等。","text":"概 念 前置是指在用例执行前需要执行的代码，如连接数据库、打开浏览器等，后置是指用例执行完毕后需要执行的代码，比如关闭数据库连接、关闭浏览器等。 前置和后置都有很多种类，他们根据种类的不同，执行的顺序也不同，我们可以根据他们执行顺序的规则来进行设定，比如，先连接数据库，再打开浏览器，先关闭浏览器，再关闭数据库连接等。 当然，我们不使用前置和后置，通过把需要先执行的代码写到前面，需要后执行的代码写到后面的方式也可实现效果，但前置和后置为我们提供了一种更方便的解决方案，实际开发中需不需要使用看业务及个人习惯。 种类简介pytest的前置和后置包括如下几种： 模块级（setup_module/teardown_module）开始于模块始末，作用于全局（总用各执行一次） 函数级（setup_function/teardown_function）仅对函数用例生效。（即不在类中，每个函数执行一次） 类级（setup_class/teardown_class）只在类中前后运行一次。（在类中） 方法级（setup_method/teardown_method）开始于方法始末（在类中，每个方法执行一次） 类里面的（setup/teardown）运行在调用方法的前后（每个方法执行一次） Demo代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env python# -*- coding:utf-8 -*-def setup_module(): print(&quot;\\n setup_module,只执行一次，当有多个测试类的时候使用&quot;)def teardown_module(): print(&quot;\\n teardown_module,只执行一次，当有多个测试类的时候使用&quot;)class TestPytest1(object): @classmethod def setup_class(cls): print(&quot;\\n setup_class1,只执行一次&quot;) @classmethod def teardown_class(cls): print(&quot;\\n teardown_class1, 只执行一次&quot;) def setup_mtehod(self): print(&quot;\\nsteup_method1，每个测试方法都执行一次&quot;) def teardown_method(self): print(&quot;teardown_method1，每个测试方法都执行一次&quot;) def test_three(self): print(&quot;test_three,测试用例&quot;) def test_four(self): print(&quot;test_four,测试用例&quot;)class TestPytest2(object): @classmethod def setup_class(cls): print(&quot;\\nteardown_class2,只执行一次&quot;) @classmethod def teardown_class(cls): print(&quot;\\nteardown_class2，只执行一次&quot;) def setup_method(self): print(&quot;\\nsetup_method2，每个测试方法都执行一次&quot;) def teardown_method(self): print(&quot;teardown_method2，每个测试方法都执行一次&quot;) def test_two(self): print(&quot;test_two，测试用例&quot;) def test_one(self): print(&quot;test_one，测试用例&quot;) 运行结果如下： setup_module是在所有用例执行的时候最先运行的，teardown_module是所有用例结束时执行的 setup_class是在其他用例执行前运行的，teardown_class是在其他用例执行完成后运行的。 setup_method是在每一条用例执行前，且在setup执行前运行的，teardown_method是在每一条用例执行完成后，且在teardown执行完成后运行的。 setup是在每条用例执行前运行，teardown是在每条用例执行完成后运行。 所以，它们的调用顺序是 setup_module &gt; setup_class &gt; setup_method &gt; setup &gt; teardown &gt; teardown_method &gt; teardown_class &gt; teardown_module","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"Pytest用例失败重跑","slug":"pytest失败重跑","date":"2020-06-25T06:19:00.000Z","updated":"2020-09-25T09:40:12.000Z","comments":true,"path":"pytest失败重跑.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91.html","excerpt":"用例重跑有两种方法，利用pytest-rerunfailures包，和直接使用@pytest.mark.flaky(reruns=重跑次数,reruns_delay=间隔时间)装饰器。","text":"用例重跑有两种方法，利用pytest-rerunfailures包，和直接使用@pytest.mark.flaky(reruns=重跑次数,reruns_delay=间隔时间)装饰器。 pytest-rerunfailures包pip install pytest-rerunfailures #安装pytest-rerunfailures 安装好后，只要执行命令 pytest test_study.py –reruns n 即可实现失败重跑。 其中n代表重跑次数，如，输入 pytest test_add.py -–reruns 3 代表用例失败后尝试重新执行3次，注意，是用例执行失败后尝试执行3次，加上第一次失败的那次，总共执行4次。 执行结果： @pytest.mark.flaky(reruns=n,reruns_delay=t)装饰器装饰器 @pytest.mark.flaky(reruns=n,reruns_delay=t) ，其中n是指重跑次数，t是指间隔时间。 直接使用结果如下图： 把参数设为变量结果如下图：","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"Pytest基础学习记录","slug":"Pytest基础学习记录","date":"2020-06-25T03:19:00.000Z","updated":"2020-09-16T09:40:12.000Z","comments":true,"path":"Pytest基础学习记录.html","link":"","permalink":"https://www.lauyongyi.cn/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html","excerpt":"Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。","text":"Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。 在了解了Pytest的一些基础之后，照着网上的教程，写了一个简单的Demo，用来验证和记录一些基础。 12345678910111213141516171819#! /usr/bin/env python# -*- coding:utf-8 -*-def add(x,y): return x + ydef test_add(): assert add(1, 10) == 11 assert add(1, 1) == 2 assert add(1, 99) == 100class TestClass: def test_two(self): x = &quot;hello&quot; assert hasattr(x, &quot;check&quot;) @pytest.mark.add def test_one(self): x = &quot;this&quot; assert &quot;h&quot; in x 关于Pytest的运行参数记录：（可以使用pytest –help 查看帮助文档） 无参数模式：​ 读取路径下所有符合规则的文件，类，方法，函数全部执行。使用方法如下pytest 或 py.test。 运行结果如下： 12345678910111213141516171819202122&gt;py.test======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py ..F [100%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x00000280287AD070&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:19: AssertionError=================================================================== 1 failed, 2 passed in 0.10s ==================================================================== 结果比较简略，没有太多的运行细节。 -v 参数：​ 打印详细运行日志信息，一般在调试的时候加上这个参数，终端会打印出每条用例的详细日志信息，方便定位问题。 -s 参数: 带控制台输出效果，代码中带有“print”语句时，才有效果，常用于调试。 pytest -s 123456789101112131415161718192021222324252627&gt;pytest -v test_add.py======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#x27;Python&#x27;: &#x27;3.8.4rc1&#x27;, &#x27;Platform&#x27;: &#x27;Windows-10-10.0.18362-SP0&#x27;, &#x27;Packages&#x27;: &#123;&#x27;pytest&#x27;: &#x27;5.2.1&#x27;, &#x27;py&#x27;: &#x27;1.9.0&#x27;, &#x27;pluggy&#x27;: &#x27;0.13.1&#x27;&#125;, &#x27;Plugins&#x27;: &#123;&#x27;html&#x27;: &#x27;2.1.0&#x27;, &#x27;metadata&#x27;: &#x27;1.10.0&#x27;, &#x27;rerunfailures&#x27;: &#x27;7.0&#x27;&#125;, &#x27;JAVA_HOME&#x27;: &#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#x27;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_one PASSED [ 66%]test_add.py::TestClass::test_two FAILED [100%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x0000017441950610&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:19: AssertionError=================================================================== 1 failed, 2 passed in 0.10s ==================================================================== 相较于没有参数的运行方式，-v 多了执行结果。 -k 参数:​ 执行指定关键字的用例。用法如下： ​ pytest -k ‘类名’ ​ pytest -k ‘方法名’ ​ pytest -k ‘类名 and not 方法名’ #运行类里所有方法，不包含某个方法 -x 参数:​ 遇到用力失败立即停止运行。 12345678910111213141516171819202122232425&gt;pytest -x -v======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#x27;Python&#x27;: &#x27;3.8.4rc1&#x27;, &#x27;Platform&#x27;: &#x27;Windows-10-10.0.18362-SP0&#x27;, &#x27;Packages&#x27;: &#123;&#x27;pytest&#x27;: &#x27;5.2.1&#x27;, &#x27;py&#x27;: &#x27;1.9.0&#x27;, &#x27;pluggy&#x27;: &#x27;0.13.1&#x27;&#125;, &#x27;Plugins&#x27;: &#123;&#x27;html&#x27;: &#x27;2.1.0&#x27;, &#x27;metadata&#x27;: &#x27;1.10.0&#x27;, &#x27;rerunfailures&#x27;: &#x27;7.0&#x27;&#125;, &#x27;JAVA_HOME&#x27;: &#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#x27;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x00000204DCDDEBE0&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:15: AssertionError=================================================================== 1 failed, 1 passed in 0.11s ==================================================================== –maxfail参数:​ 用例失败个数达到阀值停止运行，具体用法如下：pytest –maxfail=[num] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;pytest -v --maxfail&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#39;Python&#39;: &#39;3.8.4rc1&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.18362-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;5.2.1&#39;, &#39;py&#39;: &#39;1.9.0&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;html&#39;: &#39;2.1.0&#39;, &#39;metadata&#39;: &#39;1.10.0&#39;, &#39;rerunfailures&#39;: &#39;7.0&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#39;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]test_add.py::TestClass::test_one PASSED [100%]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;________________________________________________________________________ TestClass.test_two ________________________________________________________________________self &#x3D; &lt;test_add.TestClass object at 0x000001DD58CFFBB0&gt; def test_two(self): x &#x3D; &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False &#x3D; hasattr(&#39;hello&#39;, &#39;check&#39;)test_add.py:15: AssertionError&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed, 2 passed in 0.11s &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;pytest -v --maxfail&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#39;Python&#39;: &#39;3.8.4rc1&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.18362-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;5.2.1&#39;, &#39;py&#39;: &#39;1.9.0&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;html&#39;: &#39;2.1.0&#39;, &#39;metadata&#39;: &#39;1.10.0&#39;, &#39;rerunfailures&#39;: &#39;7.0&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#39;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;________________________________________________________________________ TestClass.test_two ________________________________________________________________________self &#x3D; &lt;test_add.TestClass object at 0x000001D5B04F3B80&gt; def test_two(self): x &#x3D; &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False &#x3D; hasattr(&#39;hello&#39;, &#39;check&#39;)test_add.py:15: AssertionError&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed, 1 passed in 0.10s &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; -m参数:​ 将用例进行分类，使用 @pytest.mark.XXX进行标记。运行是执行：pytest -m XXX 1234567D:\\Git\\pytestDemo&gt;pytest -m add======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items / 2 deselected / 1 selected test_add.py . -n 参数：​ pytest-xdist 是 pytest 分布式执行插件，可以多个CPU或者主机执行，插件预先用户将测试并发执行（进程级并发），插件是动态决定测试用例执行顺序的，为了保证各个测试能在各个独立线程里正确的执行，应该保证测试用例的独立性。多个CPU 并行执行用例，需要在 pytest 后面添加 -n 参数，如果参数为 auto ，会自动检查系统的PCU数目，如果参数为数字，则指定运行测试的处理器进程数。使用方法： ​ pytest -n auto ​ pytest -n [num]","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"python简易爬虫获取壁纸","slug":"python简易爬虫获取壁纸","date":"2020-06-20T06:16:00.000Z","updated":"2020-06-20T06:28:38.000Z","comments":true,"path":"python简易爬虫获取壁纸.html","link":"","permalink":"https://www.lauyongyi.cn/python%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E5%A3%81%E7%BA%B8.html","excerpt":"记录一下只用re，request，os编写的简易爬虫","text":"记录一下只用re，request，os编写的简易爬虫 需要爬取的页面：https://wallhaven.cc/latest 页面分析，获取壁纸详情页的链接使用浏览器自带的控制台（快捷键F12）对页面元素进行分析,找到壁纸详情页的链接，如图中红框。编写相关的正则表达式， 123456# 第一次正则匹配，获取图片部分的全部html代码（记得转成str类型）detailed_context = str(re.findall(&#x27;&lt;section class=&quot;thumb-listing-page&quot;&gt;(.*?)&lt;/section&gt;&#x27;, detailed_html, re.S))# 第二次匹配，获取图片url的具体html代码detailed_html = str(re.findall(&#x27;&lt;li&gt;(.*?)&lt;/li&gt;&#x27;, detailed_context, re.S))# 第三次匹配，提示图片详情的urldetailed_list = re.findall(&#x27;&lt;a class=&quot;preview&quot; href=&quot;(.*?)&quot; target=&quot;_blank&quot; &gt;&lt;/a&gt;&#x27;, detailed_html, re.S) 因为只用了“re”用来提取URL，所以为了方便展示用了3次正则匹配来提示壁纸详情的URL。PS：编写的正则表达式可以用在线正则表达式测试进行验证 获取壁纸的下载地址用https://wallhaven.cc/w/xlmgjo举例。使用控制台进行元素定位之后，可以看到有一个后缀位.jpg的链接（也有可能是.png),这个就是我们要的链接。 1img_url = re.search(&#x27;&lt;img id=&quot;wallpaper&quot; src=&quot;(.*?)&quot;&#x27;, html, re.S).group(1) 完整代码如下：1234567891011121314151617181920212223242526import requests, os, reheaders = &#123; &quot;Host&quot;: &quot;wallhaven.cc&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot; &#125;start_url = &#x27;https://wallhaven.cc/latest&#x27;detailed_html = requests.get(start_url,headers=headers).text# 第一次正则匹配，获取图片部分的全部html代码（记得转成str类型）detailed_context = str(re.findall(&#x27;&lt;section class=&quot;thumb-listing-page&quot;&gt;(.*?)&lt;/section&gt;&#x27;, detailed_html, re.S))# 第二次匹配，获取图片url的具体html代码detailed_html = str(re.findall(&#x27;&lt;li&gt;(.*?)&lt;/li&gt;&#x27;, detailed_context, re.S))# 第三次匹配，提示图片详情的urldetailed_list = re.findall(&#x27;&lt;a class=&quot;preview&quot; href=&quot;(.*?)&quot; target=&quot;_blank&quot; &gt;&lt;/a&gt;&#x27;, detailed_html, re.S)for i in detailed_list: html = requests.get(i, headers=headers).text img_url = re.search(&#x27;&lt;img id=&quot;wallpaper&quot; src=&quot;(.*?)&quot;&#x27;, html, re.S).group(1) img_name = img_url.split(&#x27;/&#x27;)[-1] os.makedirs(&#x27;F:\\img&#x27;, exist_ok=True) r = requests.get(img_url, stream=True) with open(&#x27;F:\\img\\%s&#x27; % img_name, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=3072): f.write(chunk) print(&#x27;Saved %s&#x27; % img_name)","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"Robot Framework No keyword with name 'Get Json Value' found.","slug":"Robot Framework不同Py版本出现的问题","date":"2020-06-20T03:49:00.000Z","updated":"2020-06-20T03:53:19.000Z","comments":true,"path":"Robot Framework不同Py版本出现的问题.html","link":"","permalink":"https://www.lauyongyi.cn/Robot%20Framework%E4%B8%8D%E5%90%8CPy%E7%89%88%E6%9C%AC%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"解决办法： Get Json Value关键字只支持python2.x RequestsLibrary中的to json关键字 Get Json Value改为to json","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"Jenkins配置项目出现的错误","slug":"Jenkins配置项目出现的错误","date":"2020-06-17T03:10:00.000Z","updated":"2020-09-24T08:39:00.000Z","comments":true,"path":"Jenkins配置项目出现的错误.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF.html","excerpt":"记录Jenkins使用过程中遇到的一些问题和解决方法。","text":"记录Jenkins使用过程中遇到的一些问题和解决方法。 服务器没有安装GitJenkins新建项目中源码管理使用Git时遇到如下问题： Failed to connect to repository : Error performing command: git ls-remote -h …. 问题原因：没有安装Git 解决方法：安装Git，执行命令yum install git，出现选择提示的时候，输入Y即可。 没有安装谷歌浏览器和驱动执行selenium的时候，还没开始就结束了，查看运行日志得出，服务器没有安装浏览器以及驱动。 先安装最新版的Chrome：yum install https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm 或者： yum install google-chrome-stable_current_x86_64.rpm 安装成功后，检查版本号，根据版本号，下载驱动： 12&gt;google-chrome -version Google Chrome 85.0.4183.102 下载chromedriver驱动：历史版本 http://npm.taobao.org/mirrors/chromedriver 找到对应的驱动版本 使用wget下载Zip包 wget https://cdn.npm.taobao.org/dist/chromedriver/85.0.4183.87/chromedriver_linux64.zip 解压 ：unzip chromedriver_linux64.zip 解压后把chromedriver移动到/usr/bin/目录下 mv chromedriver /usr/bin/ 查看chromedriver版本号 12&gt;chromedriver --version ChromeDriver 75.0.3770.90 (a6dcaf7e3ec6f70a194cc25e8149475c6590e025-refs&#x2F;branch-heads&#x2F;3770@&#123;#1003&#125;) 配置全局Java变量运行Jmeter脚本的时候，提示：Neither the JAVA_HOME nor the JRE_HOME environment variable is defined 进入到全局变量查看，发现少配置了JAVA_HOME，然后按照下图进行配置 路径为java的安装路径","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"Jenkins集成selenium脚本的流程","slug":"Jenkins集成selenium脚本的流程","date":"2020-06-17T02:24:00.000Z","updated":"2020-06-17T06:57:56.000Z","comments":true,"path":"Jenkins集成selenium脚本的流程.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E9%9B%86%E6%88%90selenium%E8%84%9A%E6%9C%AC%E7%9A%84%E6%B5%81%E7%A8%8B.html","excerpt":"记录一下这两天使用Jenkins集成selenium的操作流程","text":"记录一下这两天使用Jenkins集成selenium的操作流程 Jenkins安装完默认插件后，还需要安装另外几个插件Startup Trigger，Groovy，HTML Publisher。 创建项目在Jenkins控制台，选择创建一个Freestyle project（自由格式的项目） 确定之后，进入项目配置页面。 添加Git在源码管理模块，选择Git构建触发器里选择Poll SCM（轮询），然后设置时间间隔例如：H/2 * * * *具体的其他时间间隔，可以点击旁边的问号图标，会有详细的例子说明 构建操作（Bulid）点击增加构建步骤（Add bulid step）选择对应的平台执行方法Windows选择Execute Windows batch commandLinux选择Execute shell 然后写上对应的执行语句。（Linux可能需要加上# !/bin/bash避免出现一个奇怪的问题） 构建后的操作点击增加构建步骤（Add bulid step），选择Execute system Groovy script使用默认的Groovy command，写入脚本语句System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;,&quot; &quot;) 这个操作是为了防止报告生成后，样式出错的措施。然后点击 Add post-build action(构建后操作)，选择添加Publish HTML reports HTML directory to archive 填写报告存放的路径，大部分情况下，都是test_report Index page[s] 添加默认的报告位置，大部分情况下是 **/report.html Index page title[s] (Optional) 报告的标题，可以随便填写 Report title 同上点击 Add post-build action(构建后操作)添加Publish JUnit test result report(构建统计用的插件）测试报告（XML）填写pytest生成的xml文件路径即可test_report/**/*.xml其他的保持默认选项即可，然后保存应用就行了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"Centos下Jenkins运行selenium遇到的问题","slug":"Centos下Jenkins运行selenium遇到的问题","date":"2020-06-16T14:00:00.000Z","updated":"2020-06-17T06:56:59.000Z","comments":true,"path":"Centos下Jenkins运行selenium遇到的问题.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E4%B8%8BJenkins%E8%BF%90%E8%A1%8Cselenium%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"使用Jenkins对selenium脚本进行持续集成，遇到了一些奇葩问题，所以用这篇文章记录一下","text":"使用Jenkins对selenium脚本进行持续集成，遇到了一些奇葩问题，所以用这篇文章记录一下 工程运行提示“权限不够”1234567PermissionError: [Errno 13] 权限不够: &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;atomicwrites&#39;Traceback (most recent call last): File &quot;run_tests.py&quot;, line 6, in &lt;module&gt; import clickModuleNotFoundError: No module named &#39;click&#39;Build step &#39;Execute shell&#39; marked build as failureFinished: FAILURE 属于权限不够导致的，解决方案，在Bulid(构建)选项里添加# !/bin/bash然后再到xshell执行pip3 install click即可 出现error: unrecognized arguments:1234ERROR: usage: run_tests.py [options] [file_or_dir] [file_or_dir] [...]run_tests.py: error: unrecognized arguments: --html&#x3D;F:\\Git\\JenkinsDemo&#x2F;test_report&#x2F;2020_06_16_20_58_22\\report.html --self-contained-html inifile: None rootdir: F:\\Git\\JenkinsDemo 原因是缺少 pytest-html，执行 install pytest-html```就可以了解决了。12#### 提示error: unrecognized arguments: --reruns 1 sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper2020-06-16 21:10:10,183 - INFO - 回归模式，开始执行✈✈！ERROR: usage: run_tests.py [options] [file_or_dir] [file_or_dir] […]run_tests.py: error: unrecognized arguments: –reruns 1 inifile: None rootdir: /var/lib/jenkins/workspace/GitTestDemo ```原因是缺少 pytest-rerunfailures，执行pip3 install pytest-rerunfailures即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"npm install 遇到的灵异问题","slug":"npm install 遇到的灵异问题","date":"2020-06-12T08:18:00.000Z","updated":"2020-06-12T08:46:23.000Z","comments":true,"path":"npm install 遇到的灵异问题.html","link":"","permalink":"https://www.lauyongyi.cn/npm%20install%20%E9%81%87%E5%88%B0%E7%9A%84%E7%81%B5%E5%BC%82%E9%97%AE%E9%A2%98.html","excerpt":"使用 123npm -g install newman遇到了：npm WARN checkPermissions Missing write access to &#x2F;usr&#x2F;local&#x2F;lib","text":"使用 123npm -g install newman遇到了：npm WARN checkPermissions Missing write access to &#x2F;usr&#x2F;local&#x2F;lib 具体报错信息如下： 官方给出的一个解决办法是给npm的global安装位置换个地方，因为默认的安装位置是/usr/local/lib所在的文件夹，这是系统的文件夹所在地，所以可能会出现一些读写问题。将module的安装根目录设置在一般的文件夹下则没有这么多问题，下面是官方方法： 12345678# 第一步：在你的用户文件下新建一个文件夹，这个.npm-global 名字可以用你自己喜欢的名字替换，推荐直接使用这个名字。mkdir ~&#x2F;.npm-global# 第二步：更改node的安装连接npm config set prefix &#39;~&#x2F;.npm-global&#39;# 第三步：在用户的profile下增加path，为的是系统能够找到可执行文件的目录 export PATH&#x3D;~&#x2F;.npm-global&#x2F;bin:$PATH# 第四步：update profile。使其生效source ~&#x2F;.profile 再次执行 1npm -g install newman 出现 1npm ERR! Maximum call stack size exceeded 解决方案 12rm package-lock.jsonnpm cache clean --force 然后在执行安装命令","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux下jenkins部署遇到的问题记录","slug":"Linux下jenkins部署遇到的问题记录","date":"2020-06-11T09:48:00.000Z","updated":"2021-01-22T05:58:00.000Z","comments":true,"path":"Linux下jenkins部署遇到的问题记录.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E4%B8%8Bjenkins%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html","excerpt":"开始不定时的捣腾以前没有捣腾过的一些项目，首先尝试的是在Ubuntu和centos上安装Jenkins","text":"开始不定时的捣腾以前没有捣腾过的一些项目，首先尝试的是在Ubuntu和centos上安装Jenkins Ubuntu遇到的问题首先一定要安装JDK安装openjdk-8-jdk： 12apt-get updatesudo apt-get install openjdk-8-jdk 安装成功后查看版本，确认是否真的安装成功了（之前安装失败了，以为安装成功了，吐血) 1java -version 编辑/etc/profile，在文件尾添加java环境变量： 1sudo vi &#x2F;etc&#x2F;profile 或者 sudo vim &#x2F;etc&#x2F;profile 使用openjdk 1export JAVA_HOME&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&quot; Jenkins安装将存储库密钥添加到系统 1wget -q -O - https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian&#x2F;jenkins-ci.org.key | sudo apt-key add - 添加密钥后，系统将返回OK 。 接下来将Debian包存储库地址附加到服务器的sources.list ： 1echo deb http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian-stable binary&#x2F; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jenkins.list 然后执行 12sudo apt-get updatesudo apt-get install jenkins Jenkins安装成功后的启动，一直卡在加载页面，查了之后，发现是权限问题。（因为用的不是root账号，所有文件权限有问题，需要将权限设置未“777”）显示用一下命令，找到Jenkins的安装位置（默认是在： /usr/share/jenkins） 1whereis jenkins 进入到 /usr/share/ 路径下，对 /jenkins 进行权限修改 1sudo chmod -R 777 jenkins&#x2F; 然后修改：/var/lib/jenkins/ 的 “hudson.model.UpdateCenter.xml” 123 &lt;url&gt;http:&#x2F;&#x2F;updates.jenkins-ci.org&#x2F;update-center.json&lt;&#x2F;url&gt;或者是： &lt;url&gt;http:&#x2F;&#x2F;mirror.esuni.jp&#x2F;jenkins&#x2F;updates&#x2F;update-center.json&lt;&#x2F;url&gt; 修改完成后，启动Jenkins服务。输入密码就可正常进入了 Centos安装JDK安装openjdkyum install java-1.8.0-openjdk-devel.x86_64编辑全局变量：vi /etc/profile复制粘贴以下内容 123export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-XXXXXXXexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jarexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin 注意：JAVA_HOME的路径后面的XXXXXXX为jdk 的对应版本，需要根据安装完成后做调整 然后执行source /etc/profile使全局变量立即生效然后执行java -version检查是否安装成功； 安装OracleJDK需要到Oracle下载最新的jdk，这里需要注册，除了邮箱地址需要正确填写（有个注册验证）其他信息可以随意填写。 将下图所示版本下载到本地 然后在centos 系统创建文件夹存放 方法1： 12345用Xftp把jdk-8u261-linux-x64.tar.gz上传到此目录tar -xzvf jdk-8u261-linux-x64.tar.gz #解压mv jdk1.8.0_261 /usr/local/java #重命名并移动到指定位置cd /usr/local #进入/usr/local目录 方法2： 12345678910cd /usr/local #进入/usr/local目录mkdir java #创建/usr/local/java目录cd java #进入java目录用Xftp把jdk-8u261-linux-x64.tar.gz上传到此目录tar -xzvf jdk-8u261-linux-x64.tar.gz #解压mv jdk1.8.0_261 jdk1.8 #重命名jdk1.8.0_261 配置系统环境变量：vim /etc/profile 添加 12345JAVA_HOME=/usr/local/java/ #方法1的配置JRE_HOME=/usr/local/java/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 使配置生效：source /etc/profile 查看java版本：java -version 安装jenkins123sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.reposudo rpm --import https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.io.keyyum install jenkins 然后修改用户权限（不修改会出现启动失败的问题，很狗血） 123chown -R jenkins:jenkins &#x2F;var&#x2F;lib&#x2F;jenkinschown -R jenkins:jenkins &#x2F;var&#x2F;cache&#x2F;jenkinschown -R jenkins:jenkins &#x2F;var&#x2F;log&#x2F;jenkins 修改权限之后，使用systemctl start jenkins启动jenkins。 如果是使用OracleJdk的，还需要修改/etc/rc.d/init.d/jenkins里的jdk路径，下图所示的位置（需要精确到java可执行文件），否则会提示启动失败。 然后对 “hudson.model.UpdateCenter.xml”进行修改（不修改也可以，启动可能会比较慢，安装插件可能会出现失败的情况），方法Cenots的修改方法。 systemctl status jenkins查看Jenkins运行状态出现下图所示就是运行成功了 如果访问不了，可以执行firewall-cmd --permanent --zone=public --add-port=8080/tcp,开启8080端口，然后重启防火墙systemctl reload firewalld在执行firewall-cmd --list-ports确认8080端口是否开放出现下面的内容就表示开启成功 12[root@localhost ~]# firewall-cmd --list-ports8080&#x2F;tcp","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"robotframework 出现的错误提示","slug":"robotframework出现类型错误","date":"2020-06-02T08:12:00.000Z","updated":"2020-06-03T03:25:01.000Z","comments":true,"path":"robotframework出现类型错误.html","link":"","permalink":"https://www.lauyongyi.cn/robotframework%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF.html","excerpt":"问题：返回的数据是字典，直接当成字符串输出","text":"问题：返回的数据是字典，直接当成字符串输出 问题：返回的数据是字典，直接当成字符串输出 修改前的脚本：–输出返回内容– Log Json ${content} INFO 修改为： Log ${content}","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"通过adb命令发送指定的键值","slug":"通过adb命令发送指定的键值","date":"2020-05-28T10:07:00.000Z","updated":"2020-06-11T09:47:30.000Z","comments":true,"path":"通过adb命令发送指定的键值.html","link":"","permalink":"https://www.lauyongyi.cn/%E9%80%9A%E8%BF%87adb%E5%91%BD%E4%BB%A4%E5%8F%91%E9%80%81%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%AE%E5%80%BC.html","excerpt":"测试过程中，有需要将App置于后台的操作，单一设备可以通过直接操作设备，但多设备情况下，手动操作有点耗费时间","text":"测试过程中，有需要将App置于后台的操作，单一设备可以通过直接操作设备，但多设备情况下，手动操作有点耗费时间 这里我用到 adb shell 里的 input 功能，+ python，实现多设备同时操作先编写获取在线设备的方法 1234567891011import osimport reconnectDeviceid &#x3D; []# 使用adb命令，获取连接到电脑的设备p &#x3D;os.popen(&#39;adb devices&#39;)# 输出链接到电脑的设备outstr &#x3D; p.read()# 用正则表达式匹配connectDeviceid &#x3D; re.findall(r&#39;(.*?)\\s+device\\s&#39;, outstr) 然后根据加上对应的keyCode命令 123for adbDevices in connectDeviceid: adbs &#x3D; &quot;adb -s %s shell input keyevent KEYCODE_HOME&quot; % (adbDevices) KEYCODE_HOME &#x3D; os.system(adbs) 将两段代码结合起来，就可完成多设备触发返回桌面的操作。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Docker化安装STF","slug":"Docker化安装STF","date":"2020-05-26T08:03:00.000Z","updated":"2020-06-11T10:31:39.000Z","comments":true,"path":"Docker化安装STF.html","link":"","permalink":"https://www.lauyongyi.cn/Docker%E5%8C%96%E5%AE%89%E8%A3%85STF.html","excerpt":"在乌班图物理机上使用docker安装STF","text":"在乌班图物理机上使用docker安装STF 拉取STF相关联的镜像 sudo docker pull openstf/stf:latest # STF镜像 sudo docker pull sorccu/adb:latest # android adb 镜像 sudo docker pull rethinkdb:latest # rethinkdb 镜像 sudo docker pull openstf/ambassador:latest sudo docker pull nginx:latest # nginx 代理镜像 每个镜像拉取都需要一定的时间，如果出现超时的错误，重新执行拉取命令即可。 等所有镜像拉取命令执行完成后，使用命令 sudo docker images 确认是否已全部拉取成功。 启动镜像先启动一个数据库sudo docker run -d –name rethinkdb -v /srv/rethinkdb:/data –net host rethinkdb rethinkdb –bind all –cache-size 8192 –http-port 8090 再启动adb servicesudo docker run -d –name adbd –privileged -v /dev/bus/usb:/dev/bus/usb –net host sorccu/adb:latest 再启动stf 启动的时配置的IP地址为你的网址sudo docker run -d –name stf –net host openstf/stf stf local –public-ip 【IP地址】 再使用命令： sudo docker ps -a 查看 启动的docker 容器。 访问STF访问地址是：IP:7100可以使用随机字符来登录系统","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"},{"name":"openSTF","slug":"openSTF","permalink":"https://www.lauyongyi.cn/tags/openSTF/"}]},{"title":"Centos安装Docker","slug":"Centos安装docker","date":"2020-05-26T07:30:00.000Z","updated":"2020-06-11T10:31:39.000Z","comments":true,"path":"Centos安装docker.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85docker.html","excerpt":"因为时不时会在服务器上安装新的东西，有时候会导致其他已正常运行的服务受到影响，为此开始研究docker的一些基本操作。希望能较不必要的环境维护。","text":"因为时不时会在服务器上安装新的东西，有时候会导致其他已正常运行的服务受到影响，为此开始研究docker的一些基本操作。希望能较不必要的环境维护。 安装步骤： 下载docker-ce的repo： curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo 安装依赖： yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm 安装docker-ce: yum install docker-ce 启动docker： systemctl start docker","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"}]},{"title":"Docker删除所有容器","slug":"Docker删除所有容器","date":"2020-05-23T10:17:00.000Z","updated":"2020-05-26T08:13:31.000Z","comments":true,"path":"Docker删除所有容器.html","link":"","permalink":"https://www.lauyongyi.cn/Docker%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8.html","excerpt":"docker删除容器前，需要先停止容器的运行","text":"docker删除容器前，需要先停止容器的运行 删除所有处于同一状态的容器可以使用docker ps -a状态定位容器并对其进行过滤：创建，重新启动，运行，暂停或退出。要查看已退出容器的列表，可使用-f参数根据状态进行过滤。当确认要删除这些容器时，使用-q参数将容器ID传递给docker rm命令；eg： 列出所有处于停止状态的容器列表 1docker ps -a -f status&#x3D;exited 删除所有处于停止状态的容器 1docker rm $(docker ps -a -f status&#x3D;exited -q) 批量删除其他状态的容器方法同理。 删除所有容器首先需要停止所有容器 1docker stop $(docker ps -a -q) 删除所有容器 1docker rm $(docker ps -a -q) 非root用户需要在前面加上管理员权限sudo否则会提示权限不足 12sudo docker ps -a -f status&#x3D;exitedsudo docker rm $(docker ps -a -f status&#x3D;exited -q) 12sudo docker stop $(sudo docker ps -a -q)sudo docker rm $(sudo docker ps -a -q)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"}]},{"title":"解决Ride中FAIL：Variable","slug":"解决Ride中FAIL：Variable","date":"2020-05-23T07:42:00.000Z","updated":"2020-05-27T06:50:16.000Z","comments":true,"path":"解决Ride中FAIL：Variable.html","link":"","permalink":"https://www.lauyongyi.cn/%E8%A7%A3%E5%86%B3Ride%E4%B8%ADFAIL%EF%BC%9AVariable.html","excerpt":"RIDE中FAIL：Variable","text":"RIDE中FAIL：Variable 1234567891011TestCase16$&#123;nums&#125; set Variable $&#123;5&#125;$&#123;number&#125; set Variable $&#123;1&#125;Run keywork If $&#123;nums&#125;&gt;10 Log nums ELSE If $&#123;ints&#125;&gt;0 Log numberELSE Log nums 错误如下： Error:FAIL：Variable ‘${ints}’not found 修改为：Run Keyword If 缩进就可以了 123456789$&#123;nums&#125; Set Variable $&#123;5&#125;$&#123;ints&#125; Set Variable $&#123;1&#125;Run Keyword If $&#123;nums&#125; &gt;10 Log numsELSE If $&#123;ints&#125; &gt;0 Log intsELSE Log nums","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"content和text方法的区别","slug":"content和text方法的区别","date":"2020-05-23T06:13:00.000Z","updated":"2020-05-23T06:18:34.000Z","comments":true,"path":"content和text方法的区别.html","link":"","permalink":"https://www.lauyongyi.cn/content%E5%92%8Ctext%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"使用requests进行网页请求时，对页面内容进行解码和编码的时候，需要用到.content和.text。","text":"使用requests进行网页请求时，对页面内容进行解码和编码的时候，需要用到.content和.text。 Requests对象的get和post方法都会返回一个Response对象，这个对象里面存的是服务器返回的所有信息，包括响应头，响应状态码等。其中返回的网页部分会存在.content和.text两个对象中。两者区别在于，content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是’，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。所以简而言之，.text是现成的字符串，.content还要编码，但是.text不是所有时候显示都正常，这是就需要用.content进行手动编码。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"Request","slug":"Request","permalink":"https://www.lauyongyi.cn/tags/Request/"}]},{"title":"adb logcat 根据Tag 过滤日志","slug":"根据Tag 过滤日志","date":"2020-05-22T09:17:00.000Z","updated":"2021-05-10T13:52:38.000Z","comments":true,"path":"根据Tag 过滤日志.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%A0%B9%E6%8D%AETag%20%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97.html","excerpt":"adb logcat根据tag获取需要指定标签（tag）和日志级别","text":"adb logcat根据tag获取需要指定标签（tag）和日志级别 adb logcat [TAG:LEVEL ] [TAG:LEVEL ] … LEVEL: 可以选择:[V D I W E S]中其中一个 TAG:X 的作用为: 输出标签为TAG的log级别大于X的信息. 例如: adb logcat Test:I 输出 Test的I 和I 级别以上的log,包括 i, w, e 注意: (1)可以指定多个[TAG:LEVEL ] (2) level : S 表示为不输出该标签的日志,应为没有大于S级别的日志了 (3) [TAG:LEVEL ] 不会影响其他标签的日志, 所以如果要屏蔽其他log请使用 *:S adb logcat Test:I *:S 例子： 1adb logcat xx:V aa:V bb:V ReportWeb:V vac:V reqm:V Em:V cccc:V dddd:V *:S","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"python 打开/关闭命令行窗口","slug":"python 打开关闭命令行窗口","date":"2020-05-22T08:14:00.000Z","updated":"2020-05-23T07:46:29.000Z","comments":true,"path":"python 打开关闭命令行窗口.html","link":"","permalink":"https://www.lauyongyi.cn/python%20%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3.html","excerpt":"用python编写多设备安装APP脚本时，有个场景，APP安装成功后，允许，实时打印日志和设备CPU占用信息，就找了下面的方法","text":"用python编写多设备安装APP脚本时，有个场景，APP安装成功后，允许，实时打印日志和设备CPU占用信息，就找了下面的方法 123456789101112131415161718import osdevices = [&#x27;OJHA7P9PZLRWUWBA&#x27;, &#x27;ZTEBV0710T&#x27;]def adbtop(): for i in devices: adb = &#x27;start cmd /k &quot;adb -s %s shell top -m 10&quot;&#x27; %(i) os.system(adb)def adbLogcat(): logTag = &#x27;vc:V vs:V Vm:V ReportWeb:V vac:V reqm:V Em:V VPReportManager:V VpAdControl:V *:S&#x27; for i in devices: adbs = &#x27;start cmd /k &quot;adb -s %s logcat %s&quot;&#x27; % (i, logTag) os.system(adbs)def cmdKill(self): adbs = &#x27;start cmd /k &quot;tskill adb &amp;&amp; tskill cmd&quot;&#x27; kill = os.system(adbs) return killif __name__ == &#x27;__main__&#x27;: adbtop() adbLogcat() devices 是设备号。通过adb devices 获得 cmd窗口关闭命令中的 tskill adb （一般情况下是 tskill cmd）因为使用了adb 进程，所以在任务管理器显示成了adb，就需要改为 tskill adb 来结束进程。tskill adb &amp;&amp; tskill cmd 的用法是：结束adb窗口的同时，关闭CMD窗口","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"使用RIDE遇到的几个问题","slug":"使用RIDE遇到的几个问题","date":"2020-04-23T08:34:00.000Z","updated":"2020-05-23T08:15:09.000Z","comments":true,"path":"使用RIDE遇到的几个问题.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%BD%BF%E7%94%A8RIDE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98.html","excerpt":"学习RobotFramework 遇到的几个小问题","text":"学习RobotFramework 遇到的几个小问题 启动Ride： 报错信息：AttributeError:模块“sys”没有属性“maxint”python2中: 1random.randint(0,sys.maxint) pyhon3引入sys模块，输出sys.maxint,发现会报错：FAIL:Evaluating expression ‘random.randint(0,sys.maxint)’ failed: AttributeError: module ‘sys’ has no attribute ‘maxint’解决办法修改为: 1random.randint(0,sys.maxsize) 遇到报AttributeError:模块“string”没有属性“letters”python2是用： 1string.letters python3是用： 1string.ascii_letters 目前我用的是python3以上的版本：string.letters修改为string.ascii_letters就可以解决问题","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"解决monkey压测的问题java.lang.SecurityException","slug":"monkey压测可能出现的问题","date":"2020-04-15T08:29:00.000Z","updated":"2020-05-23T07:35:42.000Z","comments":true,"path":"monkey压测可能出现的问题.html","link":"","permalink":"https://www.lauyongyi.cn/monkey%E5%8E%8B%E6%B5%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"使用adb跑monkey时，出现报错：java.lang.SecurityException: Injecting to another application requires INJECT_EV ENTS permission","text":"使用adb跑monkey时，出现报错：java.lang.SecurityException: Injecting to another application requires INJECT_EV ENTS permission 原因：没有USB模拟的权限 解决办法：设置——更多设置-开发者选项—USB调试（安全设置）【允许通过USB调试修改权限或模拟点击】点击打开按钮，再次允许脚本，问题就解决了","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Python中解决UnicodeDecodeError","slug":"Python中解决UnicodeDecodeError","date":"2020-04-08T14:32:00.000Z","updated":"2020-05-23T07:50:13.000Z","comments":true,"path":"Python中解决UnicodeDecodeError.html","link":"","permalink":"https://www.lauyongyi.cn/Python%E4%B8%AD%E8%A7%A3%E5%86%B3UnicodeDecodeError.html","excerpt":"pycharm中打开文件需要使用open，遇到报错。","text":"pycharm中打开文件需要使用open，遇到报错。 代码如下： 123import os file = open(&quot;exercise01.py&quot;) print(file.read()) 此时会报错：UnicodeDecodeError: ‘gbk’ codec can’t decode byte……….处理方式是， 在open函数中加入文件读写模式的说明，其中二进制文件需要用“rb”读写，故将第二行代码改为 1file = open(&quot;exercise01.py&quot;, &quot;rb&quot;) 即可读出文件。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"模拟其它浏览器，包括移动浏览器","slug":"模拟其不同的浏览器","date":"2020-03-27T10:53:00.000Z","updated":"2020-05-23T07:22:46.000Z","comments":true,"path":"模拟其不同的浏览器.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%A8%A1%E6%8B%9F%E5%85%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8.html","excerpt":"测试Web页面兼容性的时候，总是要模拟不同的设备页面，本文主要是记录常用的设备模拟功能","text":"测试Web页面兼容性的时候，总是要模拟不同的设备页面，本文主要是记录常用的设备模拟功能 1、打开浏览器，使用F12，调出开发者调试工具，然后点击图下所示的选择设定 more tools （更多工具）- network condition （网络状态）2、Chrome浏览器修改 UA 模拟其它浏览器，见下图然后看到有个 user agent 去掉 select automatically （自动选择）就可以选择各种浏览器了，包括移动端，然后可以愉快的模拟了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}]},{"title":"adb shell top命令解析","slug":"adb shell top命令解析","date":"2020-03-26T02:42:00.000Z","updated":"2021-05-11T15:42:49.000Z","comments":true,"path":"adb shell top命令解析.html","link":"","permalink":"https://www.lauyongyi.cn/adb%20shell%20top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90.html","excerpt":"top命令提供了实时系统处理器的状态监视，它将显示系统中的任务列表，该命令可以按CPU使用&gt;内存使用和执行时间对任务进行排序。","text":"top命令提供了实时系统处理器的状态监视，它将显示系统中的任务列表，该命令可以按CPU使用&gt;内存使用和执行时间对任务进行排序。 top 用法 adb shell top --help Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [-t ] [ -h ] -m num Maximum number of processes to display. 最多显示多少个进程 -n num Updates to show before exiting. 刷新次数 -d num Seconds to wait between updates. 刷新间隔时间（默认5秒） -s col Column to sort by (cpu,vss,rss,thr). 按哪列排序 -t Show threads instead of processes. 显示线程信息而不是进程 -h Display this help screen. 显示帮助文档 返回信息解释：Android N（7.1系统，level = 25） 及之前12345678910111213141516171819202122232425262728User 5%, System 7%, IOW 0%, IRQ 0%User 67 + Nice 2 + Sys 87 + Idle 1005 + IOW 1 + IRQ 0 + SIRQ 0 &#x3D; 1162PID PR CPU% S # THR VSS RSS PCY UID Name3543 0 6% S 7 12728K 3740K bg logd &#x2F;system&#x2F;bin&#x2F;logd第一组数据的含义：- User 处于用户态的运行时间，不包含优先值为负进程- Nice 优先值为负的进程所占用的CPU时间- Sys 处于核心态的运行时间- Idle 除IO等待时间以外的其它等待时间- IOW IO等待时间- IRQ 硬中断时间- SIRQ 软中断时间第二组数据的含义：- PID 进程id- PR 优先级- CPU% 当前瞬时CPU占用率- S 进程状态:D&#x3D;不可中断的睡眠状态, R&#x3D;运行, S&#x3D;睡眠, T&#x3D;跟踪&#x2F;停止, Z&#x3D;僵尸进程- THR 程序当前所用的线程数- VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）- RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存）- PCY 调度策略优先级，SP_BACKGROUND&#x2F;SP_FOREGROUND- UID 进程所有者的用户id- Name 进程的名称 Android O（8.0系统，level = 26） 及之后:123456Tasks: 558 total, 1 running, 553 sleeping, 0 stopped, 1 zombie任务(进程) 系统现在共有558个进程，其中处于运行中的有1个，553个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。Mem: 5846936k total, 4524412k used, 1322524k free, 99464k buffers内存状态: 物理内存总量 (5.6G) 使用中的内存总量 空闲内存总量 缓存的内存量Swap: 2621436k total, 338868k used, 2282568k free, 2248048k cachedswap交换分区: 交换区总量 使用的交换区总量 空闲交换区总量 缓冲的交换区总量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546400%cpu 2%user 0%nice 4%sys 394%idle 0%iow 0%irq 0%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS23541 shell 20 0 10M 2.7M 1.4M R 4.6 0.0 0:31.89 top18117 root 20 0 0 0 0 S 0.6 0.0 0:06.88 [kworker&#x2F;u8:24]17638 root 20 0 0 0 0 S 0.6 0.0 0:01.00 [kworker&#x2F;1:0]22118 root 20 0 0 0 0 S 0.3 0.0 0:01.11 [kworker&#x2F;0:4]17910 root 20 0 0 0 0 S 0.3 0.0 0:05.94 [kworker&#x2F;u8:2] 2679 shell 20 0 15M 748K 580K S 0.3 0.0 0:19.43 adbd --root_sec+ 330 root RT 0 0 0 0 S 0.3 0.0 74:10.28 [cfinteractive] 20 root 20 0 0 0 0 S 0.3 0.0 5:24.44 [ksoftirqd&#x2F;3]23707 root 20 0 0 0 0 S 0.0 0.0 0:00.00 [kworker&#x2F;1:2]cpu状态 400%cpu -- CPU总量8%user -- 用户空间占用CPU的百分比。0%nice -- 改变过优先级的进程占用CPU的百分比41%sys -- 内核空间占用CPU的百分比394%idle -- 空闲CPU百分比0%iow -- IO等待占用CPU的百分比0%irq -- 硬中断（Hardware IRQ）占用CPU的百分比0%sirq -- 软中断（Software Interrupts）占用CPU的百分比0%host -- PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量(virtual memory usage)，单位kb。VIRT&#x3D;SWAP+RES 1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等 2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量RES — resident memory usage 常驻内存，单位kb。RES&#x3D;CODE+DATA 1、进程当前使用的内存大小，但不包括swap out 2、包含其他进程的共享 3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反 4、关于库占用内存的情况，它只统计加载的库文件所占内存大小SHR — 共享内存(shared memory)，单位kb 1、除了自身进程的共享内存，也包括其他进程的共享内存 2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小 3、计算某个进程所占的物理内存大小公式：RES – SHR 4、swap out后，它将会降下来S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒ARGS — 进程名称（命令名&#x2F;命令行） 常用的命令是：adb shell top -m 10adb shell top -t -m 10 查看设备cpu和内存占用情况：adb shell top 查看前N个进程：adb shell top -m 10/adb shell top -m 10 -t -d 10 打印每个进程使用CPU详情输出至cpu.txt：adb shell top &gt; CPU.txt 要监测单个应用，例如针对单一应用的CPU占用率~ 监测一次的CPU占用情况：adb shell top -n 1 | grep 包名 10秒刷新一次显示CPU占用情况：adb shell top -d 10 | grep 包名 实时监测指定包的CPU占用情况：adb shell top |grep 包名","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"adb 常用命令","slug":"adb 常用命令","date":"2020-03-24T07:37:00.000Z","updated":"2021-06-03T12:00:00.000Z","comments":true,"path":"adb 常用命令.html","link":"","permalink":"https://www.lauyongyi.cn/adb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"adb是什么?adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse/Android studio中通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse/Android studio时adb进程就会自动运行。 adb有什么用?借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作!","text":"adb是什么?adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse/Android studio中通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse/Android studio时adb进程就会自动运行。 adb有什么用?借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作! 常用的adb命令来源：谷歌安卓开发文档查看在线设备： adb devices 详细的查看在线设备：adb devices -l 开启TCP连接：adb tcpip [端口号] 结束adb进程：adb kill-server 无线adb调试：adb connect 「设备名」/[设备IP] 断开ABD链接：adb disconnect「设备名」/[设备IP] 多设备情况下连接指定设备：adb -s「设备名」/[设备IP] shell命令：adb shell ，多设备情况下需要指定设备 root权限获取：adb root ，adb remount 或者shell命令模式下，使用 su root权限获取之后，提示“Read-only file system”，在 shell模式下执行mount -o remount,rw /，即可。 添加代理：adb shell settings put global http_proxy IP:port 清除代理：adb shell settings put global http_proxy:0 安装：adb install 包地址 -r：重新安装现有应用，保留其数据。 -t：允许安装测试 APK。 -i ：installer_package_name：指定安装程序软件包名称。 –install-location location：使用以下某个值来设置安装位置： 0：使用默认安装位置。 1：在内部设备存储上安装。 2：在外部介质上安装。 -f：在内部系统内存上安装软件包。 -d：允许版本代码降级。 -g：授予应用清单中列出的所有权限。 –fastdeploy：通过仅更新已更改的 APK 部分来快速更新安装的软件包。 获取APP启动入口：adb logcat | grep Displayed(windows 平台没有”grep”，需要使用findstr代替） 启动App：adb shell am start -n [PackName]/[Acitvity] 清理/重置App数据： adb shell pm clear [包名] 结束APP进程：adb shell am force-stop 包名 卸载：adb uninstall [包名] 移除软件包后保留数据和缓存目录 获取APP版本：adb shell pm dump [packName] |grep version，windows平台将grep改成findstr 日志抓取：adb logcat 进程查看：adb shell top 常用的：adb shell -m top 10截屏例:adb shell screencap -p /[path]/[Filename] 复制文件到设备：adb push【本地】【设备】 复制文件到电脑：adb pull 【设备】 【本地】 获取设备信息序列号(机器码)：adb get-serialno MAC地址：adb shell cat /sys/class/net/wlan0/address 设备型号：adb shell getprop ro.product.model 系统版本：adb shell getprop ro.build.version.release 系统应用的所有包名：adb shell pm list packages -s 第三方应用包名：adb shell pm list packages -3 屏幕分辨率：adb shell wm size 屏幕像素密度：adb shell wm density CPU信息：adb shell cat /proc/cpuinfo 设备已有权限：adb shell pm list permissions -f 用户信息：adb shell pm list users -f 获取dumpsys信息：adb shell dunmpsys [参数] [包名] 命令 解析 adb shell dumpsys activity top 获取当前 Android 系统 中与用户交互的 Activity 的详细信息 adb shell dumpsys meminfo [包名] 查看应用的内存使用情况 adb shell dumpsys package [包名] 获取特定 app 的应用信息、版本信息 adb shell dumpsys activity activities 显示当前所有在运行的任务栈，并可查看栈中所有的 Activity 的列表 adb shell dumpsys activity 显示当前所有在运行的任务栈 adb shell dumpsys cpuinfo 获取CPU信息 adb shell dumpsys gfxinfo[包名] 获取GPU绘制信息 adb shell dumpsys batterystats --charged package-name 输出自设备上次充电以来指定应用软件包的电池用量统计信息 adb shell dumpsys window | findstr mCurrentFocus 获取当前前台运行的包名和类名 adb shell dumpsys window |grep mCurrentFocus 获取当前前台运行的包名和类名(Linux和Uinx下使用)","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"python通过setup.py安装模块","slug":"python通过setup.py安装模块","date":"2020-03-12T08:00:00.000Z","updated":"2020-05-25T08:03:24.000Z","comments":true,"path":"python通过setup.py安装模块.html","link":"","permalink":"https://www.lauyongyi.cn/python%E9%80%9A%E8%BF%87setup.py%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97.html","excerpt":"python有些插件需要通过编译，才能安装，具体方法如下","text":"python有些插件需要通过编译，才能安装，具体方法如下 步骤: 使用命令行工具，到达安装目录（下载完成的目录） 执行以下命令： 12python setup.py build (构建编译）python setup.py install （安装） Windows平台在执行install的时候，需要使用管理员权限的命令行或者管理员权限的PowerShell。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示","slug":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示","date":"2020-03-10T03:34:00.000Z","updated":"2020-05-23T06:37:20.000Z","comments":true,"path":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%AD%E2%80%9C%E5%B7%B2%E7%99%BB%E5%BD%95%E5%88%B0Wlan%E7%BD%91%E7%BB%9C%E2%80%9D%E6%88%96%E8%80%85%E2%80%9C%E7%99%BB%E5%BD%95%E5%88%B0%E7%BD%91%E7%BB%9C%E2%80%9D%E7%9A%84%E6%8F%90%E7%A4%BA.html","excerpt":"部分安卓手机会出现“登录wlan的提示”，在设置内无法关闭，只能通过ADB命令关闭","text":"部分安卓手机会出现“登录wlan的提示”，在设置内无法关闭，只能通过ADB命令关闭 命令如下： 123adb devices &#x2F;&#x2F;多设备情况下，需要查看设备名称，单一设备可以不输入，也可用来检查设备链接是否正常adb shell &#x2F;&#x2F;单一设备。多设备要使用 adb -s deviceName&#x2F;IP shellsettings put global captive_portal_detection_enabled 0","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"scrapy 基本命令","slug":"scrapy 基本命令","date":"2020-03-06T07:08:00.000Z","updated":"2020-05-23T08:09:47.000Z","comments":true,"path":"scrapy 基本命令.html","link":"","permalink":"https://www.lauyongyi.cn/scrapy%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html","excerpt":"记录一下scrapy常用命令。","text":"记录一下scrapy常用命令。 创建项目： scrapy startproject xxxx（项目名） 创建起始页面: scrapy genspider xxx(爬虫名）”url” 爬虫检查： scrapy check 爬虫列表： scrapy list 调试： scrapy shell //用于快速调试正则或者链接是否正确等 scrapy debug调试/已经快速运行的方法: 在爬虫根目录新建一个 main.py 12from scrapy import cmdline&lt;cmdline.execute(&#x27;scrapy crawl xxx(爬虫名)&#x27;.split())","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"adb 抓取指定包的日志（.bat方式）","slug":"adb logcat通过包名过滤（dos命令find后跟变量)","date":"2020-03-06T02:19:00.000Z","updated":"2020-05-23T07:46:12.000Z","comments":true,"path":"adb logcat通过包名过滤（dos命令find后跟变量).html","link":"","permalink":"https://www.lauyongyi.cn/adb%20logcat%E9%80%9A%E8%BF%87%E5%8C%85%E5%90%8D%E8%BF%87%E6%BB%A4%EF%BC%88dos%E5%91%BD%E4%BB%A4find%E5%90%8E%E8%B7%9F%E5%8F%98%E9%87%8F).html","excerpt":"在测试SDK的时候，遇到需要查看指定APP的日志情况（公司设备有点落后，跑AS容易卡死），就找了以下方法进行查看","text":"在测试SDK的时候，遇到需要查看指定APP的日志情况（公司设备有点落后，跑AS容易卡死），就找了以下方法进行查看 通过过滤进程的pid来过滤该应用的日志过滤条件：该app在运行实现原理： ​ 获取该app运行时的pid ​ 通过find命令，过滤pid的日志，就是该包的运行日志 实现： 1、在同一目录建立一文件：getpid.bat，输入以下代码 12@echo offadb shell &quot;ps | grep com.example.testprogram&quot; 2、在同一目录建立另外一个问文件：getpid1.bat 12345@echo offfor &#x2F;f &quot;tokens&#x3D;2 delims&#x3D; &quot; %%i in (&#39;getpid.bat&#39;) do set pid&#x3D;%%iecho %pid%adb logcat | find &quot;%pid%&quot;pause 链接手机，启动com.example.testprogram这个app 双击getpid1.bat即可获取该程序的日志： 123456789101112131415161718192021222324252627282930D&#x2F;dalvikvm( 9017): Late-enabling CheckJNII&#x2F;ActivityManager( 2272): Start proc com.example.testprogram for activity com.example.testprogram&#x2F;.MainActivity: pid&#x3D;9017 uid&#x3D;10070 gids&#x3D;&#123;50070, 1028&#125;D&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libEGL_mali.soD&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libGLESv1_CM_mali.soD&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libGLESv2_mali.soE&#x2F; ( 9017): Device driver API matchE&#x2F; ( 9017): Device driver API version: 17E&#x2F; ( 9017): User space API version: 17E&#x2F; ( 9017): mali: REVISION&#x3D;Linux-r3p1-01rel1 BUILD_DATE&#x3D;Tue Jul 2 15:06:24 KST 2013D&#x2F;OpenGLRenderer( 9017): Enabling debug mode 0D&#x2F;tag ( 9017): it&#39;s a log !D&#x2F;AndroidRuntime( 9017): Shutting down VMW&#x2F;dalvikvm( 9017): threadid&#x3D;1: thread exiting with uncaught exception (group&#x3D;0x418dc700)E&#x2F;AndroidRuntime( 9017): FATAL EXCEPTION: mainE&#x2F;AndroidRuntime( 9017): java.lang.ArithmeticException: divide by zeroE&#x2F;AndroidRuntime( 9017): at com.example.testprogram.MainActivity$2.onClick(MainActivity.java:33)E&#x2F;AndroidRuntime( 9017): at android.view.View.performClick(View.java:4247)E&#x2F;AndroidRuntime( 9017): at android.view.View$PerformClick.run(View.java:17728)E&#x2F;AndroidRuntime( 9017): at android.os.Handler.handleCallback(Handler.java:730)E&#x2F;AndroidRuntime( 9017): at android.os.Handler.dispatchMessage(Handler.java:92)E&#x2F;AndroidRuntime( 9017): at android.os.Looper.loop(Looper.java:137)E&#x2F;AndroidRuntime( 9017): at android.app.ActivityThread.main(ActivityThread.java:5289)E&#x2F;AndroidRuntime( 9017): at java.lang.reflect.Method.invokeNative(Native Method)E&#x2F;AndroidRuntime( 9017): at java.lang.reflect.Method.invoke(Method.java:525)E&#x2F;AndroidRuntime( 9017): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739)E&#x2F;AndroidRuntime( 9017): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:555)E&#x2F;AndroidRuntime( 9017): at dalvik.system.NativeStart.main(Native Method)I&#x2F;Process ( 9017): Sending signal. PID: 9017 SIG: 9I&#x2F;ActivityManager( 2272): Process com.example.testprogram (pid 9017) has died.W&#x2F;InputMethodManagerService( 2272): Got RemoteException sending setActive(false) notification to pid 9017 uid 10070","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"浏览器toast定位","slug":"浏览器toast定位","date":"2020-02-21T08:49:00.000Z","updated":"2020-05-23T06:38:19.000Z","comments":true,"path":"浏览器toast定位.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%B5%8F%E8%A7%88%E5%99%A8toast%E5%AE%9A%E4%BD%8D.html","excerpt":"在浏览器打开需要捕捉toast的页面，","text":"在浏览器打开需要捕捉toast的页面， 打开开发者工具（F12）切换到“Sources”分栏，触发toast，在 toast出现后立刻暂停，然后再去定位","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"爬虫遇到的问题与解","slug":"爬虫遇到的问题与解","date":"2019-10-20T15:00:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"爬虫遇到的问题与解.html","link":"","permalink":"https://www.lauyongyi.cn/%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3.html","excerpt":"学习爬虫过程中遇到的一些问题","text":"学习爬虫过程中遇到的一些问题 requests的content和text方法的区别Requests对象的get和post方法都会返回一个Response对象，这个对象里面存的是服务器返回的所有信息，包括响应头，响应状态码等。其中返回的网页部分会存在.content和.text两个对象中。两者区别在于，content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是’，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。所以简而言之，.text是现成的字符串，.content还要编码，但是.text不是所有时候显示都正常，这是就需要用.content进行手动编码。 re.findall提示类型不匹配的问题外层找到后，下一步引用需要加上 str 进行转码，才不会报错 例子： 1toc_block=re.findall(&#x27;&lt;h2&gt;盗墓笔记(.*?)&lt;/div&gt;&#x27;,html,re.S) #需要转成str，否则会报类型错误的问题 1toc_url=re.findall(&#x27;href=&quot;(.*?)&quot;&#x27;,str(toc_block),re.S) 关于异步加载复杂json的解析多层json，解析后，可以用re.findall查找元素","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"selenium模拟用户鼠标操作","slug":"selenium模拟用户鼠标操作","date":"2019-09-03T12:10:00.000Z","updated":"2019-09-03T12:28:38.000Z","comments":true,"path":"selenium模拟用户鼠标操作.html","link":"","permalink":"https://www.lauyongyi.cn/selenium%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C.html","excerpt":"在写selenium自动化脚本的时候，常常会遇到下拉菜单，这时候多半需要使用模拟事件来处理","text":"在写selenium自动化脚本的时候，常常会遇到下拉菜单，这时候多半需要使用模拟事件来处理 鼠标操作由selenium 的ActionChains类来完成模拟鼠标操作 主要操作流程：1、存储鼠标操作2、perform()来执行鼠标操作支持的操作如下：click 单击double_click 双击操作context_click 右键操作drag_and_drag 拖拽操作，左键按住拖动某一个元素到另外一个区域，然后释放按键move_to_element() -鼠标悬停，以后会经常遇到实例代码: ActionChains(driver).move_to_element(&#39;元素&#39;).perform()","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"selenium等待类型","slug":"selenium等待类型","date":"2019-09-01T06:16:00.000Z","updated":"2019-09-01T06:28:38.000Z","comments":true,"path":"selenium等待类型.html","link":"","permalink":"https://www.lauyongyi.cn/selenium%E7%AD%89%E5%BE%85%E7%B1%BB%E5%9E%8B.html","excerpt":"编写自动化脚本的时候，经常会出现定位不到元素或者元素为空的不稳定现象，这个时候，就需要在脚本中加入等待功能。","text":"编写自动化脚本的时候，经常会出现定位不到元素或者元素为空的不稳定现象，这个时候，就需要在脚本中加入等待功能。 在实际工作中等待机制可以保证代码的稳定性,从而代码不会因为网速、电脑性能等条件的约束而影响运行结果。等待就是当运行代码时,页面的渲染速度跟不上代码的运行速度时,就需要人为的去限制代码执行的速度,这就是等待。在做web自动化时,一般要等待页面元素加载完成后,才能执行操作,否则会报找不到元素等各种错误,这样就要求我们在有些场景下加等待时间。最常见的有三种等待方式: 隐式等待 显式等待 强制等待 隐式等待 ​ 设置一个等待时间,轮询查找(默认0.5秒)元素是否出现,如果没出现就抛出异常。这也是最常见的等待方法。 隐式等待的作用是全局的。 self.driver. implicitly_wait(30) 显式等待 ​ 显式等待是你在代码中定义等待一定条件发生后再进一步执行你的代码。WebDriverWait配合该类的 until和 untilnot方法,就能够根据判断条件进行等待。程序每隔一段时间(默认为0.5秒)进行条件判断,如果条件成立,则执行下一步,否则继续等待,直到超过设置的最长时间。当隐式等待不起作用时,就会用到显式等待。 123456from selenium. webdriver. support. wait import WebDriverWaitfrom selenium. webdriver. support import expected_conditionsWebDriverWait(driver, 10).until( expected_conditions.element_to_be_clickable(By.TAG_NAME,&quot;title&quot;)) 强制等待 ​ 线程休眠一定时间。强制等待一般在隐式等待和显示等待都不起作用时使用 12import timetime.sleep(10)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"服务器+域名部署Hexo","slug":"服务器+域名部署Hexo","date":"2018-12-26T14:40:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"服务器+域名部署Hexo.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8+%E5%9F%9F%E5%90%8D%E9%83%A8%E7%BD%B2Hexo.html","excerpt":"​ 这是本站采用的建站教程","text":"​ 这是本站采用的建站教程 服务器操作部分在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置创建文件目录(用于博客站点文件存放) 123cd &#x2F;usr&#x2F;local&#x2F;mkdir hexochmod 775 -R &#x2F;usr&#x2F;local&#x2F;hexo&#x2F; 添加 index.html(用于检测配置 Nginx 是否成功) 1vim &#x2F;usr&#x2F;local&#x2F;hexo&#x2F;index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;&#x2F;p&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 配置 Nginx 服务器 1vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root &#x2F;usr&#x2F;local&#x2F;hexo&#x2F;; &#125; 启动nginx服务； 12centos 6 启动命令：service nginx startcentos 7 启动命令：systemctl start nginx 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd &#x2F;usr&#x2F;local&#x2F;mkdir hexoRepochmod 775 -R &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F; Git 初始化裸库。 12cd hexoRepo&#x2F;git init --bare hexo.git 创建 Git 钩子(hook)。 1vim &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!&#x2F;bin&#x2F;bashgit --work-tree&#x3D;&#x2F;usr&#x2F;local&#x2F;hexo --git-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git checkout -f 保存并退出后, 给该文件添加可执行权限。 1chmod +x &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive 本地操作部分安装hexo-deployer-git插件在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo &#x2F;&#x2F;用户名@域名或 IP 地址:&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 推送到GithubPages在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g #编译$ hexo d #部署到服务器 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。","categories":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}]},{"title":"网站分享","slug":"网站分享","date":"2018-12-22T14:30:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"网站分享.html","link":"","permalink":"https://www.lauyongyi.cn/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB.html","excerpt":"个人收藏，常用的网站,持续更新","text":"个人收藏，常用的网站,持续更新 视频茶泡饭 一个免费的视频分享下载网站 CK影视 快播时代残存下载的在线视频播放网站，新的资源基本都可以在线播放。 部分老旧资源需要按照要求下载绿色版的快播才能正常观看 图片wallhaven WallBase创办人失联后，前成员推出的网站。 一个很“强大”图片网站，具体强大到什么地步，还得自己慢慢探索 （我的电脑壁纸基本都来自这个网站） Windows资源下载msdn.itellyou 微软资源下载首推的网站，谁用谁知道","categories":[{"name":"分享","slug":"分享","permalink":"https://www.lauyongyi.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.lauyongyi.cn/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"SQL常用语句","slug":"SQL基础语句","date":"2018-12-13T10:47:00.000Z","updated":"2020-10-16T03:50:30.000Z","comments":true,"path":"SQL基础语句.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5.html","excerpt":"记录工作中较常用的SQL语句。","text":"记录工作中较常用的SQL语句。 1、查看数据库:：SHOW databases;。2、选择数据库：USE database_name。3、表定义信息：DESCRIBE table_name。4、插入数据：INSERT INFO table_name (field_1...field_n) VALUES (value_1...value_n);。5、更新数据：UPDATE table_name SET field_1=value_1…field_n=value_n WHERE CONDITION;。6、删除记录：DELETE FROM table_name WHERECONDITION;。7、单表数据查询。 1）单表数据查询的基本语句：SELECT field_1,field_n FROM table_name;。 2）避免重复：SELECT DISTINCT field_1, field_n FROM table_name;。 3）排序查询：SELECT field_1, field_n FROM table_name WHERE CONDITION ORDER BY field_name [ASC|DESC];。 4）限制数据记录查询数量：SELECT field_1,field_n FROM table_name WHERE CONDITION LIMIT OFFSET_START,ROW_COUNT;。 5）统计数值列总和：SELECT SUM（field_name）FROM table_name;。 6）统计制定列的值的数目：SELECT COUNT（field_name）FROM table_name;。 7）根据列表查询：SELECT field_1, field_n FROM table_name WHERE field_1 IN (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);。 8）范围查询：SELECT field_1, field_n FROM table_name WHERE field_n BETWEEN value_1 AND value_2;。 9）分组查询：SELECT * FROM table_name WHERE field_1 LIKE &#39;%&#39; GROUP BY field_1 LIMIT 10;。 10）多条件查询：SELECT column1, columnN FROM table_name WHERE CONDITION-1 &#123;AND|OR&#125; CONDITION-2; 8、多表查询。 1）SELECT 字段1,字段2,字段3,…… FROM 表名1,表名2 WHERE 关联条件&#39;;。等同于SELECT 字段1,字段2,字段3,…… FROM 表名1 INNER JOIN 表名2 ON 关联条件;。 2）左连接查询：SELECT 字段1,字段2,字段3,…… FROM 表名1 LEFT JOIN 表名2 ON 关联条件;。 3）右连接查询：SELECT 字段1,字段2,字段3,…… FROM 表名1 RIGHT JOIN 表名2 ON 关联条件;。 4）自动删除重复行：SELECT语句1 UNION SELECT语句2;。 5）保留重复行（不自动排序）：SELECT语句1 UNION ALL SELECT语句2;。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"安卓App与iOSApp和Web测试的区别","slug":"安卓App与iOSApp和Web测试的区别","date":"2018-11-24T12:37:00.000Z","updated":"2018-11-27T06:42:21.000Z","comments":true,"path":"安卓App与iOSApp和Web测试的区别.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93App%E4%B8%8EiOSApp%E5%92%8CWeb%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"关于安卓App与iOSApp和Web测试的区别，经常会被人问起，然后就整理了一下","text":"关于安卓App与iOSApp和Web测试的区别，经常会被人问起，然后就整理了一下 WEB 测试和 App 测试从流程上来说，没有区别。 都需要经历测试计划方案，用例设计，测试执行，缺陷管理，测试报告等相关活动。 从技术上来说，WEB 测试和 APP 测试其测试类型也基本相似，都需要进行功能测 试、性能测试、安全性测试、GUI 测试等测试类型。 他们的主要区别在于具体测试的细节和方法有区别，比如：性能测试，在 WEB 测试只需要测试响应时间这个要素，在 App 测试中还需要考虑流量测试和耗电量测试。 ​ 兼容性测试：在 WEB 端是兼容浏览器，在 App 端兼容的是手机设备。而且相对应 的兼容性测试工具也不相 同，WEB 因为是测试兼容浏览器，所以需要使用不同 的浏览器进行兼容性测试（常见的是兼容 IE6，IE8，chrome，firefox）如果是 手机端， 那么就需要兼容不同品牌，不同分辨率，不同 android 版本甚至不同 操作系统的兼容。（常见的兼容方式是兼容市场占用率前 N 位的手机即可），有时候也可以使用到兼容性测试工具，但 WEB 兼容性工具多用 IETester 等工具， 而 App 兼容性测试会使用 Testin 这样的商业工具也可以做测试。 ​ 安装测试：WEB 测试基本上没有客户端层面的安装测试，但是 App 测试是存在客 户端层面的安装测试，那么就具备相关的测试点。 还有App测试基于手机设备，还有一些手机设备的专项测试。如交叉事件测试， 操作类型测试，网络测试（弱网测试，网络切换） ​ 交叉事件测试：就是在操作某个软件的时候，来电话、来短信，电量不足提示等 外部事件。 ​ 操作类型测试：如横屏测试，手势测试 ​ 网络测试：包含弱网和网络切换测试。需要测试弱网所造成的用户体验，重点要考虑回退和刷新是否会造成二次提交。弱网络的模拟，可以用fiddler等实现。 ​ 从系统架构的层面，WEB 测试只要更新了服务器端，客户端就会同步会更新。而 且客户端是可以保证每一个用户的客户端完全一致的。但是 APP 端是不能 够保 证完全一致的，除非用户更新客户端。如果是 APP 下修改了服务器端，意味着客 户端用户所使用的核心版本都需要进行回归测试一遍。 ​ 还有升级测试：升级测试的提醒机制，升级取消是否会影响原有功能的使用，升级后用户数据是否被清除了。 android 和 ios 测试区别 Android 长按 home 键呼出应用列表和切换应用，然后右滑则终止应用；目前都是基于全屏手势，更多的是关注不同的手势操作会带来什么样的响应事件 多分辨率测试，Android 端 不同厂商不同型号的，屏幕参数众多，需要选取有代表的进行测试。可以参考类似腾讯移动分析，ios 较少； 手机操作系统，Android 较多，ios 较少且不能降级，只能单向升级；新的 ios 系统中的资源库不能完全兼容低版本中的 ios 系统中的应用，低版本 ios 系统中 的应用调用了新的资源库，会直接导致闪退（Crash）； 操作习惯：Android虚拟导航键是否被重写（例如：单击返回，长按回到主页面），测试点击后的反馈是否正确；应用数据从内存移动到 SD 卡后能否正常运行等； push 测试：Android：点击 home 键，程序后台运行时，此时接收到 push，点 击后唤醒应用，此时是否可以正确跳转；ios，点击 home 键关闭程序和屏幕锁屏 的情况（红点的显示）； 安装卸载测试：Android 的下载和安装的平台和工具和渠道比较多，ios 主要 有 app store，iTunes 和 testflight 下载； 升级测试：可以被升级的必要条件：新旧版本具有相同的签名；新旧版本具有 相同的包名；有一个标示符区分新旧版本（如版本号）， 对于 Android 若有内置的应用需检查升级之后内置文件是否匹配（如内置的输入 法） 另外：对于测试还需要注意一下几点： 并发（中断）测试：闹铃弹出框提示，另一个应用的启动、视频音频的播放， 来电、用户正在输入等，语音、录音等的播放时强制其他正在播放的要暂停； 数据来源的测试：输入，选择、复制、语音输入，安装不同输入法输入等； push（推送）测试：在开关机、待机状态下执行推送，消息先死及其推送跳转 的正确性； 应用在开发、未打开状态、应用启动且在后台运行的情况下是 push 显示和跳转 否正确； 推送消息阅读前后数字的变化是否正确； 多条推送的合集的显示和跳转是否正确； 分享跳转：分享后的文案是否正确；分享后跳转是否正确，显示的消息来源是 否正确； 触屏测试：同时触摸不同的位置或者同时进行不同操作，查看客户端的处理情 况，是否会 crash 等","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"一个APP的组成","slug":"app相关的知识","date":"2018-11-24T07:37:00.000Z","updated":"2018-11-27T06:42:21.000Z","comments":true,"path":"app相关的知识.html","link":"","permalink":"https://www.lauyongyi.cn/app%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86.html","excerpt":"为了方便测试工作的展开，收集的一些APP相关基础知识和测试关注的点","text":"为了方便测试工作的展开，收集的一些APP相关基础知识和测试关注的点 Android 四大组件Android 四大基本组件：Activity、BroadcastReceiver 广播接收器、 ContentProvider 内容提供者、Service 服务。 Activity: 应用程序中，一个 Activity 就相当于手机屏幕，它是一种可以包含用户界面的 组件，主要用于和用户进行交互。一个应用程序可以包含许多活动，比如事件的 点击，一般都会触发一个新的 Activity。 BroadcastReceiver 广播接收器： 应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时， 或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然 而， 它们可以启动一个 activity 或 serice 来响应它们收到的信息，或者用 NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力 ──闪动背灯、震动、播放声音 等。一般来说是在状态栏上放一个持久的图标， 用户可以打开它并获取消息。 ContentProvider 内容提供者: 内容提供者主要用于在不同应用程序之间实现数据共享的功能，它提供了一套完 整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据 的 安全性。只有需要在多个应用程序间共享数据时才需要内容提供者。例如：通讯 录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处：统一 数 据访问方式。 Service 服务： 是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用 户交互而且还要长期运行的任务（一边打电话，后台挂着 QQ）。服务 的运行不 依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另一个应用程序， 服务扔然能够保持正常运行，不过服务并不是运行在一个独立的进程当 中，而 是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉后，所有 依赖于该进程的服务也会停止运行（正在听音乐，然后把音乐程序退出）。 ActivityActivity 是 Android 的四大组件之一，也是平时我们用到最多的一个组件，可 以用来显示 View。Activity 是一个 Android 的应用组件，它提供屏幕进行交互。每个 Activity 都 会获得一个用于绘制其用户界面的窗口，窗口可以充满哦屏幕也可以小于屏幕并 浮动在其他窗口之上。 一个应用通常是由多个彼此松散联系的 Activity 组成，一般会指定应用中的某 个 Activity 为主活动，也就是说首次启动应用时给用户呈现的 Activity。将 Activity 设为主活动的方法 当然 Activity 之间可以进行互相跳转，以便执行不同的操作。每当新 Activity 启动时，旧的 Activity 便会停止，但是系统会在堆栈也就是返回栈中保留该 Activity。 当新 Activity 启动时，系统也会将其推送到返回栈上，并取得用户的操作焦点。 当用户完成当前 Activity 并按返回按钮是，系统就会从堆栈将其弹出销毁，然 后回复前一 Activity 当一个 Activity 因某个新 Activity 启动而停止时，系统会通过该 Activity 的 生命周期回调方法通知其这一状态的变化。 Activity 因状态变化每个变化可能有若干种，每一种回调都会提供执行与该状 态相应的特定操作的机会。 Activity 生命周期1.运行（Active/Running）:Activity 处于活动状态，此时 Activity 处于栈顶， 是可见状态，可以与用户进行交互 2.暂停（Paused）:当 Activity 失去焦点时，或被一个新的非全面屏的 Activity， 或被一个 透明的 Activity 放置在栈顶时，Activity 就转化为 Paused 状态。此 刻并不会被销毁，只是失去了与用户交互的能力，其所有的状态信息及其 成员 变量都还在，只有在系统内存紧张的情况下，才有可能被系统回收掉 3.停止（Stopped）:当 Activity 被系统完全覆盖时，被覆盖的 Activity 就会进 入 Stopped 状态，此时已不在可见，但是资源还是没有被收回 4.系统回收（Killed）:当 Activity 被系统回收掉，Activity 就处于 Killed 状 态 如果一个活动在处于停止或者暂停的状态下，系统内存缺乏时会将其结束 （finish）或者杀死（kill）。这种非正常情况下，系统在杀死或者结束 之前 会调用 onSaveInstance()方法来保存信息，同时，当 Activity 被移动到前台时， 重新启动该 Activity 并调用 onRestoreInstance()方法加载保留的信息，以保 持原有的状态。 在上面的四中常有的状态之间，还有着其他的生命周期来作为不同状态之间的过 度，用于在不同的状态之间进行转换，生命周期的具体说明见下图所示。 导致app 出现 ANR的原因简单的总结有以下两点： 1.主线程执行了耗时操作，比如数据库操作或网络编程 2.其他进程（就是其他程序）占用 CPU 导致本进程得不到 CPU 时间片，比如其他 进程的频繁读写操作可能会导致这个问题。 细分的话，导致 ANR 的原因有如下几点： ​ 耗时的网络访问 ​ 大量的数据读写 ​ 数据库操作 ​ 硬件操作（比如 camera) ​ 调用 thread 的 join()方法、sleep()方法、wait()方法或者等待线程锁的时候 ​ service binder 的数量达到上限 ​ system server 中发生 WatchDog ANR ​ service 忙导致超时无响应 ​ 其他线程持有锁，导致主线程等待超时 ​ 其它线程终止或崩溃导致主线程一直等待。 App 出现 crash 的原因App 崩溃相关的几个因素：内存 管理错误，程序逻辑错误，设备兼容，网络因素等，如下： ​ 内存管理错误：可能是可用内存过低，app 所需的内存超过设备的限制，app 跑不起来导致 App crash。 或是内存泄露，程序运行的时间越长，所占用的内存越大，最终用尽全部内存， 导致整个系统崩溃。 亦或非授权的内存位置的使用也可能会导致 App crash。 ​ 程序逻辑错误：数组越界、堆栈溢出、并发操作、逻辑错误。 e.g. app 新添加一个未经测试的新功能，调用了一个已释放的指针，运行的时 候就会 crash。 ​ 设备兼容：由于设备多样性，app 在不同的设备上可能会有不同的表现。 ​ 网络因素：可能是网速欠佳，无法达到 app 所需的快速响应时间，导致 app crash。或者是不同网络的切换也可能会影响 app 的稳定性。 经常出现的异常（Exception） 常见的几种如下： NullPointerException - 空指针引用异常 ClassCastException - 类型强制转换异常 IllegalArgumentException - 传递非法参数异常 ArithmeticException - 算术运算异常 ArrayStoreException - 向数组中存放与声明类型不兼容对象异常 IndexOutOfBoundsException - 下标越界异常 NegativeArraySizeException - 创建一个大小为负数的数组错误异常 NumberFormatException - 数字格式异常 SecurityException - 安全异常 UnsupportedOperationException - 不支持的操作异常","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"建站教程","slug":"本站建站教程","date":"2018-11-15T16:07:04.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"本站建站教程.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%9C%AC%E7%AB%99%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B.html","excerpt":"本站采用的blog服务是Hexo，采用的是GitPage部署的方式","text":"本站采用的blog服务是Hexo，采用的是GitPage部署的方式 官网教程地址：https://hexo.io/zh-cn/docs/ 参考资料基本的操作 https://www.simon96.online/2018/10/12/hexo-tutorial/ 进阶修改相关 https://segmentfault.com/a/1190000009544924 本站使用的主题Next https://github.com/theme-next/hexo-theme-next 官方的中文教程 https://theme-next.iissnan.com/getting-started.html","categories":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}]},{"title":"浏览器输入 url 按回车背后经历了哪些","slug":"浏览器输入 url 按回车背后经历了哪些","date":"2018-10-02T06:16:00.000Z","updated":"2018-10-02T06:28:38.000Z","comments":true,"path":"浏览器输入 url 按回车背后经历了哪些.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%20url%20%E6%8C%89%E5%9B%9E%E8%BD%A6%E8%83%8C%E5%90%8E%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B.html","excerpt":"一个日常生活中，最常见的操作，但也常常被忽略，那就是：浏览器输入 url 按回车背后经历了哪些","text":"一个日常生活中，最常见的操作，但也常常被忽略，那就是：浏览器输入 url 按回车背后经历了哪些 1、首先，在浏览器地址栏中输入 url，先解析 url，检测 url 地址是否合法 2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在 屏幕中显示页面内容。若没有，则跳到第三步操作。 浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求； 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)； 路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存； ISP 缓存：若上述均失败，继续向 ISP 搜索。 3、在发送 http 请求前，需要域名解析(DNS 解析)，解析获取相应的 IP 地址。 4、浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手。 5、握手成功后，浏览器向服务器发送 http 请求，请求数据包。 6、服务器处理收到的请求，将数据返回至浏览器 7、浏览器收到 HTTP 响应 8、浏览器解码响应，如果响应可以缓存，则存入缓存。 9、 浏览器发送请求获取嵌入在 HTML 中的资源（html，css，javascript，图片， 音乐······），对于未知类型，会弹出对话框。 10、 浏览器发送异步请求。 11、页面全部渲染结束。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"web测试","slug":"web测试","permalink":"https://www.lauyongyi.cn/tags/web%E6%B5%8B%E8%AF%95/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2018-10-01T06:16:00.000Z","updated":"2018-10-01T06:28:38.000Z","comments":true,"path":"HTTP状态码.html","link":"","permalink":"https://www.lauyongyi.cn/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html","excerpt":"HTTP状态码（HTTP Status Code）是指表示服务器HTTP响应状态的3位数字代码。","text":"HTTP状态码（HTTP Status Code）是指表示服务器HTTP响应状态的3位数字代码。 它的作用在于使客户端程序快速通过服务器返回的状态，决定下一步要如何处理。因为由于网络延迟、服务器内部错误等各种原因，都可能导致客户端发送的请求得不到正确的响应，但是这些错误原因千差万别，如果一一处理很不现实，所以更有效的方式是把它们分组归类，利用统一的状态码进行标记，这样客户端就可以根据状态码进行处理了。 HTTP状态码可以分为5大类。 1）1xx仅仅是作为通知的消息，例如：102 Processing。这一类型的状态码，代表请求已经被接受，需要继续处理。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是临时的，表示客户端应该采取其他行动。 2）2xx是代表请求成功，例如：200 OK。这一类型的状态码，代表请求已成功被服务器接收、理解并接受。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立， 且其 URI 已经随 Location 头信息返回 202 服务器已接受请求，但尚未处理 3）3x是代表HTTP重定向，例如：301 Moved Permanently。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应 （对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应 继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来 检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此 响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返 回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者 应继续使用原有位置来进行以后的请求。 4）4xx是代表客户端导致的错误，例如404 Not Found。这类的状态码代表客户端发生的错误妨碍了服务器的处理。 401 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书 403 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份 验证并不能提供任何帮助，而且这个请求也不应该被重复提交 404 请求失败，请求所希望得到的资源未被在服务器上发现 5）5xx是代表服务器导致的错误，例如：500 Internal Server Error。这类状态码代表服务器在处理请求的过程中有错误或者异常状态发生，当然也有可能是服务器当前的软硬件资源无法完成对请求的处理。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的 方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收 到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状 况是临时的，并且将在一段时间以后恢复。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"}]},{"title":"HTTP协议","slug":"关于HTTP协议","date":"2018-10-01T02:16:00.000Z","updated":"2019-09-01T06:28:38.000Z","comments":true,"path":"关于HTTP协议.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE.html","excerpt":"http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。","text":"http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。 HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:&#x6a;&#x61;&#118;&#x61;&#x2d;&#110;&#101;&#116;&#x40;&#106;&#97;&#118;&#x61;&#46;&#115;&#117;&#x6e;&#x2e;&#x63;&#111;&#x6d;。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Postman环境变量设置与返回值检查","slug":"Postman环境变量设置与返回值检查","date":"2018-09-17T10:47:00.000Z","updated":"2018-12-13T10:47:30.000Z","comments":true,"path":"Postman环境变量设置与返回值检查.html","link":"","permalink":"https://www.lauyongyi.cn/Postman%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC%E6%A3%80%E6%9F%A5.html","excerpt":"Postman的全局变量，方便环境管理和参数设置。","text":"Postman的全局变量，方便环境管理和参数设置。 Postman变量作用域Global：全局，比如可以将错误提示信息设置成全局变量 Environment：环境变量，比如可以将测试domain设置成环境变量 Local：本地变量，一般可以在sandbox中定义 Data：测试数据中导入变量，所谓的参数化 界面位置 简单的实例：使用的是v2ex的Api作为示例链接, url： https://www.v2ex.com/api/nodes/show.json?name=&#123;&#123;node_name&#125;&#125; 是环境变量 操作步骤：先点击Postman界面的眼睛图标 然后点击“Environment（环境变量）”的Add，进入到编辑页面，见下图。 环境变量的名称可以自由定义，建议设置成有代表性，这样才方便区分。 填写好之后，需要选择环境变量 添加断言： 1234567var jsonData &#x3D; JSON.parse(responseBody);var node_name &#x3D; pm.environment.get(&quot;node_name&quot;);console.log(node_name);---先获取并检查返回值是否是想要的结果pm.test(&quot;返回值的name必须等于node_name&quot;, function () &#123; pm.expect(jsonData.name).to.eql(node_name);---将返回值与变量作比较&#125;); 然后运行，就可以看到结果了","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"https://www.lauyongyi.cn/tags/Postman/"}]},{"title":"连接MySQL出现2059错误","slug":"使用Navicat连接MySQL出现2059错误","date":"2018-06-13T15:00:00.000Z","updated":"2021-04-24T00:45:38.898Z","comments":true,"path":"使用Navicat连接MySQL出现2059错误.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%BD%BF%E7%94%A8Navicat%E8%BF%9E%E6%8E%A5MySQL%E5%87%BA%E7%8E%B02059%E9%94%99%E8%AF%AF.html","excerpt":"今天使用navicat链接mysql的时候报了2059的错误，找了很久才找到解决方法，这里记录一下。","text":"今天使用navicat链接mysql的时候报了2059的错误，找了很久才找到解决方法，这里记录一下。 出现2059这个错误的原因是在mysql8之前的版本中加密规则为mysql_native_password，而在mysql8以后的加密规则为caching_sha2_password。通过网络查找发现我们可以将mysql用户登录的加密规则修改为mysql_native_password。下面说下具体步骤：打开xshll或者命令行工具 输入mysql -uroot -p登陆mysql，如果提示commod not found，那我们需要先将mysql加入系统环境变量（安装在本地的情况）。 登录成功后输入ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER修改加密规则 加密规则修改完成后我们可以通过ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;我是新密码&#39;更新一下用户的密码。这样就可以顺利的去使用Navicat去链接Mysql了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"},{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"},{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/categories/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"name":"分享","slug":"分享","permalink":"https://www.lauyongyi.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"工具的使用","slug":"工具的使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"},{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"},{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"},{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"面试","slug":"面试","permalink":"https://www.lauyongyi.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"http","slug":"http","permalink":"https://www.lauyongyi.cn/tags/http/"},{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"},{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.lauyongyi.cn/tags/MySQL/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"},{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"},{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"},{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"},{"name":"apache bench","slug":"apache-bench","permalink":"https://www.lauyongyi.cn/tags/apache-bench/"},{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"},{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"},{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"},{"name":"openSTF","slug":"openSTF","permalink":"https://www.lauyongyi.cn/tags/openSTF/"},{"name":"Request","slug":"Request","permalink":"https://www.lauyongyi.cn/tags/Request/"},{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"name":"网站","slug":"网站","permalink":"https://www.lauyongyi.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"web测试","slug":"web测试","permalink":"https://www.lauyongyi.cn/tags/web%E6%B5%8B%E8%AF%95/"},{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"},{"name":"Postman","slug":"Postman","permalink":"https://www.lauyongyi.cn/tags/Postman/"}]}
{"meta":{"title":"Tianen","subtitle":"搞事情，搞事情","description":"","author":null,"url":"https://www.lauyongyi.cn","root":"/"},"pages":[{"title":"关于这个小站点","date":"2018-11-15T15:04:43.000Z","updated":"2021-05-10T14:34:36.395Z","comments":false,"path":"about/index.html","permalink":"https://www.lauyongyi.cn/about/index.html","excerpt":"","text":"关于本人 这个站点主要用于记录个人的一些学习过程，主要是工作中用到的工具，框架、接触到的新知识等。记录内容来源主要是个人操作、学习记录以及网上其他大神的分享摘录。 如果文章中有不实、侵权以及错误的地方，可以通过邮件告诉我，我会及时处理修正。 欢迎一起来玩，ヾﾉ≧∀≦)o来啊，快活啊!"},{"title":"Project","date":"2021-07-18T14:53:03.856Z","updated":"2021-04-24T00:45:38.950Z","comments":true,"path":"project/index.html","permalink":"https://www.lauyongyi.cn/project/index.html","excerpt":"","text":""},{"title":"能快速找到文章的地方","date":"2018-11-15T15:03:58.000Z","updated":"2021-04-24T00:45:38.950Z","comments":false,"path":"tags/index.html","permalink":"https://www.lauyongyi.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-15T14:56:50.000Z","updated":"2021-04-24T00:45:38.900Z","comments":false,"path":"categories/index.html","permalink":"https://www.lauyongyi.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用requests做简单的接口测试","slug":"python+request2","date":"2021-09-05T11:14:00.000Z","updated":"2021-09-05T14:15:00.000Z","comments":true,"path":"python+request2.html","link":"","permalink":"https://www.lauyongyi.cn/python+request2.html","excerpt":"​ requests除了用来做接口请求的发送，还可以用来做接口测试，使用方法跟最基础的发送请求一样，不同点就是多了一些处理方法和断言。","text":"​ requests除了用来做接口请求的发送，还可以用来做接口测试，使用方法跟最基础的发送请求一样，不同点就是多了一些处理方法和断言。 ​","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"Linux常用的几个命令","slug":"Linux常用命令","date":"2021-09-04T03:26:00.000Z","updated":"2021-12-14T11:04:00.000Z","comments":true,"path":"Linux常用命令.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"​ 记录几个日常工作中常用到的几个Linux命令如：tail、cat、vi、grep等以及相关的可选项的使用。","text":"​ 记录几个日常工作中常用到的几个Linux命令如：tail、cat、vi、grep等以及相关的可选项的使用。 tail​ tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容. 命令格式tail [必要参数] [选择参数] [文件] 命令功能用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 命令参数 参数 解释 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示行数 –pid=PID 与-f合用,可以在指定进程结束后结束tail -f -q, –quiet, –silent 从不输出给出文件名的首部 -s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 使用实例显示文件末尾内容123456tail -n 5 time.log BTW = FFUSB = FF0x300Power Down% 循环查看文件内容12345678910111213141516171819202122ping 192.168.31.220 &gt; ip.log&amp;[1] 37763tail -f ip.log --pid 37763Request timeout for icmp_seq 0Request timeout for icmp_seq 1Request timeout for icmp_seq 2Request timeout for icmp_seq 3Request timeout for icmp_seq 4Request timeout for icmp_seq 5Request timeout for icmp_seq 6Request timeout for icmp_seq 7Request timeout for icmp_seq 8Request timeout for icmp_seq 9Request timeout for icmp_seq 10Request timeout for icmp_seq 11Request timeout for icmp_seq 12Request timeout for icmp_seq 13Request timeout for icmp_seq 14Request timeout for icmp_seq 15Request timeout for icmp_seq 16Request timeout for icmp_seq 17Request timeout for icmp_seq 18 说明： ping 192.168.31.220 &gt; ip.log&amp; &amp; //在后台ping远程主机。并输出文件到ip.log；这种做法也适用于一个以上的档案监视。可以Ctrl＋c来终止，也可以在另一个窗口 kill pid 来结束。 grep​ grep命令是Linux系统中一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 命令格式grep [option] /path/file：用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。 命令参数： 参数 解释 -a –text 不要忽略二进制的数据。 -A&lt;显示行数&gt; –after-context=&lt;显示行数&gt; 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b –byte-offset 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; –before-context=&lt;显示行数&gt; 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c –count 计算符合样式的列数。 -C&lt;显示行数&gt; –context=&lt;显示行数&gt;或-&lt;显示行数&gt; 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; –directories=&lt;动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; –regexp=&lt;范本样式&gt; 指定字符串做为查找文件内容的样式。 -E –extended-regexp 将样式为延伸的普通表示法来使用。 -f&lt;规则文件&gt; –file=&lt;规则文件&gt; 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F –fixed-regexp 将样式视为固定字符串的列表。 -G –basic-regexp 将样式视为普通的表示法来使用。 -h –no-filename 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H –with-filename 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i –ignore-case 忽略字符大小写的差别。 -l –file-with-matches 列出文件内容符合指定的样式的文件名称。 -L –files-without-match 列出文件内容不符合指定的样式的文件名称。 -n –line-number 在显示符合样式的那一行之前，标示出该行的列数编号。 -q –quiet或–silent 不显示任何信息。 -r –recursive 此参数的效果和指定“-d recurse”参数相同。 -s –no-messages 不显示错误信息。 -v –revert-match 显示不包含匹配文本的所有行。 -V –version 显示版本信息。 -w –word-regexp 只显示全字符合的列。 -x –line-regexp 只显示全列符合的列。 -y 此参数的效果和指定“-i”参数相同。 使用场景查找指定进程123ps -ef | grep pycharm 501 36537 1 0 3:14下午 ?? 17:29.34 /Users/......./Library/Application Support/JetBrains/Toolbox/apps/PyCharm-P/ch-0/212.5080.64/PyCharm.app/Contents/MacOS/pycharm 501 38003 36013 0 5:18下午 ttys000 0:00.00 grep pycharm 说明： 第一条记录是查找出的进程；第二条结果是grep进程本身，并非真正要找的进程。 查找指定进程个数1234ps -ef | grep pycharm -c2ps -ef | grep -c pycharm catcat（“ concatenate ”的缩写）命令是Linux / Unix等操作系统中最常用的命令之一。cat命令允许创建单个或多个文件，查看文件、连接文件以及在终端或文件中重定向输出。 主要用途1、显示文件内容，如果没有文件或文件为-则读取标准输入。2、将多个文件的内容进行连接并打印到标准输出。3、显示文件内容中的不可见字符（控制字符、换行符、制表符等）。 命令格式cat [OPTION]... [FILE]...FILE（可选）：要处理的文件，可以为一或多个。长选项与短选项等价| 参数 | 解释 || ———————————————– | ———————————————————— ||-A, –show-all |等价于”-vET”组合选项。|-b, –number-nonblank |只对非空行编号，从1开始编号，覆盖”-n”选项。||-e |等价于”-vE”组合选项。||-E, –show-ends |在每行的结尾显示’$’字符。||-n, –number |对所有行编号，从1开始编号。||-s, –squeeze-blank |压缩连续的空行到一行。||-t |等价于”-vT”组合选项。||-T, –show-tabs |使用”^I”表示TAB（制表符）。||-u |POSIX兼容性选项，无意义。||-v, –show-nonprinting |使用”^”和”M-“符号显示控制字符，除了LFD（line feed，即换行符’\\n’）和TAB（制表符）。||–help | 显示帮助信息并退出。||–version | 显示版本信息并退出。| 操作示例123456789101112# 合并显示多个文件cat ./1.log ./2.log ./3.log# 显示文件中的非打印字符、tab、换行符cat -A test.log# 压缩文件的空行cat -s test.log# 显示文件并在所有行开头附加行号cat -n test.log# 显示文件并在所有非空行开头附加行号cat -b test.log# 将标准输入的内容和文件内容一并显示echo &#x27;######&#x27; |cat - test.log vi/vim参考另一个笔记 :Linux vi和vim","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"使用requests发送简单的接口请求","slug":"python+request","date":"2021-08-29T11:14:00.000Z","updated":"2021-08-29T13:15:00.000Z","comments":true,"path":"python+request.html","link":"","permalink":"https://www.lauyongyi.cn/python+request.html","excerpt":"​ requests一个Python第三方库，用来做接口测试、爬虫特别方便","text":"​ requests一个Python第三方库，用来做接口测试、爬虫特别方便 安装requests安装命令如下：pip install requests 如果遇到报错，windows可以使用管理员权限的命令行窗口执行、Linux等可以在前面加sudo。 使用requests非常简单，只需要import requests，然后调用即可。 第一个Get请求例子： 123456import requestshtml = requests.get(&#x27;https://www.v2ex.com/api/nodes/show.json?name=python&#x27;)print(html.status_code)print(html.text)print(html.headers) 运行结果如下图： ![](/images/2021/08/Interface Test/02.png) 第一个Post请求Post请求，相较于Get请求，要稍稍复杂一些，需要构造requestsBody。 例子： 123456789101112131415import requestsurl = &quot;https://api.apishop.net/common/weather/getWeatherByGPS&quot;payload=&#123;&#x27;apiKey&#x27;:&#x27;XXXXXXXXXXXXXXXXXXX&#x27;,&#x27;from&#x27;: &#x27;1&#x27;,&#x27;lat&#x27;: &#x27;22.546534&#x27;,&#x27;lng&#x27;: &#x27;113.931833&#x27;,&#x27;need3HourForcast&#x27;: &#x27;1&#x27;,&#x27;needMoreDay&#x27;: &#x27;1&#x27;&#125;headers = &#123;&#125;response = requests.post(url, headers=headers, data=payload)print(response.text) 由于返回的内容较多，这里就不加图了。 携带User-Agent的请求用户代理（英语：user agent）在计算机科学中指的是代表用户行为的程序（软件代理程序）。例如，网页浏览器就是一个“帮助用户获取、渲染网页内容并与之交互”的用户代理 当一个软件在一个网络协议进行操作时，它通常向它的operating peer提交一个特定的字符串来标示自己，该字符串通常包含了其应用程序类型、操作系统、软件供应商……等等，有时还会包含软件修订版本等信息。在HTTP、SIP以及SMTP/NNTP[2]协议中，这个识别是通过user-agent的头字段传送的。网络机器人，例如网络抓取工具，通常也会在用户代理的字符串中包含bot的操纵者的联系信息，例如一个URL或一个电子邮件地址，以便网站管理员可以用来联系操纵者。 在HTTP中，User-Agent字符串通常被用于内容协商，而原始服务器为该响应选择适当的内容或操作参数。例如，User-Agent字符串可能被网络服务器用以基于特定版本的客户端软件的已知功能选择适当的变体。 通过使用robots.txt文件的可以设置网络抓取工具对网站的部分访问与否，而其设置标准之一就是用户代理字符串。换句话说，借由robots.txt文件的设置，可以让网站不能被特定的浏览器访问。 以豆瓣为例子： 1234567import requestshtml = requests.get(&#x27;https://www.douban.com/&#x27;)print(html.status_code)*****运行结果*****418 返回的“418”表示请求被豆瓣的服务拒绝了，也就说明，豆瓣认为该次请求是爬虫请求。 这时候，添加一个User-Agent来模拟成六=浏览器发送的请求。 User-Agent可以从网上随便搜索到，也可用浏览器自带的控制台获取。 1234567import requestsheaders = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#x27;&#125;html = requests.get(&#x27;https://www.douban.com/&#x27;,headers=headers)print(html.status_code)******运行结果******200 这时候，就可以添加一些其他打印了，如text、hearders等。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"adb shell dumpsys 命令解析","slug":"adb命令--dumpsys","date":"2021-08-28T15:17:00.000Z","updated":"2021-08-28T15:17:00.000Z","comments":true,"path":"adb命令--dumpsys.html","link":"","permalink":"https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--dumpsys.html","excerpt":"​ dumpsys 是一种在 Android 设备上运行的工具，可提供有关系统服务的信息。可以使用 ADB从命令行调用 dumpsys，获取在连接的设备上运行的所有系统服务的诊断输出。此输出通常比想要的更详细，因此可以使用下文所述的命令行选项仅获取您感兴趣的系统服务的输出。","text":"​ dumpsys 是一种在 Android 设备上运行的工具，可提供有关系统服务的信息。可以使用 ADB从命令行调用 dumpsys，获取在连接的设备上运行的所有系统服务的诊断输出。此输出通常比想要的更详细，因此可以使用下文所述的命令行选项仅获取您感兴趣的系统服务的输出。 基本语法使用 dumpsys 的一般语法如下： adb shell dumpsys [-t timeout] [--help | -l | --skip services | service [arguments] | -c | -h] 要获取所连接设备的所有系统服务的诊断输出，只需运行 adb shell dumpsys。不过，这样输出的信息比想要的信息多得多。要使输出更加可控，可以通过在命令中添加相应服务来指定要检查的服务。 选项 说明 -t timeout 指定超时期限（秒）。如果未指定，默认值为 10 秒。 --help 输出 dumpsys 工具的帮助文本。 -l 输出可与 dumpsys 配合使用的系统服务的完整列表。 --skip services 指定您不希望包含在输出中的 services。 service [arguments] 指定您希望输出的 service。某些服务可能允许您传递可选 arguments。您可以通过将 -h 选项与服务名称一起传递来了解这些可选参数，如下所示：adb shell dumpsys procstats -h -c 指定某些服务时，附加此选项能以计算机可读的格式输出数据。 -h 对于某些服务，附加此选项可查看该服务的帮助文本和其他选项。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"adb shell am 命令解析","slug":"adb命令--am","date":"2021-08-28T02:42:00.000Z","updated":"2021-08-28T13:57:00.000Z","comments":true,"path":"adb命令--am.html","link":"","permalink":"https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--am.html","excerpt":"​ am全称：Activity Manager ，可以执行各种系统操作，如启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性，等等。","text":"​ am全称：Activity Manager ，可以执行各种系统操作，如启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性，等等。 命令行语法 环境 命令 adb 直接发出 adb shell am &lt;command&gt; shell 中 am &lt;command&gt; intent 功能Intent 是一个消息传递对象，您可以用来从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个： 启动 Activity Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 用于描述要启动的 Activity，并携带任何必要的数据。 如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收 启动服务 Service 是一个不使用用户界面而在后台执行操作的组件。使用 Android 5.0（API 级别 21）及更高版本，您可以启动包含 JobScheduler 的服务。如需了解有关 JobScheduler 的详细信息，请参阅其 API-reference documentation。 对于 Android 5.0（API 级别 21）之前的版本，您可以使用 Service 类的方法来启动服务。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。 如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。 传递广播 广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，您可以将广播传递给其他应用。 Intent 基础项 Intent 说明 例子 参数 COMPONENT 指定带有软件包名称前缀的组件名称以创建显式 intent com.example.app/.ExampleActivity -n ACTION 指定 intent 操作，比如调用拨打电话组件 android.intent.action.VIEW -a DATA_URI 指定 intent 数据 URI content://contacts/people/1 -d CATEGORY 指定 intent 类别 android.intent.category.APP_CONTACTS -c MIME_TYPE 传递给Intent的额外数据，以Bundle的形式定义，就是一些键值对 image/png -t EXTRA 添加字符串数据作为键值对 -e FLAGS 将标志添加到 setFlags() 支持的 intent。 -f Intent EXTRA(附加的额外数据) Intent 说明 数据类型 -e|–es extra_key extra_string_value 添加字符串数据作为键值对 字符串 –esn extra_key 添加一个 null extra。URI intent 不支持此选项。 null –ez extra_key extra_boolean_value 添加布尔型数据作为键值对。 布尔型 –ei extra_key extra_int_value 添加整数型数据作为键值对。 整型 –el extra_key extra_long_value 添加长整型数据作为键值对。 长整型 –ef extra_key extra_float_value 添加浮点型数据作为键值对。 浮点型 –eu extra_key extra_uri_value 添加 URI 数据作为键值对。 URI –ecn extra_key extra_component_name_value 添加组件名称，将其作为 ComponentName 对象进行转换和传递 COMPONENT –eia extra_key extra_int_value[,extra_int_value…] 添加整数数组。 整数数组 –ela extra_key extra_long_value[,extra_long_value…] 添加长整型数组。 长整型数组 –efa extra_key extra_float_value[,extra_float_value…] 添加浮点型数组。 浮点型数组 Intent activity FLAG Intent 说明 –activity-brought-to-front 包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT –activity-clear-top 包含标志 FLAG_ACTIVITY_CLEAR_TOP –activity-clear-when-task-reset 包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET –activity-exclude-from-recents 包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS –activity-launched-from-history 包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY –activity-multiple-task 包含标志 FLAG_ACTIVITY_MULTIPLE_TASK –activity-no-animation 包含标志 FLAG_ACTIVITY_NO_ANIMATION –activity-no-history 包含标志 FLAG_ACTIVITY_NO_HISTORY –activity-no-user-action 包含标志 FLAG_ACTIVITY_NO_USER_ACTION –activity-previous-is-top 包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP –activity-reorder-to-front 包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT –activity-reset-task-if-needed 包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED –activity-single-top 包含标志 FLAG_ACTIVITY_SINGLE_TOP –activity-clear-task 包含标志 FLAG_ACTIVITY_CLEAR_TASK –activity-task-on-home 包含标志 FLAG_ACTIVITY_TASK_ON_HOME Intent FLAG Intent 说明 –grant-read-uri-permission 包含标志 FLAG_GRANT_READ_URI_PERMISSION –grant-write-uri-permission 包含标志 FLAG_GRANT_WRITE_URI_PERMISSION –debug-log-resolution 包含标志 FLAG_DEBUG_LOG_RESOLUTION –exclude-stopped-packages 包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES –include-stopped-packages 包含标志 FLAG_INCLUDE_STOPPED_PACKAGES –receiver-registered-only 包含标志 FLAG_RECEIVER_REGISTERED_ONLY –receiver-replace-pending 包含标志 FLAG_RECEIVER_REPLACE_PENDING –selector 需要使用 -d 和 -t 选项以设置 intent 数据和类型 am用法启动页面命令行语法 旧语法 adb shell am start [options] intent 新语法 adb shell am start-activity [options] intent 参数 说明 -D 启用调试 -W 等待启动完成 -P file 类似于 –start-profiler，但当应用进入空闲状态时分析停止 -R count 重复 Activity 启动 count 次数。在每次重复前，将完成顶部 Activity -S 启动 Activity 前强行停止目标应用 启动服务 旧语法 adb shell am startservice &lt;intent&gt; 新语法 adb shell am start-service &lt;intent&gt; 启动广播 语法 adb shell am broadcast [options] intent 进程操作 参数 说明 force-stop &lt;package&gt; 强行停止与package（应用的包名称）关联的所有应用 kill [options] &lt;package&gt; 终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。 kill-all 终止所有后台进程 内存快照 命令 说明 dumpheap [options] &lt;process&gt; &lt;file&gt; 转储 process 的堆，写入 file。 -n：转储原生堆，而非托管堆。 -g: 转储之前，强制执行GC 使用基本步骤： 1、执行命令：am dumpheap com.android.calculator2 /data/local/tmp/1.hprof 2、pull到计算机：adb pull /data/local/tmp/1.hprof d:\\1 3、转换格式：hprof-conv 1.hprof 2.hprof （hprof-conv 工具位于platform-toos） 4、使用MAT打开 UID监听 watch-uids [–oom &lt;uid&gt;] 监听uid状态变化。–oom 指定监听的uid详细变化信息 用法 1234567891011121314不加参数：adb shell am watch-uids10068 idle10068 cached10068 procstate CEM seq 010068 active10068 uncached10068 procstate TOP seq 010025 procstate BFGS seq 0 &#x2F;&#x2F;以上打开10068应用10025 procstate TOP seq 010068 cached10068 procstate LAST seq 0 &#x2F;&#x2F;10068 按home键回到主屏幕10068 procstate CRE seq 010068 idle10068 gone &#x2F;&#x2F;10068从最近使用程序删除 异常监听 参数 说明 monitor 启动对崩溃或 ANR 的监控。 crash &lt;PACKAGE|PID&gt; 在指定的包或进程中引发VM崩溃","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"adb命令之logcat","slug":"adb命令--logcat","date":"2021-08-26T02:19:00.000Z","updated":"2021-08-27T14:46:12.000Z","comments":true,"path":"adb命令--logcat.html","link":"","permalink":"https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--logcat.html","excerpt":"​ Logcat 是一个adb的一个工具命令，用于转储系统消息日志。","text":"​ Logcat 是一个adb的一个工具命令，用于转储系统消息日志。 主要作用是： ​ 1、抓取保存设备引发错误时的堆栈追踪 ​ 2、抓取保存使用 Log 类编写的消息 语法adb logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 输出到电脑： adb logcat &gt; /path/filename shell链接下： logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... Android 日志缓冲区​ Android 日志记录系统是系统进程 logd 维护的一组结构化环形缓冲区。这组可用的缓冲区是固定的，并由系统定义。最相关的缓冲区为：main（用于存储大多数应用日志）、system（用于存储源自 Android 操作系统的消息）、 crash（用于存储崩溃日志）、radio(无线装置/电话相关消息)和events(事件相关消息)。每个日志条目都包含一个优先级（VERBOSE、DEBUG、INFO、WARNING、ERROR 或 FATAL）、一个标识日志来源的标记以及实际的日志消息。 查看指定缓冲区语法 adb logcat -b &lt;buffer&gt; 举例： adb logcat -b radio adb logcat -b events 缓冲区操作 命令选项 作用 -c 清除（刷新）整个缓冲区日志并退出。 -d 将缓冲区日志转储到屏幕并退出。 -g 打印指定日志缓冲区的大小并退出。 -G 设置环形缓冲区大小，单位可以为K或者M 日志过滤日志信息： 108-27 12:03:33.511 2454 2598 D MtkHotplugStatus: disable usb detect 说明： 123456日志时间：08-27 12:03:33.511UID--父进程：2454PID--进程号：2598输出级别：D输出标签：MtkHotplugStatus日志信息：disable usb detect 管道过滤windows下：adb logcat | findstr &lt;过滤字段&gt; Linux下：adb logcat | grep &lt;过滤字段&gt; 根据进程过滤 –pid=&lt;pid&gt; 只打印给定的pid日志 语法：adb logcat --pid &lt;pid&gt; 使用正则过滤 最简单的正则符号 含义 . 代表一个字符 * 代表0个和任意多个字符 例子： 1234567890，转换成正则表达可以是：.*789.*，.*678.*。 用法： -e &lt;expr&gt;, –regex=&lt;expr&gt; 打印输出通过设置perl兼容的正则表达式 例子：包含wifi字符串的日志：adb logcat -e .*wifi.* 行数时间过滤 参数选项 说明 -m &lt;count&gt; 打印指定最大行数后退出，可以和**–regex**配合使用 -t &lt;count&gt; 只打印最近的指定行数（类似-d,输出完成跳出） -t “&lt;time&gt;” 只打印指定时间之后的日志（类似 -d） -T &lt;count&gt; 只打印最近的指定行数（不同于 -d，输出完成继续实时log） -T “&lt;time&gt;” 只打印指定时间之后的日志（不同于 -d） 例子：adb logcat -t &#39;01-26 20:52:41.820&#39; adb logcat -T &#39;01-26 20:52:41.820&#39; 时间格式 MM-DD hh:mm:ss.mmm YYYY-MM-DD hh:mm:ss.mmm ssss.mmm 标签过滤 -s 设置默认的输出级别 语法： adb logcat -s &lt;tag&gt;:&lt;priority&gt; tag：感兴趣的标签 priority：优先级等于或者高于指定优先级的标签 logcat日志优先级 优先级 全称 描述 V Verbose 详细，最低优先级 D Debug 调试 I Info 信息 W Warn 警告 E Error 错误 F Fatal 致命 S Silent 静默，最高优先级，不会打印任何信息 优先级设置说明priority是最小的优先级，该标记标识的所有大于等于指定优先级的消息被写入日志。也可以在一个过滤器表达式中提供多个这样的过滤，它们之间用空格隔开。 Android 编程代码中使用日志1234567Log 类允许您在 logcat 工具中显示的代码中创建日志条目。常用的日志记录方法包括：· Log.v(String, String)（详细）· Log.d(String, String)（调试）· Log.i(String, String)（信息）· Log.w(String, String)（警告）· Log.e(String, String)（错误） 例子： 123Log.i(&quot;MyActivity&quot;, &quot;MyClass.getView() — get item number &quot; + position);logcat 输出类似于如下：I/MyActivity( 1557): MyClass.getView() — get item number 1 输出格式控制 -v &lt;format&gt; 设置日志消息的输出格式，默认值为 brief 格式有关支持的格式列表。 输出格式 格式 描述 brief 显示优先级/标记以及发出消息的进程的 PID（默认格式） process 仅显示 PID tag 仅显示优先级/标记 raw 显示原始日志消息，不显示其他元数据字段 time 显示日期、调用时间、优先级/标记以及发出消息的进程的 PID。 threadtime 显示日期、调用时间、优先级、标记以及发出消息的线程的 PID 和 TID long 显示所有元数据字段，并使用空白行分隔消息 输出对比 格式 日志 格式 元字段+日志消息 默认 03-22 14:47:38.220 630 1391 D asd_primary_out:L[0],R[0], continus 20 times! brief D/asd_primary_out( 630): L[0],R[0], continus 20 times! process D( 630)L[0],R[0], continus 20 times! (asd_primary_out) tag D/asd_primary_out: L[0],R[0], continus 20 times! raw L[0],R[0], continus 20 times! time 03-22 14:47:38.220 D/asd_primary_out( 630):L[0],R[0], continus 20 times! threadtime 03-22 14:47:38.220 630 1391 D asd_primary_out: L[0],R[0], continus 20 times! long [03-22 14:47:38.402 1364:11406 V/BroadcastQueue ] XXXXXX 统计LOG输出 -S, –statistics 输出统计量。统计缓冲区，个进程占用情况 输出内容： 日志存储转储到计算机：adb logcat &gt; d:\\log.txt 转储到手机：adb shell logcat &gt; /sdcard/log.txt 使用参数存储到手机 参数选项 说明 -f &lt;file&gt; 将日志消息输出写入 &lt;filename&gt;。默认值为 stdout -r &lt;kbytes&gt; 每输出 &lt;kbytes&gt; 时旋转日志文件。默认值为 16。需要使用 -f 选项。 -z &lt;conut&gt; 设置最大tarballs(tar压缩包)数量，默认为5 -n &lt;count&gt; 设置最大的分割日志数：count 默认为 4。需要使用 -r 选项。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"HTTP请求与响应","slug":"HTTP请求与响应","date":"2021-08-12T10:16:00.000Z","updated":"2021-08-12T10:18:38.000Z","comments":true,"path":"HTTP请求与响应.html","link":"","permalink":"https://www.lauyongyi.cn/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.html","excerpt":"​ HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）–由客户端发送用来触发一个服务器上的动作；响应（responses）–来自服务器的应答。","text":"​ HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）–由客户端发送用来触发一个服务器上的动作；响应（responses）–来自服务器的应答。 HTTP 请求和响应具有相似的结构，由以下部分组成︰ 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。 一个可选的HTTP头集合指明请求或描述消息正文。 一个空行指示所有关于请求的元数据已经发送完毕。 一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。 起始行和 HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。 HTTP请求消息(Request)客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 Http请求消息结构.png 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request：12345678910111213GET &#x2F;562f25980001b1b106000338.jpg HTTP&#x2F;1.1Host img.mukewang.comUser-Agent Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36Accept image&#x2F;webp,image&#x2F;*,*&#x2F;*;q&#x3D;0.8Referer http:&#x2F;&#x2F;www.imooc.com&#x2F;Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q&#x3D;0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request：12345678910111213POST &#x2F; HTTP1.1Host:www.wrox.comUser-Agent:Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application&#x2F;x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename&#x3D;Professional%20Ajax&amp;publisher&#x3D;Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。 第二部分：请求头部，第二行至第六行。 第三部分：空行，第七行的空行。 第四部分：请求数据，第八行。 HTTP之响应消息(Response)一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 http响应消息格式.jpg 例子 HTTP/1.1 200 OK Date: Fri, 22 May 2009 06:07:21 GMT Content-Type: text/html; charset=UTF-8 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头， Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Postman简易教程","slug":"postman简易教程","date":"2021-08-11T10:10:00.000Z","updated":"2021-08-29T07:10:00.000Z","comments":true,"path":"postman简易教程.html","link":"","permalink":"https://www.lauyongyi.cn/postman%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B.html","excerpt":"​ postman是一款跨平台的接口调试及测试工具，界面清晰，功能全面，上手简单，适合刚接触接口测试的初学者作为入门工具使用","text":"​ postman是一款跨平台的接口调试及测试工具，界面清晰，功能全面，上手简单，适合刚接触接口测试的初学者作为入门工具使用 Postman的安装到postman官网的download页面下载对应系统的版本就可以了 Postman界面 postman的工作界如上图： 其中红色框框所在的就是请求方法的选择，常用的请求方式如下： 方法 描述 GET 请求指定的页面信息，并返回实体主体 HEAD 类似GET请求，只不过返货的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求。数据被包含在请求体中。 PUT 从客户端向服务器传送数据取代指定的文档内容 DELETE 请求服务器删除指定的页面或者数据 OPTIONS 允许客户端查看服务器的性能 PATCH 是对PUT方法的补充，用来对已知资源进行局部更新 黑色框框，就是请求连接输入框。 send为请求发送按钮。 灰色的框框圈起来的大范围为功能区域，用来填写和修改键值对、请求体、请求头、测试方法等。 底部的response区域为请求响应区域，用于展示请求结果。 一个GET简单的请求百度人人都爱的测速网站，这里也可以用来做为第一个简单的接口请求演示 用于测试的时候，需要把https请求换成http，这样response里才有完整的内容返回 如上图所示，成功的请求到百度的页面内容，状态码为200，请求耗时177ms，大小297.75KB 一个简单的POST请求apishop一个API接口网站，提供各种接口（收费服务），这里就用其中一个接口用来演示。（也可以自己搭建，按需选择）。 此外postman支持将现有的接口请求转换成代码形式，如java、python、php、C#等。但断言无法被转换 简易接口测试Postman提供了一些测试功能，可以在运行接口的同时，进行一写测试校验。可以前往Postman的测试教程查看详细的说明。 Postman接口测试的模块位于主界面的Test，见下图，红色箭头所指就是Postman提供的基本测试方法，可以满足日常的测试需求 例子： 使用v2ex的节点来举例 链接如下：https://www.v2ex.com/api/nodes/show.json?name=python 判断示例如下： 12345678var jsonData = JSON.parse(responseBody);pm.test(&quot;Status code is 200&quot;, function () &#123; pm.response.to.have.status(200);&#125;);pm.test(&quot;返回值的name必须等于python&quot;, function () &#123; pm.expect(jsonData.name).to.eql(&quot;python&quot;);&#125;); 编写好之后，点击运行，就可以看到测试结果 Test脚本基于JavaScript语言，使用postman自带的Test模板（可以减少编写断言代码了）， 可以快速的生成用例。 模板 描述 示例 clear a global variable 清除全局变量 pm.globals.unset(“variable_key”); Clear an environment variable 清除一个环境变量 pm.environment.unset(“variable_key”); get a global variable 得到一个全局变量 pm.globals.get(“variable_key”); get a variable 得到一个变量 pm.variables.get(“variable_key”); Get an environment variable 得到一个环境变量 pm.environment.get(“variable_key”); response body:contains string 检查response body包含字符串 pm.test(“Body matches string”, function () { pm.expect(pm.response.text()).to.include(“string_you_want_to_search”); }); response body:convert XML body to a JSON object response body：将XML转换为JSON对象 var jsonObject = xml2Json(responseBody); response body:is equal to a string 检查响应体等于一个字符串 pm.test(“Body is correct”, function () { pm.response.to.have.body(“response_body_string”); }); response body:JSON value check 检查response body中JSON某字段值 pm.test(“Your test name”, function () { var jsonData = pm.response.json(); pm.expect(jsonData.value).to.eql(100); }); response headers:content-Type header check 检查content-Type是否包含在header返回 pm.test(“Content-Type is present”, function () { pm.response.to.have.header(“Content-Type”); }); response time is than 200ms 响应时间超过200ms pm.test(“Response time is less than 200ms”, function () { pm.expect(pm.response.responseTime).to.be.below(200); }); send s request 发送一个请求 pm.sendRequest(“https://postman-echo.com/get&quot;, function (err, response) { console.log(resp onse.json()); }); set a global variable 设置一个全局变量 pm.globals.set(“variable_key”, “variable_value”); set an environment variable 设置一个环境变量 pm.environment.set(“variable_key”, “variable_value”); status code:Code is 200 状态码：代码是200 pm.test(“Status code is 200”, function () { pm.response.to.have.status(200); }); status code:code name has string 状态码：代码中有指定字符串 pm.test(“Status code name has string”, function () { pm.response.to.have.status(“Created”); }); status code：successful POST request 状态码：成功的post请求 pm.test(“Successful POST request”, function () { pm.expect(pm.response.code).to.be.oneOf([201,202]); }); use tiny validator for JSON data 为json数据使用tiny验证器 var schema = { “items”: { “type”: “boolean” } }; var data1 = [true, false]; var data2 = [true, 123]; pm.test(‘Schema is valid’, function() { pm.expect(tv4.validate(data1, schema)).to.be.true; pm.expect(tv4.validate(data2, schema)).to.be.true; }); 常见模板用例： 状态码判断 响应文本判断 json值判断 header判断 响应时间判断 变量设置变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。 对我们做接口测试来说，又是一个非常重要的功能 。 在postman常用的三种变量分别是全局变量，环境变量，集合变量 。 全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。 环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。 集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。 其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。 想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。 定义变量（设置变量） 获取变量（访问变量） 全局和环境变量旧版本的postman，在右上角有一个齿轮的标志，点击后弹出界面，就可以根据需求定义全局变量或者环境变量了。 但在新版本中，就需要点击眼睛的标志 Environment：环境变量 Globals：全局变量 点击adb后会进入一个编辑页面，如下图 New Environment ：环境变量的名称，可以随意命名VARIAVLE: 变量名INITIAL VALUE: 共享初始值, 用于团队共享时供别人使用的默认值CURRENT VALUE: 当前值, 自己当前使用的变量值(一般我们只用设置这个值即可)Perisit All: 保持所有, 将当前自己使用的值(CURRENT VALUE)替换所有的初始值Reset All: 重置所有, 将当前所有的CURRENT VALUE重置为与当前初始值一样 添加完成后 ，点击界面上的Save或者快捷键Ctrl + s保存即可。 变量引用点击眼睛旁边的下拉菜单就可以看到刚刚添加的环境变量 点击需要使用的环境变量即可，然后在需要引用的位置上使用固定格式&#123;&#123;变量名&#125;&#125;即可。 集合变量设置点击一个集合（文件夹）的菜单，选择Edit 就会进入到集合（文件夹）的编辑页面，如下图 在这里，可以设置这个集合通用的请求参数，前置方法、断言和变量。 添加完成后，在运行该集合的接口时，可以直接调用。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}]},{"title":"接口测试","slug":"接口测试","date":"2021-08-10T15:00:00.000Z","updated":"2021-08-11T10:00:00.000Z","comments":true,"path":"接口测试.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.html","excerpt":"什么是接口和接口测试​ 接口（软件类接口）是指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。 ​ 接口测试，顾名思义：是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖关系。","text":"什么是接口和接口测试​ 接口（软件类接口）是指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。 ​ 接口测试，顾名思义：是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖关系。 ​ 其中接口协议分为HTTP,WebService,Dubbo,Thrift,Socket等类型，测试类型又主要分为功能测试，性能测试，稳定性测试，安全性测试等。 ​ 在分层测试的“金字塔”模型中，接口测试属于第二层服务集成测试范畴。相比UI层（主要是WEB或APP）自动化测试而言，接口自动化测试收益更大，且容易实现，维护成本低，有着更高的投入产出比，是每个公司开展自动化测试的首选。 ![](/images/2021/08/Interface Test/1.png) 接口测试的意义 更早的发现问题随着敏捷测试的盛行，我们都知道测试工作要尽早的介入到项目开发周期中，因为越早的发现 bug，修复的成本就越低。然而功能测试一般都要等到系统提供可测试的 UI 界面后才能进行，单元测试又要求较高的专业性和人力成本，所以选择接口测试来更早的介入测试。接口测试可以在功能界面未开发出来之前对系统的接口进行测试，从而更早的发现总是并以更低的成本修复问题。 缩短产品周期接口测试更早的介入，可以更早的发现并解决 bug，从而使得留到后期功能测试阶段的 bug 数量减少，最终缩短整个项目的上线时间，有助于实现敏捷测试。 发现更底层的问题系统中的有些 bug 如果想通过 UI 层功能测试会比较困难，或者构造测试数据和测试条件非常复杂，而通过接口测试可以更简单、更全面的覆盖到底层的代码逻辑，从而发现一些隐藏 bug。 尤其是一些异常的、极端的情况，可以用接口测试很容易的验证。 常见的接口测试工具 postman： 推荐。基本功能免费。最简单的基于http接口的调试和测试工具; jmeter：后置处理器配合断言基本上可以满足接口测试需求，就是测试报告要做二次开发 自己撸代码：推荐。配合类似xunit测试框架，基本可以满足一切需求； soapui: 收费的； insomnia：强力推荐。postman的弱化版，基本功能免费，重要的是工具代码开源，可以自己改； apifox：一款适用于 Mac 的API接口调试应用。官方介绍 Apifox = Postman + Swagger + Mock。","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.lauyongyi.cn/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}]},{"title":"monkey命令","slug":"Monkey命令","date":"2021-08-07T14:29:00.000Z","updated":"2021-08-08T07:49:42.000Z","comments":true,"path":"Monkey命令.html","link":"","permalink":"https://www.lauyongyi.cn/Monkey%E5%91%BD%E4%BB%A4.html","excerpt":"monkey 是一个运行在模拟器或者Android设备中可以产生类似用户点击、触摸、手势以及一些系统级的伪随机事件流的程序。","text":"monkey 是一个运行在模拟器或者Android设备中可以产生类似用户点击、触摸、手势以及一些系统级的伪随机事件流的程序。 为什么要用monkey？Monkey=猴子，就是像猴子一样的乱点。 目的 测试软件的稳定性，健壮性，压力。 monkey的使用monkey的基本用法adb shell monkey &lt;event&gt; 这里的&lt;event&gt;是指随机发送的事件数。 例如：发送200个随机事件，只需要运行：adb shell monkey 200。 运行结果如下图所示： monkey正常结束（即成功运行完成）后也不会停止启动的进程，设备只是在结束事件之后，简单地保持在最后那个状态下，而不会回到主界面。 帮助命令adb shell monkey -hmonkey的帮助文档，里面详细的说明了monkey的用法。 monkey命令参数monkey自带了多个可选参数，可以满足不同场景下的使用需求，基础用法是： adb shell monkey [options] &lt;events&gt; 这里的[options]是指monkey可传入的参数 日志参数运行monkey时，程序可能出现异常，这时候就需要添加日志参数 -v， -v：打印出日志信息，每一个-v将增加反馈信息的级别。-v越多，日志越详细，不过目前最多支持3个。 adb shell monkey -v -v -v 200 -v：除启动提示，测试完成和最终结果外提供较少的信息。 -v -v：提供较详细的测试信息。 -v -v -v：提供更详细的信息，如测试中被选中或微被选中的Acticity等信息。 事件类参数随机生成器在执行monkey时，如果希望重复执行之前的随机操作，可以使用-s参数。 adb shell monkey -s&lt;seed&gt; &lt;events&gt; -s 后接随机数生成器的seed值。可以是随机的任意整数。 延迟时间为了更真实的模拟用户可能的操作，执行monkey的时候，可以带上延迟时间：即每个指令之间的间隔时间。 adb shell monkey --throttle &lt;milliseconds&gt; –throttle后面接时间，单位ms。 触摸事件adb shell monkey --ptc-touch &lt;percent&gt; –ptc-touch：触摸事件。 说明：触摸事件泛指在某一位置发生的一个down-up事件。 动作事件adb shell monkey --ptc-motion &lt;percent&gt; –ptc-motion：动作事件。 说明：动作事件泛指从某一位置按下后经过一系列随机事件后弹起的操作。包括但不限于手势操作。 轨迹球事件adb shell monkey --ptc-trackball &lt;percent&gt; –ptc-trackball：接轨迹球事件。 说明：轨迹球事件包括一系列的随机移动，以及偶尔跟随在移动后面的点击事件。 基本导航事件adb shell monkey --ptc-nav &lt;percent&gt; –ptc-nav：基本导航事件。 说明： 基本导航事件是指来自方向输入设备的上、下、左、右事件。 主要导航事件adb shell monkey --ptc-majornav &lt;percent&gt; –ptc-majornav：主要导航事件。 说明： 主要导航事件是指引发图形界面的一些动作，如返回、确认、菜单键等。 系统按键事件adb shell monkey --pct-syskeys &lt;percent&gt; –pct-syskeys：系统按键事件 说明：系统按键事件指的是供系统使用的保留按键：如Home键、Back键、拨号键、挂断键、音量键等。 app启动事件adb shell monkey --pct-appswitch &lt;percent&gt; –pct-appswitch：app启动事件 说明：app启动事件，俗称打开应用，通过调用startActivity()方法，最大限度的打开package下的所有应用。 其他类型事件adb shell monkey --pct-anyevent &lt;percent&gt; –pct-anyevent：其他类型事件 说明：其他类型事件包含除了上述几个事件外的所有事件。 monkey约束类命令约束类命令可以将monkey的运行范围限制在特定范围，比如特定的包或者类。 包名限制adb shell monkey -p &lt;PackageName&gt; &lt;events&gt; -p后面接一个或者多个包名，-p &lt;PackageName&gt; 为固定形式，每个包名前都必须带 -p。 类限制adb shell monkey -c &lt;main-category&gt; &lt;events&gt; -c后面接一个或者多个类名，设置后monkey只允许系统启动这些类别中某个类别列出的Activity。同-p一样，一个-c带一个类名。如果不指定任何类别，monkey将选择Intent.CATEGORY_LAUNCHER和Intent.CATEGORY_monkey里的Activity。 例子：adb shell monkey -c Intent.CATEGORY_LAUNCHER 1000 调试类命令通过调试类命令，可以对monkey进行一些简单调试，方便快速的定位monkey运行中遇到的问题问题。 跳转监视命令adb shell monkey --dbg-no-enents &lt;events&gt; –dbg-no-events：在设置此选项后，monkey将进行初始启动，进入到某个测试Activity中不会进一步生成事件。 为了更好地跟踪，一般该选项会与-v（日志）、-p&lt;allowed-package-name&gt;（包约束）和--throttle&lt;milliseconds&gt;（延迟）等联合使用（延迟至少30s），从而提供一个可监视应用程序所调用包之间转换的环境。 分析报告生成adb shell monkey --hprof &lt;events&gt; –hprof：在设置此选项后，将在monkey事件序列前后立即生成profilfing report（分析报告）。该选项将在data/misc中生成5MB左右大小的文件，慎用！ 忽略crashesadb shell monkey --ignore-crashes &lt;events&gt; –ignore-crashes：在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。 忽略超时adb shell monkey --ignore-timeouts &lt;events&gt; –ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANP，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。 忽略权限错误adb shell monkey --ignore-security-exceptions &lt;events&gt; –ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。 忽略报错adb shell moneky --kill-process-after-error &lt;events&gt; –kill-process-after-error：在设置此选项后，当monkey因为应用程序发生错误而停止时，将会通知系统停止发生错误的进程。如果不设置此选项，在monkey停止时发生错误的应用程序将继续处于运行状态。 错误汇报adb shell monkey --monitor-native-crashes &lt;events&gt; –monitor-native-crashes：在设置此选项后，monkey运行时native code(本地代码)的崩溃事件将被监视并报告。如果不设置此选项，将不会监视此类事件。 如果此时还设置了–kill-process-after-error命令，此类崩溃（system native code）系统也将停止运行。 调试命令adb shell monkey --wait-dbg &lt;events&gt; –wait-dbg：在设置此选项后，将暂停执行中的monkey，直到有调试器与它连接。 命令实例1adb shell monkey -v -v -p com.test.testpackage --monitor-native-crashes --ignore-security-exceptions --kill-process-after-error --pct-trackball 0 --pct-nav 0 --pct-anyevent 0 --pct-appswitch 0 --pct-flip 0 --pct-majornav 10 --pct-touch 44 --pct-motion 30 --throttle 500 6000000 &gt;/sdcard/log/monkey_test.txt &amp;logcat -v time &gt; /sdcard/log/logcat.txt 总结monkey监控并特殊处理的3个事件如下。1）如果指定测试包，限制测试在指定的包中。2）如果应用crash或存在未捕获的异常，monkey停止并报告错误。3）如果应用产生ANR（Application Not Responding）错误，monkey停止并报告错误。产生ANR的两个条件如下。❑ 线程响应超过5s。❑ HandleMessage回调函数超过10s。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"安卓界面渲染检查","slug":"安卓界面渲染检查","date":"2021-07-30T15:00:00.000Z","updated":"2021-07-31T05:51:20.000Z","comments":true,"path":"安卓界面渲染检查.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A3%80%E6%9F%A5.html","excerpt":"​ Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。","text":"​ Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。 ​ Android 上的“设置”应用包含一个名为开发者选项的设置，您可以使用该屏幕配置一些系统行为来帮助您分析和调试应用性能。例如，您可以启用 USB 调试、捕获错误报告、启用点按的视觉反馈、在窗口 surface 更新时刷写 surface、使用 GPU 渲染 2D 图形，等等。 开启GPU渲染分析​ GPU 渲染模式分析工具可以显示渲染流水线的每个阶段渲染前一帧所用的相对时间。这些信息有助于您确定流水线中的瓶颈所在，从而了解应该优化哪些方面来提高应用的渲染性能。 在设备上，转到 Settings（设置） 点击 Developer Options（开发者选项）。 在 Monitoring（监控） 部分，选择 Profile GPU Rendering（HWUI呈现模式分析）。 在“HWUI呈现模式分析”对话框中，选择在屏幕上显示为竖条，以在设备的屏幕上叠加图形。 打开您要分析的应用。 在屏幕显示成条形图​ 染模式分析工具以图表（以颜色编码的直方图）的形式显示各个阶段及其相对时间。图1显示了此图表的一个示例。 下面是有关输出的几点注意事项： 对于每个可见应用，该工具将显示一个图形。 沿水平轴的每个竖条代表一个帧，每个竖条的高度表示渲染该帧所花的时间（以毫秒为单位）。 水平绿线表示 16 毫秒。要实现每秒 60 帧，代表每个帧的竖条需要保持在此线以下。当竖条超出此线时，可能会使动画出现暂停。 该工具通过加宽对应的竖条并降低透明度来突出显示超出 16 毫秒阈值的帧。 每个竖条都有与渲染管道中某个阶段对应的彩色区段。区段数因设备的 API 级别不同而异。 渲染和流畅概念​ Google 定义：界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与应用互动，应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是 60fps？）。如果应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉应用不流畅，我们将这种情况称为卡顿。 为什么是 60fps 或 16ms？​ 16ms 意味着 1000/60hz，相当于 60fps。这是因为人眼与大脑之间的协作无法感知超过 60fps 的画面更新。12fps 大概类似手动快速翻动书籍的帧率， 这明显是可以感知到不够顺滑的。24fps 使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。 24fps 是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。 但是低于 30fps 是 无法顺畅表现绚丽的画面内容的，此时就需要用到 60fps 来达到想要的效果，超过 60fps 就没有必要了。如果我们的应用没有在 16ms 内完成屏幕刷新的全部逻辑操作，就会发生卡顿。 渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。图 2 说明了显示的每种颜色所代表的含义。 图3介绍了使用运行 Android 6.0 及更高版本的设备时分析器输出中某个竖条的每个区段 使用ADB命令分析先开坑，后面再填 呈现 GPU 过度绘制过渡绘制 所谓过渡绘制，就是指一帧画面上，某一个像素区域被绘制了多次。 危害 过度绘制会浪费大量的CPU以及GPU资源，最直观的影响就是会导致APP卡顿。 呈现 GPU 过度绘制是开发者选项中的另一个功能，通过对界面进行彩色编码来帮助识别过度绘制。当应用在同一帧中多次绘制相同像素时，便会发生过度绘制。 开启步骤： 在设备上，转到 Settings（设置） 点击 Developer Options（开发者选项）。 向下滚动到硬件加速渲染部分，并选择调试 GPU 过度绘制。 在调试 GPU 过度绘制对话框中，选择显示过度绘制区域。 Android 会按照如下图所示的方式为界面元素着色，以确定过度绘制的次数： 这些颜色是半透明的，因此在屏幕上看到的确切颜色取决于界面的内容。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"常用的Git命令","slug":"常用的Git命令","date":"2021-07-23T14:37:00.000Z","updated":"2021-08-08T09:29:00.000Z","comments":true,"path":"常用的Git命令.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4.html","excerpt":"​ Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。 git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自wikipedia。","text":"​ Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。 git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自wikipedia。 安装Git在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &#39;git&#39; is currently not installed. You can install it by typing:sudo apt-get install git 如果碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; （windows推荐使用Git自带的命令行工具：GitBash，可以避免很多问题。其次文件夹尽量避免使用中文或特殊符号） ​ 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 常用的Git命令创建本地仓库123Documents % mkdir GitEx #创建一个目录Documents % cd GitEx #进入到目录GitEx % git init #把这个目录变成Git可以管理的仓库 ​ 执行之后，瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 1234567891011hint: Using &#x27;master&#x27; as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; andhint: &#x27;development&#x27;. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Initialized empty Git repository in /Users/tinenlau/Documents/GitEx/.git/ ​ 通过ls -a可以看到目录结构。如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 12GitEx % ls -a. .. .git 添加文件​ 把一个文件放入到 “GitEx” 目录下，一定要放到 “GitEx” 目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 ​ 第一步：用命令git add告诉Git，把文件添加到仓库，例如一张图片： 1GitEx % git add wallhaven-57ge21.jpeg ​ 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 ​ 第二步：用命令git commit告诉Git，把文件提交到仓库 1234GitEx % git commit -m &quot;add new pic&quot;[master (root-commit) 1983ca0] add new pic 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 wallhaven-57ge21.jpeg ​ 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 ​ 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 ​ git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的wallhaven-57ge21.jpeg文件）；0 insertions：没有插入内容（因为上传的是图片）。 ​ 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123GitEx % git add file1.txtGitEx % git add file2.txt file3.txtGitEx % git commit -m &quot;add 3 files.&quot; 总结一下 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 Git版本管理​ 在Git中，用git log命令可以显示从最近到最远的提交日志： 12345678910111213141516GitEx % git log commit 81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master)Author: &lt;&gt;Date: Sun Jul 25 20:41:42 2021 +0800 版本演示管理commit 3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774Author: &lt;&gt;Date: Sun Jul 25 20:33:02 2021 +0800 Git说明commit 1983ca011b008cda324a3c5d6da21571c8825857Author: &lt;&gt;Date: Fri Jul 23 23:41:13 2021 +0800 ​ 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数 1234GitEx % git log --pretty=oneline81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master) 版本演示管理3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774 Git说明1983ca011b008cda324a3c5d6da21571c8825857 add new pic ​ 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。 ​ 要把仓库还原到上一版本，就必须先知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 ​ 要把当前版本回退到上一个版本就可以使用git reset命令： 1234GitEx % git reset --hard HEAD^HEAD is now at 3dbfc11 Git说明GitEx % git reset --hard HEAD^HEAD is now at 1983ca0 add new pic ​ 查看文件夹的内容，从返回的结果来看，新建的文件夹被删除了。 123GitEx % ls -a. .git.. wallhaven-57ge21.jpeg ​ 用git log再看看现在版本库的状态： 1234567GitEx % git logcommit 1983ca011b008cda324a3c5d6da21571c8825857 (HEAD -&gt; master)Author: &lt;&gt;Date: Fri Jul 23 23:41:13 2021 +0800 add new pic ​ 新提交的版本已经看不到了。但在不关闭命令行窗口的前提下，还是可以还原的，方法是：找到那个需要还原版本的commit id： 12345GitEx % git reset --hard 81eca4214c46c22aHEAD is now at 81eca42 版本演示管理tinenlau@TinendeAir GitEx % ls -a. .git wallhaven-57ge21.jpeg.. readme.rtf ​ 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 用git log可以查看提交历史，以便确定要回退到哪个版本。 用git reflog查看命令历史，以便确定要回到未来的哪个版本。 暂存区工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 所以，git commit就是往master分支上提交更改。 可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 对工作区进行了文件操作，然后用git status查看一下状态： 12345678910111213 GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: readme.rtfUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) newreadme.txt readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚的显示了：readme.rtf被删除了，新增了两个文件，状态为Untracked即：没有被添加过。 分别使用git add添加新文件，然后使用git rm删除状态为delete的文件，然后再次使用git status查看状态： 1234567GitEx % git status On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: newreadme.txt deleted: readme.rtf new file: readme.txt git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。 123456789GitEx % git commit -m &quot;修改和新增多个文件&quot; [master 892a394] 修改和新增多个文件 3 files changed, 2 insertions(+), 10 deletions(-) create mode 100644 newreadme.txt delete mode 100644 readme.rtf create mode 100644 readme.txttinenlau@TinendeAir GitEx % git status On branch masternothing to commit, working tree clean 撤销修改人非圣贤孰能无过，虽然写错或者修改错了文档的情况不一定会发生，但如果发生了，又还没有提交到暂存区的时候，就可以用git checkout -- file来丢弃一些修改。 123456789101112131415161718GitEx % vi newreadme.txt GitEx % cat newreadme.txt 添加一个新的readme文档checkout 演示用GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: newreadme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)GitEx % git checkout -- newreadme.txtGitEx % cat newreadme.txt 添加一个新的readme文档% 从演示的代码可以看出，添加的内容被删除了，但原内容还在，又可以开心的搞事情了。 但是，你不小心修改或者写错了，还手贱的git add了，这时候git checkout -- file是救不了你了，这时候，不就需要用到git reset HEAD &lt;file&gt;把暂存区的修改撤销掉（unstage）。 1234567891011121314151617181920212223242526272829303132333435GitEx % vi newreadme.txt GitEx % cat newreadme.txt 添加一个新的readme文档llaklshjdakjhsdkjakjf asdhksdbkbsdfasjkfksljhdfjkshfsjdfljkshdfkljklasdjsfjksfhvoixclvn se;fksp[fcvaksdjkfvoics dv GitEx % git add newreadme.txt GitEx % git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: newreadme.txtGitEx % git reset Head newreadme.txtUnstaged changes after reset:M newreadme.txtGitEx % git status On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: newreadme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)GitEx % git checkout -- newreadme.txt GitEx % git status On branch masternothing to commit, working tree cleanGitEx % cat newreadme.txt 添加一个新的readme文档% 嘿嘿，一顿操作之后，又可以愉快的搞事情了。 小结。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 删除文件在Git中，删除也是一个修改操作，可以先模拟添加一个文件，然后将它删除。 1234567891011121314151617GitEx % touch delete.txtGitEx % git add delete.txt GitEx % git commit -m &quot;add delete.txt&quot;[master 88b28c9] add delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 delete.txttinenlau@TinendeAir GitEx % ls -a. delete.txt wallhaven-57ge21.jpeg.. newreadme.txt.git readme.txtGitEx % git logcommit 88b28c9840bd9730816437b4d4710c5e86b3a449 (HEAD -&gt; master)Author: &lt;&gt;Date: Thu Jul 29 23:45:15 2021 +0800 add delete.txt 现在有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 12345678910111213141516171819202122232425tinenlau@TinendeAir GitEx % rm delete.txt tinenlau@TinendeAir GitEx % git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: delete.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) GitEx % git rm delete.txt rm &#x27;delete.txt&#x27;GitEx % git commit -m &quot;del delete.txt&quot;[master b383f57] del delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 delete.txtGitEx % ls -a. .git readme.txt.. newreadme.txt wallhaven-57ge21.jpegtinenlau@TinendeAir GitEx % git logcommit b383f57e0ada97541d6757f918994d86c199d7bc (HEAD -&gt; master)Author: &lt;&gt;Date: Thu Jul 29 23:49:14 2021 +0800 del delete.txt 先手动删除文件，然后使用git rm 和git add效果是一样的。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 12345678910GitEx % git reset HEAD^Unstaged changes after reset:D delete.txtGitEx % git checkout delete.txtUpdated 1 path from the indexGitEx % ls -a. delete.txt wallhaven-57ge21.jpeg.. newreadme.txt.git readme.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 创建SSHkey由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 需要把youremail@example.com换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。当然了，你也可以选择设置密码，只要你不嫌麻烦。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登录GitHub或者Gitee，打开“Setting–SSH”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容就可以了。这里应该要有配图的但我懒得截图了，就这样吧。 答疑时间为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。 创建远程仓库Git的在线仓库推荐：GitHub，Gitee，还有腾讯云旗下的Coding等。 关于账号、仓库的创建可以进入这两个网站，然后按照相关指示进行操作，GitHub最好自带梯子。Gitee是国内的，可以多多支持。 关联/添加远程仓库在线Git仓库创建好之后，需要和本地原有的仓库进行关联，需要使用的命令是： git remote add origin git@github.com:[username]/[gitname].git 下面是关联远程仓库后拉取的操作过程记录： 1234567891011121314151617181920212223242526272829303132333435Documents % mkdir GitLocalDocuments % cd GitLocal GitLocal % git inithint: Using &#x27;master&#x27; as the name for the initial branch. This default branch namehint: is subject to change. To configure the initial branch name to use in allhint: of your new repositories, which will suppress this warning, call:hint: hint: git config --global init.defaultBranch &lt;name&gt;hint: hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; andhint: &#x27;development&#x27;. The just-created branch can be renamed via this command:hint: hint: git branch -m &lt;name&gt;Initialized empty Git repository in /Users/xxxxxxx/Documents/GitLocal/.git/GitLocal % ls -a. .. .gitGitLocal % git remote add origin git@gitee.com:lauyongyi/git-examples.gittinenlau@TinendeAir GitLocal % git pull origin masterhint: Pulling without specifying how to reconcile divergent branches ishint: discouraged. You can squelch this message by running one of the followinghint: commands sometime before your next pull:hint: hint: git config pull.rebase false # merge (the default strategy)hint: git config pull.rebase true # rebasehint: git config pull.ff only # fast-forward onlyhint: hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a defaulthint: preference for all repositories. You can also pass --rebase, --no-rebase,hint: or --ff-only on the command line to override the configured default perhint: invocation.From gitee.com:lauyongyi/git-examples * branch master -&gt; FETCH_HEADGitLocal % ls -a. .git README.en.md ly.txt.. .gitignore README.md 这个是关联后推送的操作记录（因为懒得操作，所以直接从网上抄的） 12345678910git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;. SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes&#x2F;no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 删除远程仓库如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm &lt;name&gt;命令。使用前，建议先用git remote -v查看远程库信息： 123GitLocal % git remote -vorigin git@gitee.com:lauyongyi/git-examples.git (fetch)origin git@gitee.com:lauyongyi/git-examples.git (push) 然后，根据名字删除，比如删除origin： 123GitLocal % git remote rm originGitLocal % git remote -v 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 远程仓库克隆现在普遍都是面向GitHub编程的。遇到好的项目时，除了Star、Fork、DownloadZip外，还可以把项目完整的克隆到本地，包括分支结构、提交信息等，比Download更全面。 克隆的命令是：git clone git@github.com:UserName/GitProjectName.git 克隆需要的连接可以从项目页面上找到，通常都在下图所示的位置 GitHub给出的地址不止一个，还可以用https://github.com/UserName/ProjectName.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 推送提交要将本地的修改同步到仓库中，就需要用到git push命令。 完整命令格式如下：git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 结合前面的 git add ,git commit，最后一步就是git push，将本地的修改同步到远端。 操作举例： 1git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 1$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。 1$ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 123$ git config --global push.default matching# 或者$ git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 1$ git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 1$ git push --force origin 上面命令使用-–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用–-force选项。 最后，git push不会推送标签(tag)，除非使用–tags选项。 1$ git push origin --tags 将当前分支推送到远程的同名的简单方法，如下 - 1$ git push origin HEAD 将当前分支推送到源存储库中的远程引用匹配主机。 这种形式方便推送当前分支，而不考虑其本地名称。如下 - 1$ git push origin HEAD:master 拉取新的内容git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂 git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]] 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，要取回origin主机的next分支，与本地的master分支合并，需要写成下面这样 - 1$ git pull origin next:master 如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为： 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。 12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 1$ git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 1$ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用–rebase选项。 1$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 分支管理一个项目在开发过程中，会有不同的阶段，可能需要不同分支来进行管理。这时候就需要用到git分支管理的功能。 创建和切换分支创建dev分支，然后切换到dev分支： 12git-examples % git checkout -b devSwitched to a new branch &#x27;dev&#x27; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev #创建分支$ git checkout dev #切换分支Switched to branch &#x27;dev&#x27; 然后，用git branch命令查看当前分支： 123git-examples % git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 123456789101112131415161718git-examples % touch dev.txtgit-examples % vi dev.txt git-examples % git add dev.txt git-examples % git commit -m &quot;dev分支首个提交&quot;[dev 6feff02] dev分支首个提交 1 file changed, 1 insertion(+) create mode 100644 dev.txtgit-examples % git push -u origin devEnumerating objects: 8, done.Counting objects: 100% (8/8), done.Delta compression using up to 8 threadsCompressing objects: 100% (7/7), done.Writing objects: 100% (8/8), 1.69 KiB | 1.69 MiB/s, done.Total 8 (delta 1), reused 4 (delta 0), pack-reused 0remote: Powered by GITEE.COM [GNK-6.0]remote: Create a pull request for &#x27;dev&#x27; on Gitee by visiting:remote: https://gitee.com/lauyongyi/git-examples/pull/new/lauyongyi:dev...lauyongyi:master dev分支的工作完成，我们就可以切换回master分支： 123456789git-examples % git checkout masterSwitched to branch &#39;master&#39;Your branch is up to date with &#39;origin&#x2F;master&#39;.git-examples % git branch dev* mastergit-examples % ls -a. .git README.en.md.. .gitignore README.md 我们把dev分支的工作成果合并到master分支上： 123456789git-examples % git merge devUpdating d1a8baf..6feff02Fast-forward dev.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 dev.txtgit-examples % ls -a. .git README.en.md dev.txt.. .gitignore README.md git merge命令用于合并指定分支到当前分支。合并后，再查看dev.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 合并完成后，就可以放心地删除dev分支了：(用完就丢，真实) 1234git-examples % git branch -d devDeleted branch dev (was 6feff02).git-examples % git branch * master switch我们注意到切换分支使用git checkout &lt;branch&gt;，而前面讲过的撤销修改则是git checkout -- &lt;file&gt;，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： 12git-examples % git switch -c devSwitched to a new branch &#39;dev&#39; 直接切换到已有的master分支，可以使用： 1234git-examples % git switch masterAlready on &#39;master&#39; dev* master 使用新的git switch命令，比git checkout要更容易理解。 小结查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt;","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"adb 命令播放音视频","slug":"adb播放音视频","date":"2021-06-26T14:50:00.000Z","updated":"2021-06-26T15:01:52.047Z","comments":true,"path":"adb播放音视频.html","link":"","permalink":"https://www.lauyongyi.cn/adb%E6%92%AD%E6%94%BE%E9%9F%B3%E8%A7%86%E9%A2%91.html","excerpt":"android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下","text":"android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下 播放音乐1adb shell am start -n com.android.music/com.android.music.MediaPlaybackActivity -d /sdcard/test.mp3 /sdcard/timian.mp3为音乐地址 或 1adb shell am start -a &quot;android.intent.action.VIEW&quot; -t &quot;audio/mp3&quot; -d &quot;file:///storage/sdcard0/Music/hello.mp3&quot; /storage/sdcard0/Music/hello.mp3为音乐地址 播放视频1adb shell am start -a android.intent.action.VIEW -d &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; /mnt/sdcard/DCIM/Camera/test.3gp为视频文件地址 或 1adb shell am start -a android.intent.action.VIEW -d &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; -n &quot;com.alensw.PicFolder/.PlayerActivity&quot; /mnt/sdcard/DCIM/Camera/test.3gp为视频文件地址 com.alensw.PicFolder/.PlayerActivity是播放器的播放页面 模拟操作对屏幕进行操作，可以用ADB命令模拟按键 12345adb shell input keyevent 24 #增加音量adb shell input keyevent 25 #降低音量adb shell input keyevent 85 #暂停/播放adb shell input keyevent 126 #恢复播放adb shell input keyevent 127 #停止播放 关闭可以采用杀死进程的方式进行 123ps -A | grep music#找到music的pidkill pid","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Mac OS 运行npm报错","slug":"Mac OS npm报错","date":"2021-06-22T15:17:00.000Z","updated":"2021-06-22T15:36:30.000Z","comments":true,"path":"Mac OS npm报错.html","link":"","permalink":"https://www.lauyongyi.cn/Mac%20OS%20npm%E6%8A%A5%E9%94%99.html","excerpt":"​ 使用Mac OS 运行npm install -g npm 出现如下图所示错误","text":"​ 使用Mac OS 运行npm install -g npm 出现如下图所示错误 报错如下： 图中，方框圈起的报错信息，主要是说没有权限，关键词：permission denied 底部椭圆圈起的内容，大概翻译一下，意思是 123permissions of the file and its containing directories, or try runningnpm ERR! the command again as root&#x2F;Administrator. 文件及其包含的目录的权限，或尝试运行npm犯错!再次以root&#x2F;管理员的身份执行该命令。 会报错是因为执行命令没有获取管理员权限，只需要在原有的命令前面加上sudo获取权限，然后回车时候需要输入管理员密码即可。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"使用python编写Uiautomator2.0脚本","slug":"Uiautomatou 2.0 python篇","date":"2021-06-19T10:29:00.000Z","updated":"2021-06-21T15:57:00.000Z","comments":true,"path":"Uiautomatou 2.0 python篇.html","link":"","permalink":"https://www.lauyongyi.cn/Uiautomatou%202.0%20python%E7%AF%87.html","excerpt":"​ 近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目Uiautomaotr2.0，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。","text":"​ 近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目Uiautomaotr2.0，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。 环境安装首先，必须确保本地安装了python环境，然后按照[README][https://github.com/openatx/uiautomator2/blob/master/README.md]的说明进行安装。 安装命令如下：pip3 install -U uiautomator2或者pip install -U uiautomator2， pip3 针对的是python2和python3共存的环境，例如自带python2.x的Mac os，Linux。 测试是否安装成功可以执行 uiautomator2 --help 脚本运行打开pycharm，新建一个工程，创建python文件 1234import uiautomator2d = uiautomator2.connect()print(d.info) 运行python文件，在控制台会有一个倒计时输出。从打印信息可以看出，是在安装需要用到的APP 12345[D 210619 18:46:21 __init__:634] kill process(ps): uiautomator[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator.apk-d3f17174fb/app-uiautomator.apk[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator.apk[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator-test.apk-652bf9e13c/app-uiautomator-test.apk[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator-test.apk 安装结束后，就会打印出连接的设备的信息 1&#123;&#x27;currentPackageName&#x27;: &#x27;net.oneplus.launcher&#x27;, &#x27;displayHeight&#x27;: 2297, &#x27;displayRotation&#x27;: 0, &#x27;displaySizeDpX&#x27;: 384, &#x27;displaySizeDpY&#x27;: 853, &#x27;displayWidth&#x27;: 1080, &#x27;productName&#x27;: &#x27;OnePlus8T_CH&#x27;, &#x27;screenOn&#x27;: True, &#x27;sdkInt&#x27;: 30, &#x27;naturalOrientation&#x27;: True&#125; 启动和停止APP运行来源于[原文档][https://github.com/openatx/uiautomator2#launch-an-app] Launch an app123456789# 默认的这种方法是先通过atx-agent解析apk包的mainActivity，然后调用am start -n $package/$activity启动d.app_start(&quot;com.example.hello_world&quot;)# 使用 monkey -p com.example.hello_world -c android.intent.category.LAUNCHER 1 启动# 这种方法有个副作用，它自动会将手机的旋转锁定给关掉d.app_start(&quot;com.example.hello_world&quot;, use_monkey=True) # start with package name# 通过指定main activity的方式启动应用，等价于调用am start -n com.example.hello_world/.MainActivityd.app_start(&quot;com.example.hello_world&quot;, &quot;.MainActivity&quot;) Stop an app1234# 相当于 `am force-stop`, 可能会丢失部分数据d.app_stop(&quot;com.example.hello_world&quot;) # 相当于 `pm clear`，清理APP相关的数据d.app_clear(&#x27;com.example.hello_world&#x27;) Stop all running apps1234# 停止所有APP的运行，但不清空后台任务d.app_stop_all()# 停止除了 com.examples.demo 以外的其他APPd.app_stop_all(excludes=[&#x27;com.examples.demo&#x27;]) 获取APP详情123456789101112info = d.app_info(&quot;com.oneplus.gallery&quot;)print(info)# expect output&#123; &#x27;packageName&#x27;: &#x27;com.oneplus.gallery&#x27;, &#x27;mainActivity&#x27;: &#x27;com.oneplus.gallery2.OPGalleryActivity&#x27;, &#x27;label&#x27;: &#x27;Gallery&#x27;, &#x27;versionName&#x27;: &#x27;4.0.180&#x27;, &#x27;versionCode&#x27;: 24190720, &#x27;size&#x27;: 137659606&#125; 打印正在运行的APP1234import uiautomator2d = uiautomator2.connect()print(d.app_list_running()) 运行结果是： 1[&#x27;net.oneplus.odm.provider&#x27;, &#x27;com.heytap.market&#x27;, &#x27;org.ifaa.aidl.manager&#x27;, &#x27;com.tencent.mm&#x27;, &#x27;com.android.cellbroadcastreceiver&#x27;, &#x27;com.numberrecognition&#x27;, &#x27;com.qualcomm.qti.workloadclassifier&#x27;, &#x27;com.oneplus.opbugreportlite&#x27;, &#x27;com.google.android.gms&#x27;, &#x27;com.oneplus.coreservice&#x27;, &#x27;com.heytap.mcs&#x27;, &#x27;com.oneplus.sound.tuner&#x27;, &#x27;com.redteamobile.virtual.softsim&#x27;, &#x27;com.oneplus.instant.local.service&#x27;, &#x27;com.oneplus.communication.sync&#x27;, &#x27;com.github.uiautomator&#x27;, &#x27;com.qualcomm.qcrilmsgtunnel&#x27;, &#x27;com.android.permissioncontroller&#x27;, &#x27;com.oneplus.orm&#x27;, &#x27;org.codeaurora.ims&#x27;, &#x27;com.oneplus.camera&#x27;, &#x27;com.android.se&#x27;, &#x27;com.android.nfc&#x27;, &#x27;com.android.settings&#x27;, &#x27;com.oneplus.gamespace&#x27;, &#x27;com.oneplus.brickmode&#x27;, &#x27;com.amap.android.location&#x27;, &#x27;com.google.android.ext.services&#x27;, &#x27;com.oneplus.config&#x27;, &#x27;com.oneplus.account&#x27;, &#x27;com.android.systemui&#x27;, &#x27;com.qualcomm.qti.devicestatisticsservice&#x27;, &#x27;com.qualcomm.qtil.aptxals&#x27;, &#x27;com.oneplus.camera.service&#x27;, &#x27;com.nearme.instant.platform&#x27;, &#x27;com.oneplus.permissionutil&#x27;, &#x27;com.oneplus.share&#x27;, &#x27;com.tencent.soter.soterserver&#x27;, &#x27;com.oneplus&#x27;, &#x27;com.google.android.providers.media.module&#x27;, &#x27;com.heytap.cloud&#x27;, &#x27;com.oneplus.screenrecord&#x27;, &#x27;com.oneplus.gallery&#x27;, &#x27;net.oneplus.weather&#x27;, &#x27;com.qualcomm.location&#x27;, &#x27;com.google.android.inputmethod.latin&#x27;, &#x27;com.android.cellbroadcastservice&#x27;, &#x27;com.qualcomm.qti.telephonyservice&#x27;, &#x27;com.android.providers.calendar&#x27;, &#x27;com.oneplus.camera.pictureprocessing&#x27;, &#x27;com.oneplus.mms&#x27;, &#x27;com.android.vending&#x27;, &#x27;com.android.phone&#x27;, &#x27;com.dolby.daxservice&#x27;, &#x27;net.oneplus.launcher&#x27;, &#x27;com.oneplus.voicewakeup&#x27;, &#x27;com.qualcomm.qti.uim&#x27;, &#x27;com.heytap.openid&#x27;] 等待指定app运行1234567891011import uiautomator2d = uiautomator2.connect()pid = d.app_wait(&quot;com.oneplus.camera&quot;)if not pid: print(&quot;com.oneplus.camera is not running&quot;)else: print(&quot;com.oneplus.camera pid is %d&quot; % pid)d.app_wait(&quot;com.oneplus.camera&quot;, front=True) # 等待应用前台运行# d.app_wait(&quot;com.oneplus.camera&quot;, timeout=20.0) #app_wait 默认等待时间就是20s 运行结果如下 1234com.oneplus.camera pid is 5577 #app运行时的打印com.oneplus.camera is not running #app没有运行时的打印","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"Fiddler的使用","slug":"Fiddler 过滤","date":"2021-06-04T14:37:00.000Z","updated":"2021-06-14T07:26:00.000Z","comments":true,"path":"Fiddler 过滤.html","link":"","permalink":"https://www.lauyongyi.cn/Fiddler%C2%A0%E8%BF%87%E6%BB%A4.html","excerpt":"​ 使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能Filters。","text":"​ 使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能Filters。 User Filters启用​ 一般情况下，User Filter 是没有启动，状态如下图所示 点击选择后，状态变成已启用，如下图所示 Action的功能Action：Run Filterset now是否运行，Load Filterset加载，Save Filterset保存； Hosts 过滤Zone：指定只显示内网（Intranet）或互联网（Internet）的内容； Host：指定显示某个域名下的会话； -No Host Filter：无HOST过滤；Hide the following Hosts：隐藏以下HOST；Show only the following Hosts：仅显示以下HostsFlag the following Hosts：标记以下HOST；输入多个HOST，多个之前用 ; 或 , 或 回车键 分隔；支持通配符如：*,baidu.com； 步骤：选择Hosts—&gt;输入过滤条件单条件ir.baidu.com或多条件ir.baidu.com;www.baidu.com或通配符*.baidu.com—&gt;Changes not yet saved—&gt;选择Ations中Run Filterset now； Client Process 过滤客户端进程过滤规则： Show only traffic from：你可以指定只捕获哪个Windows进程中的请求； Show only Internet Explorer traffic：只显示IE发出的请求； Hide Windows RSS platform traffic：隐藏Windows RSS平台发出的请求； Request Headers 过滤Request header过滤规则： 经常使用：Show only if URL contains：只显示包含特定字符的请求； Hide if URL contains：隐藏包含特定字符的请求； Flag requests with headers：标记带有特定header的请求； Delete request headers：删除请求header； Set request header：设置请求的header； Breakpoints断点设置规则： Break request on HTTP POST：给所有POST请求设置断点； Break request on HTTP GET with QueryString：给所有带参数的GET请求设置断点； Break on XMLHttpRequest：给所有XML请求设置断点； Break response on Content-Type：给包含特定的Content-Type返回设置断点； Response Status Code 过滤响应HTTP状态过滤规则： Hide success(2xx)：隐藏响应成功的session(2xx)； Hide Authentication demands(401,407)：隐藏未经授权被拒绝的session(401,407； Hide redirects(300,301,302,303,307)：隐藏重定向的session(300,301,302,303,307)； Hide Not Modified(304)：隐藏无变更的session(304)； Response HeadersResponse header过滤规则： Flag response that set cookies：标记会设置cookie的响应； Flag response with headers：标记带有特定header的响应； Delete response headers：删除响应header； Set response header：设置响应的header； Response Type and Size响应类型和大小过滤规则： Show all Content-Type：显示所有响应类型； Hide smaller than ？KB：隐藏小于指定大小的session； Hide larger than ？KB：隐藏大于指定大小的session； Time HeatMap：获得即时数据（绿色阴影代表响应时间在50毫秒以内；超过50毫秒但在300毫秒之内的响应条目没有颜色；响应时间在300至500毫秒之间的会涂以黄色；超过500毫秒的用红色底纹显示）； Block script files：阻止脚本文件，显示为404； Block image files：阻止图片文件； Block SWF files：阻止SWF文件； Block CSS files：阻止CSS文件； 鼠标右键菜单过滤功能","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"常见的运行异常","slug":"常见的运行异常","date":"2021-05-28T15:37:00.000Z","updated":"2021-06-18T15:37:00.000Z","comments":true,"path":"常见的运行异常.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8.html","excerpt":"​ 安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。","text":"​ 安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。 NullPointerException（空指针异常）​ 俗称NPE。调用了未经初始化的对象或者是不存在的对象。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 目前，客户端页面显示很多需要依赖服务端返回数据，当网络异常时，没有获取到对象，此时为null，就很容易出现nullpointerException异常。有可能也是代码错误，没有new造成的。 如何检测java.lang.NullPointerException检测NullPointerException非常简单，只需查看异常跟踪，它将显示异常的类名和行号。然后查看代码并查看可能为null。只要看一下上面的所有例子，从堆栈跟踪中可以清楚地看出是什么导致了null指针异常。 错误示例1. 调用实例方法时出现NullPointerException 示例代码 - 123456789101112131415161718public class Temp &#123; public static void main(String[] args) &#123; Temp t = initT(); t.foo(&quot;Hi&quot;); &#125; private static Temp initT() &#123; return null; &#125; public void foo(String s) &#123; System.out.println(s.toLowerCase()); &#125;&#125; 当运行上面的程序时，它会抛出NullPointerException异常错误消息。 123Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 在语句t.foo(&quot;Hi&quot;)中抛出NullPointerException异常; 因为t在这里为null。 2. 访问/修改null对象的字段时出现NullPointerException 示例代码 - 123456789101112131415161718public class Temp &#123; public int x = 10; public static void main(String[] args) &#123; Temp t = initT(); int i = t.x; &#125; private static Temp initT() &#123; return null; &#125;&#125; 执行上面示例代码，得到以下结果 - 123Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:9) 语句int i = t.x中抛出NullPointerException异常; 因为t在这里为null。 3. 在方法参数中传递null时NullPointerException 示例代码 - 123456789101112public class Temp &#123; public static void main(String[] args) &#123; foo(null); &#125; public static void foo(String s) &#123; System.out.println(s.toLowerCase()); &#125;&#125; 这是java.lang.NullPointerException最常见的情况之一，因为它传递null参数给调用者。错误信息如下： 123Exception in thread &quot;main&quot; java.lang.NullPointerException at NPE.foo(NPE.java:9) at NPE.main(NPE.java:4) 4. 抛出null时抛出java.lang.NullPointerException 示例代码 12345public class Temp &#123; public static void main(String[] args) &#123; throw null; &#125;&#125; 下面是上面程序的异常堆栈跟踪，由于throw null所以抛出NullPointerException异常。 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:5) 5. 获取null数组的长度时抛出java.lang.NullPointerException 1234567public class Temp &#123; public static void main(String[] args) &#123; int[] data = null; int len = data.length; &#125;&#125; 执行上面示例代码，得到以下结果 - 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 6. 访问null数组的索引值时出现NullPointerException 示例代码 - 1234567public class Temp &#123; public static void main(String[] args) &#123; int[] data = null; int len = data[2]; &#125;&#125; 执行上面示例代码，得到以下结果 - 12Exception in thread &quot;main&quot; java.lang.NullPointerException at Temp.main(Temp.java:7) 7. 在null对象上同步时出现java.lang.NullPointerException 1234567891011public class Temp &#123; public static String mutex = null; public static void main(String[] args) &#123; synchronized(mutex) &#123; System.out.println(&quot;synchronized block&quot;); &#125; &#125;&#125; synchronized(mutex)将抛出NullPointerException，因为mutex对象为null。 8. java.lang.NullPointerException引发HTTP状态500 有时会将错误页面作为java Web应用程序响应发送，错误消息为“HTTP状态500 - 内部服务器错误”，根本原因就是java.lang.NullPointerException异常。 下面是一段编辑了Spring MVC Example项目并更改了HomeController方法，如下所示。 12345678@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) public String user(@Validated User user, Model model) &#123; System.out.println(&quot;User Page Requested&quot;); System.out.println(&quot;User Name: &quot;+user.getUserName().toLowerCase()); System.out.println(&quot;User ID: &quot;+user.getUserId().toLowerCase()); model.addAttribute(&quot;userName&quot;, user.getUserName()); return &quot;user&quot;; &#125; 下图显示了Web应用程序响应引发的错误消息。 下面是异常堆栈跟踪 - 12345678910111213141516171819202122232425HTTP Status 500 – Internal Server ErrorType Exception ReportMessage Request processing failed; nested exception is java.lang.NullPointerExceptionDescription The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionorg.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:982) org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) javax.servlet.http.HttpServlet.service(HttpServlet.java:661) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) javax.servlet.http.HttpServlet.service(HttpServlet.java:742) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.NullPointerException com.journaldev.spring.controller.HomeController.user(HomeController.java:38) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:498) 根本原因是语句user.getUserId().toLowerCase()中引发了NullPointerException，因为user.getUserId()返回null。 解决方案​ 这种异常通常是调用一个对象的接口方法抛出的，在调用接口方法之前，要进行判空或者进行try-catch，这样基本可以规避大部分空指针异常。​ 最常见是在 回调接口, 如 网络请求回调，第三方登录回调 返回的时候 调用 context.startActivity 时 context 为空导致。可以在 context 为空的时候使用 Application Context， 加上 if (!(context instanceof Activity)) { intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); } ArrayindexOutOfBoundsExceptions（数组越界异常）出现的原因​ 如果访问数组元素的时候，索引编号并不存在 错误示例 使用不合法的索引访问数组时会报数组越界这种错误，数组arr的合法错误范围是[0, arr.length-1];当你访问这之外的索引时会报这个错。例如： 12345678public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3&#125;; for (int i = 0; i &lt;= arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 控制台输出的错误提示： 1234567java.lang.ArrayIndexOutOfBoundsException: 3at Test.main(Test.java:5)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)at java.lang.reflect.Method.invoke(Method.java:606)at edu.rice.cs.drjava.model.compiler.JavacCompiler.runCommand(JavacCompiler.java:272) 解决方案​ 这种情况一般要在数组循环前做好length判断，index超出length上限和下限时都会报错。举例如下：一个数组int test[N]，一共有N个元素分别是test[0]~test[N-1]，如果调用test[N]，将会报错。建议读取时，不要超过数组的长度（array.length）。参考链接Android中一种常见情形就是上拉刷新中header也会作为listview的第0个位置，如果判断失误很容易造成越界。 indexOutOfBoundsException（越界异常）出现的原因​ 该异常表示不合法下标，通常是因为访问了list不合法的位置，建议检查数据是否越界。 解决方案 1.遍历数组/字符串等集合前，要判断遍历对象的长度； 2.操作数组/字符串等集合前，要检查角标是否在长度允许范围内； 3.ListView操作不当也会引起该异常，这种情况下一般是由于List渲染的时候，外面的数据源发生变化导致的。举例如ListView滚动时点击刷新将会报错，解决方法是ListView滚动时将刷新置为不可点击。 outOfMemory（内存溢出）​ 指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存，俗称OOM 出现的原因​ （1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；​ （2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；​ （3）代码中存在死循环或循环产生过多重复的对象实体；​ （4）使用的第三方软件中的BUG；​ （5）启动参数内存值设定的过小； ​ 通俗解释：系统已经不能再分配出你所需要的空间，比如系统现在只有1G的空间，但是你偏偏要2个G空间，这就叫内存溢出 例子：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。 常见错误提示​ [相关例子说明][https://segmentfault.com/a/1190000017226359] ​ 1、OOM fo heap ：java.lang:OutOfMemoryError: Java heap space，此OOM是由于JVM中heap的最大值不满足需要，将设置heap的最大值调高即可。 ​ 2、OOM for Perm：java.lang:OutOfMemoryError: Java perm space，此OOM是由于JVM中perm的最大值不满足需要，将设置perm的最大值调高即可，参数样例为：-XX:MaxPermSize=512M ​ 3、OOM for GC=&gt;例如：java.lang:OutOfMemoryError: GC overhead limit exceeded，此OOM是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略 ​ 4、OOM for native thread created：java.lang.OutOfMemoryError: unable to create new native threa，此OOM是由于进程剩余的空间不足，导致创建进程失败 ​ 5、OOM for allocate huge array：Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: Requested array size exceeds VM limit，此类信息表明应用程序（或者被应用程序调用的APIs）试图分配一个大于堆大小的数组 ​ 6、OOM for small swap：Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?,抛出这类错误，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽 ​ 7、OutOfMemoryError： thrown while trying to throw OutOfMemoryError; no stack trace available，抛出这类错误，一般是由于方法重复调用、死循环引起，直至内存耗尽 内存泄漏： (Memory Leak)​ 指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 以产生的方式来分类，内存泄漏可以分为四类：（1）常发性内存泄漏：发生内存泄漏的代码会被多次执行到，每次被执行时都会导致一块内存泄漏。（2）偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。（3）一次性内存泄漏：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏。（4）隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。 memory leak会最终会导致out of memory！ 内存泄漏和内存溢出的相关说明例子：[博客园][https://www.cnblogs.com/xiaoxi/p/7354857.html]，[百度百科：内存泄漏][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA]，[百度百科：内存溢出][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F] 拓展知识​ jvm管理的内存大致包括三种不同类型的内存区域：Permanent Generation space（永久保存区域）、Heap space(堆区域)、Java Stacks(Java栈）。其中永久保存区域主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGen space区域，Class需要存储的内容主要包括方法和静态属性。堆区域用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。而Java栈跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。\u0010 illegalStateException（非法状态异常）常见错误提示java.lang.IllegalStateException：Cannot forward a response that is already committed IllegalStateException：response already commited IllegalStateException：getOutputStream() has already been called for this request 出现原因 ​ 该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。 ​ 这里涉及到java的io流：flush()，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中，然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行清空输出，因此flush()的作用就是保证缓存清空输出。 response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。 illegalArguementException（非法参数异常）常见错误提示 java.lang.IllegalArgumentException 出现原因​ 参数不匹配异常，通常由于传递了不正确的参数导致。 常见于： Activity、Service状态异常； 非法URL； UI线程操作 Fragment中嵌套了子Fragment，Fragment被销毁，而内部Fragment未被销毁，所以导致再次加载时重复，在onDestroyView() 中将内部Fragment销毁即可 在请求网络的回调中使用了glide.into(view),view已经被销毁会导致该错误 解决方法​ 因为参数不合法导致抛出IllegalArgumentException，请根据堆栈信息描述的出错的函数参数，按照要求传入正确的参数。 举例错误堆栈信息 123456789101112131415161718192021java.lang.IllegalArgumentException: Cannot locate declared field class org.apache.http.impl.client.HttpClientBuilder.sslContext at org.apache.commons.lang3.Validate.isTrue(Validate.java:155) at org.apache.commons.lang3.reflect.FieldUtils.readDeclaredField(FieldUtils.java:512) at com.gargoylesoftware.htmlunit.HttpWebConnection.getField(HttpWebConnection.java:1095) at com.gargoylesoftware.htmlunit.HttpWebConnection.createConnectionManager(HttpWebConnection.java:1017) at com.gargoylesoftware.htmlunit.HttpWebConnection.getResponse(HttpWebConnection.java:174) at com.gargoylesoftware.htmlunit.WebClient.loadWebResponseFromWebConnection(WebClient.java:1397) at com.gargoylesoftware.htmlunit.WebClient.loadWebResponse(WebClient.java:1315) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:394) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:315) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:463) at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:448) at com.epoint.dzdamanager.login.DnetDefaultLoginForUrlImpl.doLogin(DnetDefaultLoginForUrlImpl.java:87) at com.epoint.ztb.htmlutil.HtmlToPdf.getHtmlPageFromUrlF9(vb:80) at com.epoint.dzdamanager.domain.DownZtbData.pageToPdf(DownZtbData.java:446) at com.epoint.dzdamanager.domain.DownZtbData.genFileList(DownZtbData.java:319) at com.epoint.dzdamanager.domain.DownZtbData.workForBarStep(DownZtbData.java:152) at com.epoint.dzdamanager.pack.job.DoPackServiceImp.doPack(DoPackServiceImp.java:87) at com.epoint.dzdamanager.pack.job.DoPackJob.execute(DoPackJob.java:35) at org.quartz.core.JobRunShell.run(JobRunShell.java:202) at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) 例子分析重点提示Cannot locate declared field class org.apache.http.impl.client.HttpClientBuilder.sslContext经排查，htmlunit.jar包在4.4.1版本中HttpClientBuilder该类无sslContext属性，属性名称为sslcontext，从而引发参数报错。 ClassCastException（类型强制转换异常）常见错误提示java.lang.ClassCastException 出现原因​ 当试图将对某个对象强制执行向下转型，但该对象又不可转换为其子类的实例时将引发该异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。例子 java.lang.ArithmeticException （算术条件异常）​ 异常算术条件时抛出。 例如，“除以零”的整数会抛出。 错误示例123456789public class EXDemo &#123; public static void main(String[] args)&#123; int x = 10; int y = 0; int temp = x/y; //此处出现异常 System.out.println(x/y); System.out.println(&quot;计算结束&quot;); &#125;&#125; 运行结果如下： 12Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at EXDemo.main(EXDemo.java:5) 在以上例子中,因为被除数为0,所以程序中出现了异常,从运行结果可以发现,如果不对异常进行处理,则一旦出现了异常后,程序就立刻推出,所以后面的语句并没有打印输出. 在计算机的发展中有两大计算机”杀手”,一个是断电,另外一个是被除数为0;因为被除数为0在数学上的解是无穷大,对于计算机来说,意味着内存将被全部占满.","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"adb shell am 命令解析","slug":"adb命令--pm ","date":"2021-05-16T02:42:00.000Z","updated":"2021-08-28T15:01:00.000Z","comments":true,"path":"adb命令--pm .html","link":"","permalink":"https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--pm%20.html","excerpt":"​ pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。","text":"​ pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。 基本语法 说明 用法 输出到电脑 adb shell pm &lt;command&gt; shell连接执行 pm &lt;command&gt; 例子 adb shell am list packages 包名信息查询包状态分类安卓系统中，包的状态分为：停用、启用、系统、三方和卸载 语法：list packages [options] [filter] 参数 说明 filter 过滤文字，仅输出包名称包含 filter 中的文本的软件包 -f 查看它们的关联文件 -d 进行过滤以仅显示已停用的软件包 -e 进行过滤以仅显示已启用的软件包 -s 进行过滤以仅显示系统软件包 -3 进行过滤以仅显示第三方软件包 -i 查看软件包的安装程序 -u 包括卸载的软件包 权限查询​ 权限（Permission），顾名思义是一种对信息访问的申请。Android的权限有上百种，例如应用程序尝试调用拨号权限、调用摄像头权限、调用读取短信权限、调用读取通讯录权限等等。对于这些权限，Android将其按照危险等级进行了划分分组，分成如下的三种类别： 正常权限（PROTECTION_NORMAL）：指的是应用程序需要访问的一些数据资源，但并不涉及到用户的隐私或者对其他应用程序无害。例如设置闹钟就是属于正常权限。Android在处理正常权限时并不会提示用户，而用户也没有办法取消这些正常权限 签名权限（PROTECTION_SIGNATURE）：指的是Android在安装时授予应用程序的权限，利用签名权限，两个签名相同的应用程序就可以进行安全的数据共享。 危险权限（PROTECTION_DANGEROUS ）：指的是直接触碰到用户隐私或者影响其他程序操作的权限，对于这一类的权限，Android会以弹窗的方式向用户进行问询，应用程序必须要经过用户的授权后才可以进行相应的行为。 危险权限组 权限查询语法基本语法： adb shell pm list permission-groups，输出所有已知的权限组。 list permissions [options] group，输出所有已知的权限，或者，仅输出 group 中的权限。 参数 说明 group 仅输出 group 中的权限 -g 按组加以组织 -f 输出所有信息 -s 简短摘要 -d 仅列出危险权限 -u 仅列出用户将看到的权限 权限授权取消权限授权语法grant &lt;package_name&gt; &lt;permission&gt; 说明：向应用授予权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。 权限撤销语法revoke &lt;package_name&gt; &lt;permission&gt; 说明：从应用中撤销权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。 重置权限语法reset-permissions 说明：重置所有运行时权限到默认最初的默认状态 安装与卸载安装应用语法：adb shell pm install [options] &lt;path&gt;，作用同adb install 参数 说明 path 安装包路径 -r 重新安装现有应用，保留其数据 -d 允许版本代码降级 卸载应用语法：adb shell pm uninstall [options] &lt;package&gt;，作用同adb uninstall 参数 说明 package 需要卸载的应用包名 -k 移除软件包后保留数据和缓存目录 启停隐显应用停用/启用应用 停用语法 disable 说明 停用给定软件包或组件 启用语法 enable 说明 停用给定软件包或组件 隐藏/显示应用 隐藏语法 hide 说明 停用给定软件包或组件 显示语法 unhide 说明 停用给定软件包或组件 挂起/解冻应用 挂起语法 suspend &lt;TARGET-PACKAGE&gt; 说明 挂起指定应用 解冻语法 unsuspend &lt;TARGET-PACKAGE&gt; 说明 解冻指定应用 清除数据 语法 clear &lt;package&gt; 说明 删除与软件包关联的所有数据 other 参数 说明 list instrumentation [options] 列出所有测试软件包。 list features 输出系统的所有功能。 list libraries 输出当前设备支持的所有库。 list users 输出系统上的所有用户。 path package 输出给定 package 的 APK 的路径","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Crash详解","slug":"Crash详解","date":"2021-05-10T13:59:00.000Z","updated":"2020-05-10T14:14:00.000Z","comments":true,"path":"Crash详解.html","link":"","permalink":"https://www.lauyongyi.cn/Crash%E8%AF%A6%E8%A7%A3.html","excerpt":"Android APP Crash通常是由未捕获的Exception或signal引起app异常退出。","text":"Android APP Crash通常是由未捕获的Exception或signal引起app异常退出。 如果app使用Java语言编写，那么，当Throwable抛出未处理的异常时，此时就会引起 app Crash。 如果app 使用native-code编写，那么，当执行时遇到未处理的signal（例如SIGSEGV）时，app就会 Crash并退出。 当应用程序崩溃时，Android终止应用程序的进程并显示一个对话框，让用户知道应用程序已经停止。如下图。 App Crash 不仅发生在前台进程，任何app组件，例如Broadcast Receivers,Content Providers,Service等在后台运行的组件，也可以引起App Crash。这些Crash很容易引起用户混淆，因为他们没有直接参与到你的app中。 分析App Crash解决崩溃可能很困难。 但是，如果您能够确定崩溃的根本原因，则很可能可以找到解决方案。 有很多情况可能会导致应用程序崩溃。 一些原因是显而易见的，比如检查一个空值或空字符串，而另外一些更微妙，比如将无效参数传递给API甚至是复杂的多线程交互。 读取堆栈信息解决App Crash，首先要找到在那些代码发生的。你可以通过logcat或者收集工具如play Console，bugly等输出的堆栈信息进行分析查看。 下面是一个Crash示例： 123456789101112131415--------- beginning of crash AndroidRuntime: FATAL EXCEPTION: main Process: com.android.developer.crashsample, PID: 3686 java.lang.NullPointerException: crash sample at com.android.developer.crashsample.MainActivity$1.onClick(MainActivity.java:27) at android.view.View.performClick(View.java:6134) at android.view.View$PerformClick.run(View.java:23965) at android.os.Handler.handleCallback(Handler.java:751) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:156) at android.app.ActivityThread.main(ActivityThread.java:6440) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:746) --------- beginning of system 上述Crash 堆栈信息包含 以下信息 1.Crash app 包名 2.Crash app PID 3.引起Crash的异常信息（此异常时引起Crash的重要原因） 4.引起Crash 的代码位置，行号，哪个函数调用等等 5.对于被调用的每个函数，另一行显示前面的调用站点（称为栈帧）。 通过走栈和检查代码，你可能会发现一个地方传递了一个不正确的值。 如果您的代码没有出现在堆栈跟踪中，则可能是在某处将异常操作传递给了一个无效的参数。 您可以经常通过检查堆栈跟踪的每一行，找到您使用的任何API类，并确认您传递的参数是正确的，并且从允许的地方调用该类来判断发生了什么。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"Android Uiantomator2.0脚本编写基础知识","slug":"Android Uiantomator2.0脚本编写基础","date":"2021-03-10T12:16:00.000Z","updated":"2021-06-18T10:33:00.000Z","comments":true,"path":"Android Uiantomator2.0脚本编写基础.html","link":"","permalink":"https://www.lauyongyi.cn/Android%20Uiantomator2.0%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80.html","excerpt":"UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。","text":"UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。 UiautomatorViewer工具​ uiautomatorviewer是android SDK自带的一个元素定位工具。通过截屏并分析XML布局文件的方式，为用户提供控件信息查看服务。使用uiautomatorviewer，你可以检查一个应用的UI来查看应用的布局和组件以及相关的属性。该工具位于SDK目录下的tools\\bin子目录下。 启动UiUiautomatorViewer​ 方法一：直接进入进入SDK目录下的tools\\bin目录下双击uiautomatorviewer.bat就可以启动。（旧版本的在SDK目录下的tools） ​ 方法二：将环境变量配置到SDK目录下的tools\\bin目录，在命令行工具执行：uiautomatorviewer 核心定位元素 属性 描述 resource-id 资源ID，需要操作的组件基本都会有ID text 文字属性，显示在组件上的文字 content-desc 描述，常用于提示操作 checken 选择属性，常见开关、单/复选和开关状态 focused 焦点属性，如输入框光标的闪动，说明焦点在输入框 搜索对象 属性 返回值 API By类 resource-id static BySelector res(java.lang.String resourceName) text static BySelector text(java.lang.String text) content-desc static BySelector decs(java.lang.String contentDescription) checken static BySelector checked(boolean isChecked) focused static BySelector focused(boolean isFocused) 常见组件操作 常见组件操作 类（UiObject2） 点击 public boolean click() 长按 public boolean longclick() 拖动 public void drag(Point dest) 输入 public boolean setText(String text) 常见设备操作 常见设备操作 类（UiDevice） 点击 click(int x, int y) 按键 pressKeyCode(int KeyCode) 滑动 swipe(int startX, int StartY, int endX, int endY, int steps) 1个steps等于5ms。 用例注释生命周期@Before 每次用例开始前都执行 @Test 测试用例 @After 每次用例结束后都执行","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"安卓shell脚本","slug":"安卓Shell脚本","date":"2021-02-15T09:30:00.000Z","updated":"2021-02-16T06:39:00.000Z","comments":true,"path":"安卓Shell脚本.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93Shell%E8%84%9A%E6%9C%AC.html","excerpt":"​ 在做测试Android应用时，经常需要执行某些重复的操作，如果设备支持adb调试，可以使用python、java等编写自动化脚本，以实现自动执行重复操作，解放人力。但如果遇到不支持ADB调试的设备时，只能使用串口工具，此时python、java就显得些乏力，这时候，就可以使用shell脚本。","text":"​ 在做测试Android应用时，经常需要执行某些重复的操作，如果设备支持adb调试，可以使用python、java等编写自动化脚本，以实现自动执行重复操作，解放人力。但如果遇到不支持ADB调试的设备时，只能使用串口工具，此时python、java就显得些乏力，这时候，就可以使用shell脚本。 1、脚本编写 ​ 安卓的shell脚本编写和Linux系统一样。但因为机制原因，要执行shell脚本，需要到/data目录下才可以。 ​ 使用串口工具链接设备和电脑。 ​ 选择端口 ​ 进入到设备 ​ su获取权限 ​ cd /data 进入到data目录 ​ vi shellscript.sh 12345678910111213#示例脚本。模拟打开一个应用，然后发送指定键值进行操作#!/system/bin/shwhile truedo&#123; am start PackageName input keyevent KeyCode input keyevent KeyCode input keyevent KeyCode sleep 3 am force-stop PackageName&#125;done ​ 按 Esc #进入vi命令模式 ​ 输入 :wq #写入并退出 ​ chmod 777 shellscript.sh #赋予权限 ​ ./shellscript.sh #执行脚本","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Centos安装Tomcat","slug":"Centos安装Tomcat","date":"2021-01-22T05:02:00.000Z","updated":"2021-01-22T05:30:00.000Z","comments":true,"path":"Centos安装Tomcat.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85Tomcat.html","excerpt":"​ 记录centos安装Tomcat的方法和配置过程","text":"​ 记录centos安装Tomcat的方法和配置过程 前提条件：已经配置好jdk环境 方法一：yum​ 可以直接使用 yum -y install tomcat 进行安装 优点： ​ 省事 缺点： ​ 不一定是最新版本 安装成功后，需要配置防火墙 firewall-cmd --zone=public --add-port=8080/tcp --permanent 进行8080端口开放配置； 如果没有出现 success （一般都是提示防火墙没有运行） ，就需要检查防火墙是否开启 防火墙开启命令 systemctl start firewalld ，防火墙开启之后，在进行配置，然后重启防火墙，命令如下 firewall-cmd --reload。防火墙重启之后，就可以通过IP:8080进行访问了。 通常，这个时候访问，提示无法访问，原因是缺少管理包，执行以下命令，安装成功之后，就可以正常访问了。 yum install -y tomcat-webapps tomcat-admin-webapps Tomcat相关的操作命令如下： 1234567891011121314151617查看tomcat的状态systemctl status tomcat.service配置开机启动systemctl enable tomcat.service删除开机启动systemctl disable tomcat.service启动tomcatsystemctl start tomcat.service停止tomcatsystemctl stop tomcat.service重启tomcatsystemctl restart tomcat.service 关于安装目录说明： 123456相关目录及作用说明 &#x2F;etc&#x2F;tomcatXX - 全局配置 &#x2F;usr&#x2F;share&#x2F;tomcatXX&#x2F; - 程序主目录 &#x2F;usr&#x2F;share&#x2F;tomcatXX&#x2F;conf&#x2F;Catalina&#x2F;localhost&#x2F; - 本机部署的 Catalina 配置 &#x2F;var&#x2F;lib&#x2F;tomcatXX&#x2F; - 工作主目录 &#x2F;var&#x2F;lib&#x2F;tomcatXX&#x2F;webapps - （应用文件实际存放于此） 方法二：手动安装配置​ 进入到一个目录下例如 cd /usr/local/ ，然后执行下载命令 wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.41/bin/apache-tomcat-9.0.41.tar.gz 这里用的是9.0版本，可以自己调整版本。 然后解压 tar -zxvf apache-tomcat-9.0.41.tar.gz 重命名 mv apache-tomcat-9.0.41 tomcat 然后启动就可以了 tomcat常用命令 12345&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;startup.sh(启动命令)&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;bin&#x2F;shutdown.sh(关闭命令)ps -ef|grep java(查看tomcat进程)kill -9 进程号(杀死经常)tail -f &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;logs&#x2F;catalina.out(查看tomcat日志)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"python基础--列表、字符串、字典、元组之间的转换","slug":"python基础--列表、元组等转换","date":"2021-01-05T08:14:00.000Z","updated":"2021-01-14T06:08:00.000Z","comments":true,"path":"python基础--列表、元组等转换.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E7%AD%89%E8%BD%AC%E6%8D%A2.html","excerpt":"列表与字符串的相互转换列表转字符串将列表中的元素用特定的符号连接成一个字符串： 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; str1 = &#x27;&#x27;.join(list1)&gt;&gt;&gt; str1&#x27;abc&#x27;&gt;&gt;&gt; str2 = &#x27;-&#x27;.join(list1)&gt;&gt;&gt; str2&#x27;a-b-c&#x27;","text":"列表与字符串的相互转换列表转字符串将列表中的元素用特定的符号连接成一个字符串： 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; str1 = &#x27;&#x27;.join(list1)&gt;&gt;&gt; str1&#x27;abc&#x27;&gt;&gt;&gt; str2 = &#x27;-&#x27;.join(list1)&gt;&gt;&gt; str2&#x27;a-b-c&#x27; 列表中如果包含有其它元素，可以采用以下形式 12345678&gt;&gt;&gt; list3 = [&#x27;a&#x27;,1,2,&#x27;b&#x27;]&gt;&gt;&gt; str3 = [str(i) for i in list3]&gt;&gt;&gt; str3[&#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; list4 = [&#x27;a&#x27;,1,[&#x27;e&#x27;,9]]&gt;&gt;&gt; str4 = [str(i) for i in list4]&gt;&gt;&gt; str4[&#x27;a&#x27;, &#x27;1&#x27;, &quot;[&#x27;e&#x27;, 9]&quot;] 上面的方法，在列表中包含有其它列表类型的元素时，可能需要脱去列表最外层的中括号，才能在实际业务中应用。 1234567&gt;&gt;&gt; list1 = [&#x27;a&#x27;,7,&#x27;b&#x27;,8,&#x27;c&#x27;,[&#x27;e&#x27;,9]]&gt;&gt;&gt; str1 = str(list1)&gt;&gt;&gt; str1&quot;[&#x27;a&#x27;, 7, &#x27;b&#x27;, 8, &#x27;c&#x27;, [&#x27;e&#x27;, 9]]&quot;&gt;&gt;&gt; str2 = str1[1:-1]&gt;&gt;&gt; str2&quot;&#x27;a&#x27;, 7, &#x27;b&#x27;, 8, &#x27;c&#x27;, [&#x27;e&#x27;, 9]&quot; 字符串转列表如果字符串没有额外分隔符，可以用直接用list转换 1234&gt;&gt;&gt; str1 = &#x27;abcde&#x27;&gt;&gt;&gt; list1 = list(str1)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] 若字符串中同样的分隔符重复出现，则用分割法返回列表： 1234&gt;&gt;&gt; str1 = &#x27;a,b,c,d,e&#x27;&gt;&gt;&gt; list1 = str1.split(&#x27;,&#x27;)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] 若字符串中是列表的形式，可获取字符串内容，从而得到列表： 1234&gt;&gt;&gt; str1 = &quot;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&quot;&gt;&gt;&gt; list1 = eval(str1)&gt;&gt;&gt; list1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 列表与字典的相互转换列表转字典两个列表一一对应，分别表示key和value 123456789101112&gt;&gt;&gt; key1= [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]&gt;&gt;&gt; val1=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; dict1 = dict(zip(key1,val1))&gt;&gt;&gt; dict1&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; key1 = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]&gt;&gt;&gt; val1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; zip(key1,val1)&lt;zip object at 0x000001A6162E1380&gt;&gt;&gt;&gt; list(zip(key1,val1))[(&#x27;1&#x27;, &#x27;a&#x27;), (&#x27;2&#x27;, &#x27;b&#x27;), (&#x27;3&#x27;, &#x27;c&#x27;)] zip 函数其实就是将两个列表一一对应的元素放到一起，结果为[(‘1’, ‘a’), (‘2’ ,‘b’), (‘3’, ‘c’)]，python3为了节省内存压缩成一个对象，通过list转换可以看到实际的结果。 嵌套列表转字典列表中的元素均为列表，其中的每一个列表都是一对key-value。 1234&gt;&gt;&gt; list1 = [[&#x27;1&#x27;,&#x27;a&#x27;], [&#x27;2&#x27;,&#x27;b&#x27;], [&#x27;3&#x27;,&#x27;c&#x27;]]&gt;&gt;&gt; dic1 = dict(list1)&gt;&gt;&gt; dic1&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 字典转列表123456789101112&gt;&gt;&gt; dic1 = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; list(dic1)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; list(dic1.keys())[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; list(dic1.values())[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; dic1.keys()dict_keys([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;])&gt;&gt;&gt; dic1.values()dict_values([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])&gt;&gt;&gt; 字典与字符串的相互转换字符串转字典字符串内容是字典，则用 eval 获取字符串内容： 123&gt;&gt;&gt; str1 = &quot;&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&quot;&gt;&gt;&gt; eval(str1)&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 还有一种方法是用 json 包中的函数，将json格式字符串转为字典。 12345&gt;&gt;&gt; import json&gt;&gt;&gt; str1 = &#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;&gt;&gt;&gt; json.loads(str1)&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; 字典转字符串json.dumps转换： 123&gt;&gt;&gt; dic = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; json.dumps(dic)&#x27;&#123;&quot;1&quot;: &quot;a&quot;, &quot;2&quot;: &quot;b&quot;, &quot;3&quot;: &quot;c&quot;&#125;&#x27; str强制转换 123&gt;&gt;&gt; dic = &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&gt;&gt;&gt; str(dic)&quot;&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;&quot; 元组与字符串的相互转换元组转字符串str强制转换 1234567&gt;&gt;&gt; tup1= (1,2,3)&gt;&gt;&gt; str(tup1)&#x27;(1, 2, 3)&#x27;&gt;&gt;&gt; type(tup1)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; type(str(tup1))&lt;class &#x27;str&#x27;&gt; 用字符分割： 123&gt;&gt;&gt; tup2 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; &#x27; &#x27;.join(tup2)&#x27;1 2 3&#x27; 字符串转元组直接用tuple强制转： 123&gt;&gt;&gt; str1 = &#x27;123&#x27;&gt;&gt;&gt; tuple(str1)(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;) 字符串中包含元组，用eval获取字符串 123456789&gt;&gt;&gt; str2 = &quot;(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&quot;&gt;&gt;&gt; tup1 = eval(str2)&gt;&gt;&gt; tup1(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)&gt;&gt;&gt; type(str2)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(tup1)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; 元组与列表的相互转换元组转列表123&gt;&gt;&gt; tup1 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; list(tup1)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] 列表转元组123&gt;&gt;&gt; list = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; tuple(list)(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) 元组与字典的相互转换元组转字典类似列表转字典，用zip函数过渡，之后用dict转换： 1234&gt;&gt;&gt; tup3 = (&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&gt;&gt;&gt; tup4 = (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)&gt;&gt;&gt; dict(zip(tup3,tup4))&#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125; 字典转元组字典的key和value分别用tuple转为元组： 12345&gt;&gt;&gt; dic1 = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;&gt;&gt;&gt; tuple(dic1.keys())(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)&gt;&gt;&gt; tuple(dic1.values())(1, 2, 3)","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--常用内置函数","slug":"python基础--常用内置函数","date":"2020-12-31T08:30:00.000Z","updated":"2021-01-14T06:14:00.000Z","comments":true,"path":"python基础--常用内置函数.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.html","excerpt":"​ 主要记录python常用的内置函数","text":"​ 主要记录python常用的内置函数 标准输出函数print()​ print() 函数是所有python使用者最先接触也是用得最多的一个函数。print()函数一次可以打印多个对象，对象可以是任意类型。print()函数有以下几个默认参数： sep：间隔多个输出对象，默认值是一个空格 end：设定结尾，默认值是换行符 file：要写入的文件对象，默认是标准输出控制台（sys.stdout) flush：是否立即输出缓存，默认内容不会立即被输出 123456789101112 print(3,[1,2,3],&#123;&#x27;name&#x27;:&#x27;joe&#x27;&#125;)3 [1, 2, 3] &#123;&#x27;name&#x27;: &#x27;joe&#x27;&#125;&gt;&gt;&gt; print(1,2,&#x27;x&#x27;,&#x27;y&#x27;, sep=&#x27;*&#x27;) #多个打印对象之间使用星号分隔1*2*x*y&gt;&gt;&gt; for item in [1,2,&#x27;x&#x27;,&#x27;y&#x27;]:... print(item,end=&#x27;,&#x27;) #不换行打印...1,2,x,y,&gt;&gt;&gt; with open(r&#x27;d:\\print_out.txt&#x27;,&#x27;w&#x27;) as fp: #打印到文件... print(1,2,&#x27;x&#x27;,&#x27;y&#x27;, sep=&#x27;*&#x27;,file=fp)...&gt;&gt;&gt; 下面的例子，就是利用print()函数的多参数，实现的各种效果 12345678910111213141516171819202122232425262728293031 # -*- coding:utf-8 -*-import timedef printer(text, delay=0.85): &quot;&quot;&quot;打字机效果&quot;&quot;&quot; for ch in text: print(ch,end=&#x27;&#x27;, flush=True) time.sleep(delay) print()def waiting(cycle=20, delay=0.1): &quot;&quot;&quot;旋转式进度指示&quot;&quot;&quot; for i in range(cycle): for ch in [&#x27;-&#x27;,&#x27;\\\\&#x27;,&#x27;|&#x27;,&#x27;/&#x27;]: print(&#x27;\\b%s&#x27;%ch,end=&#x27;&#x27;,flush=True) time.sleep(delay) print()def cover(cycle=100,delay=0.2): &quot;&quot;&quot;覆盖式打印效果&quot;&quot;&quot; for i in range(cycle): s = &#x27;\\r%d&#x27;%i print(s.ljust(3),end=&#x27;&#x27;,flush=True) time.sleep(delay) print()if __name__ == &#x27;__main__&#x27;: printer(&#x27;落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦&#x27;) waiting(cycle=20) cover(cycle=20) 标准输入函数input()​ input() 函数用于程序执行过程中接收键盘输入。按回车键，input() 函数即返回从键盘输入的字符串，但不包括回车符。因为 input()函数本身具备IO阻塞的功能，所以也可以在程序中作为调试断点来使用。input()函数没有默认参数，接收一个字符串作为输入提示信息。 示例代码： 1234567&gt;&gt;&gt; nums = input()1 2 3&gt;&gt;&gt; print(nums) #这里nums 是一个字符串，不是整数1 2 3&gt;&gt;&gt; [int(item) for item in nums.split()] #这里进行转换，变成整数[1, 2, 3]&gt;&gt;&gt; 可迭代对象长度函数len()​ len 是 length 的缩写，该函数可以返回列表、元组、字典、字符串等可迭代对象的长度（或称为元素数量）。 示例代码： 12345678910&gt;&gt;&gt; len(&#x27;asadasdasd&#x27;)10&gt;&gt;&gt; len([3,4,5])3&gt;&gt;&gt; len(&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2&#125;)2&gt;&gt;&gt; len(&#123;True,False,None&#125;)3&gt;&gt;&gt; len(range(5))5 序列生成器函数range()​ range() 函数可以返回一个整数序列，只是无法看到这个序列的全貌，也不能访问其中的某个元素。只能从头开始依次便利每一个元素。 range() 函数可以接受一个、两个、或者三个整型参数。 1234567891011121314151617&gt;&gt;&gt; type(range(5))&lt;class &#x27;range&#x27;&gt;&gt;&gt;&gt; for i in range(5): #默认从0开始，步长为1... print(i, end=&#x27;,&#x27;)...0,1,2,3,4,&gt;&gt;&gt; for i in range(5,10): #在[5,10]区间内生成序列，步长为1... print(i, end=&#x27;,&#x27;)...5,6,7,8,9,&gt;&gt;&gt; for i in range(1,10,2): #在[1,10]区间内生成序列，步长为2... print(i,end=&#x27;,&#x27;)...1,3,5,7,9,&gt;&gt;&gt; list(range(10)) #转换成list[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; 格式化输出函数format()Python中格式化输出字符串使用 format() 函数, 字符串的参数使用{NUM}进行表示, 0表示第一个参数, 1表示第二个参数, 以后顺次递加。 使用”:”, 指定代表元素需要的操作, 如”:.3”小数点三位, “:8”占8个字符空间等; 数字(0, 1, …)即代表format()里面的元素, 所以可以使用”.”调用元素的方法; 常用的格式化符号 符号 说明 {:.2f} 四舍五入，保留小数点后两位 {:.+2f} 四舍五入，保留小数点后两位，带符号 {:0&gt;2d} 整数左侧部0，总长度为2 {:X&lt;4d} 整数右侧补X，总长度未4 {:,} 为整数增加逗号分隔符 {:.2%} 百分比格式化，保留小数点后两位 {:.2e} 科学计数法，保留小数点后两位 {:&gt;10d} 长度为10以内右对齐 {:&lt;10d} 长度为10以内左对齐 {:^0d} 长度为10以内居中对齐 {:b} 转为二进制 {:#b} 转为带前缀0b {:o} 转为八进制 {:#o} 转为带前缀0o的八进制 {:x} 转为16进制 {:#x} 转为带前缀0x的十六进制 {:#X} 转为带前缀0X的十六进制 也可以使用% 实现格式化字符串输出 符号 说明 %d或%i 转为带符号的十进制形式的整数 %o 转为带符号的八进制形式整数 %x或%X 转为带符号的十六进制形式整数 %e或%E 转为科学计数法表示的浮点数 %f或%F 转为十进制形式的浮点数 %g或%G 智能选择使用%e、%E或%f、%F %c 格式化字符及其ASCII码 %r 使用repr()变量或表达式转为字符串 %s 使用str()变量或表达式转为字符串 示例代码12345&gt;&gt;&gt; Y,M,D,h,m,s = 2009, 2, 17, 10, 48, 39&gt;&gt;&gt; &#x27;&#123;:04d&#125;-&#123;:02d&#125;-&#123;:02d&#125; &#123;:02d&#125;:&#123;:02d&#125;:&#123;:02d&#125;&#x27;.format(Y,M,D,h,m,s)&#x27;2009-02-17 10:48:39&#x27;&gt;&gt;&gt; &#x27;%04d-%02d-%02d %02d:%02d:%02d&#x27;%(Y,M,D,h,m,s)&#x27;2009-02-17 10:48:39&#x27; 排序函数sorted()​ 排序函数 sorted() 不会改变排序列表的数据结构，而是返回一个新的排序结果。这一点和列表对象的 sort() 方法不同。列表对象的sort()方法改变了列表本身，且无返回值。 示例代码1234567&gt;&gt;&gt; sorted([3,7,2,8,5])[2, 3, 5, 7, 8]&gt;&gt;&gt; a = [[6, 5], [3, 7], [2, 8]]&gt;&gt;&gt; sorted(a, key=lambda x:x[0]) # 根据每一行的首元素排序，默认reverse=False[[2, 8], [3, 7], [6, 5]]&gt;&gt;&gt; sorted(a, key=lambda x:x[-1]) # 根据每一行的尾元素排序，设置reverse=True实现逆序[[6, 5], [3, 7], [2, 8]] 文件读写函数open()​ python open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。 函数语法1open(name[, mode[, buffering]]) 参数说明： name : 一个包含了你要访问的文件名称的字符串值。 mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 示例代码123456789101112&gt;&gt;&gt; data = [[1,2,3,4,5,6,7],[8,9,10,11,12,13,14,15]]&gt;&gt;&gt; with open (r&#x27;d:\\csv_data.csv&#x27;,&#x27;w&#x27;) as fp:... for line in data:... ok = fp.write(&#x27;%s\\n&#x27;%&#x27;,&#x27;.join([str(item) for item in line]))...&gt;&gt;&gt; result = list()&gt;&gt;&gt; with open(r&#x27;d:\\csv_data.csv&#x27;,&#x27;r&#x27;) as fp:... for line in fp.readlines():... result.append([float(f) for f in line.strip().split(&#x27;,&#x27;)])...&gt;&gt;&gt; result[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0], [8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0]] 补充说明： file 对象 **file.read([size])**：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。 **file.readline()**：返回一行。 file.readlines([size]) ：返回包含size行的列表, size 未指定则返回全部行。 for line in f: print line ：通过迭代器访问。 **f.write(“hello\\n”)**：如果要写入字符串以外的数据,先将他转换为字符串。 **f.tell()**：返回一个整数,表示当前文件指针的位置(就是到文件头的字节数)。 **f.seek(偏移量,[起始位置])**：用来移动文件指针。 偏移量: 单位为字节，可正可负 起始位置: 0 - 文件头, 默认值; 1 - 当前位置; 2 - 文件尾 f.close() 关闭文件 示例代码123&gt;&gt;&gt; f =open(&#x27;d:\\csv_data.csv&#x27;)&gt;&gt;&gt; f.read()&#x27;1,2,3,4,5,6,7\\n8,9,10,11,12,13,14,15\\n&#x27; 类型相关函数type()/isinstance()type()type() 函数如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。 语法12type(object)type(name, bases, dict) 参数 name – 类的名称。 bases – 基类的元组。 dict – 字典，类内定义的命名空间变量。 示例代码1234567891011&gt;&gt;&gt; type(1)&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&#x27;runoob&#x27;)&lt;type &#x27;str&#x27;&gt;&gt;&gt;&gt; type([2])&lt;type &#x27;list&#x27;&gt;&gt;&gt;&gt; type(&#123;0:&#x27;zero&#x27;&#125;)&lt;type &#x27;dict&#x27;&gt;&gt;&gt;&gt; x = 1 &gt;&gt;&gt; type( x ) == int # 判断类型是否相等True isinstance()isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 语法1isinstance(object, classinfo) 参数 object – 实例对象。 classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。 示例代码1234567&gt;&gt;&gt;a = 2&gt;&gt;&gt; isinstance (a,int)True&gt;&gt;&gt; isinstance (a,str)False&gt;&gt;&gt; isinstance (a,(str,int,list)) # 是元组中的一个返回 TrueTrue isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 数学函数sum()sum() 方法对序列进行求和计算。 语法1sum(iterable[, start]) 参数 iterable – 可迭代对象，如：列表、元组、集合。 start – 指定相加的参数，如果没有设置这个值，默认为0。 示例代码123456&gt;&gt;&gt;sum([0,1,2]) 3 &gt;&gt;&gt; sum((2, 3, 4), 1) # 元组计算总和后再加 110&gt;&gt;&gt; sum([0,1,2,3,4], 2) # 列表计算总和后再加 212 max()/min()max() 方法返回给定参数的最大值，参数可以为序列。 min() 方法返回给定参数的最小值，参数可以为序列。 语法12max( x, y, z, .... )min( x, y, z, .... ) 参数 x – 数值表达式。 y – 数值表达式。 z – 数值表达式。 示例代码123456&gt;&gt;&gt; max(3,4,2,5,8)8&gt;&gt;&gt; min(5,2,2.1)2&gt;&gt;&gt; min([3,4,5]),max([9.99,0.1])(3, 9.99) abs()abs() 函数返回数字的绝对值。 语法1abs( x ) 参数 x – 数值表达式。 示例代码1234&gt;&gt;&gt; abs(-9.99)9.99&gt;&gt;&gt; abs(9)9 pow()pow() 方法返回 xy（x 的 y 次方） 的值。 语法以下是 math 模块 pow() 方法的语法: 123import mathmath.pow( x, y ) 内置的 pow() 方法 1pow(x, y[, z]) 函数是计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z。 注意： pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。 参数 x – 数值表达式。 y – 数值表达式。 z – 数值表达式。 123456789&gt;&gt;&gt; pow(2,3)8&gt;&gt;&gt; import math&gt;&gt;&gt; math.pow(100,-2)0.0001&gt;&gt;&gt; math.pow(100,2)10000.0&gt;&gt;&gt; pow(2,-2)0.25 divmod()python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 函数语法1divmod(a, b) 参数说明： a: 数字 b: 数字 123456&gt;&gt;&gt;divmod(7, 2)(3, 1)&gt;&gt;&gt; divmod(8, 2)(4, 0)&gt;&gt;&gt; divmod(1+2j,1+0.5j)((1+0j), 1.5j) round()round() 方法返回浮点数x的四舍五入值。 语法1round( x, n ) 参数 x – 数值表达式。 n – 数值表达式，表示从小数点位数。 123456&gt;&gt;&gt; round(80.4656541231,2)80.47&gt;&gt;&gt; round(80.4656541231,3)80.466&gt;&gt;&gt; round(-80.4656541231,3)-80.466 特殊功能函数zip()函数zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法1zip([iterable, ...]) 参数说明： iterabl – 一个或多个迭代器; 示例代码1234567891011121314151617&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)] &gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt; eval() 函数eval() 函数用来执行一个字符串表达式，并返回表达式的值。 语法以下是 eval() 方法的语法: 1eval(expression[, globals[, locals]]) 参数 expression – 表达式。 globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。 locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。 示例代码12345678910&gt;&gt;&gt;x = 7&gt;&gt;&gt; eval( &#x27;3 * x&#x27; )21&gt;&gt;&gt; eval(&#x27;pow(2,2)&#x27;)4&gt;&gt;&gt; eval(&#x27;2 + 2&#x27;)4&gt;&gt;&gt; n=81&gt;&gt;&gt; eval(&quot;n + 4&quot;)85 ​ eval虽然方便，但是要注意安全性，可以将字符串转成表达式并执行，就可以利用执行系统命令，删除文件等操作。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--常用内置类","slug":"python基础--常用内置类","date":"2020-12-31T03:14:00.000Z","updated":"2020-12-31T05:55:00.000Z","comments":true,"path":"python基础--常用内置类.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%B1%BB.html","excerpt":"​ python 内置了 列表、字典、元组、集合和字符串等多种数据结构，每种数据结构都封装成为一个类。","text":"​ python 内置了 列表、字典、元组、集合和字符串等多种数据结构，每种数据结构都封装成为一个类。 列表​ 列表（list）是元素的有序集合，列表的元素可以是python语言支持的任意类型。惯用写法是用方括号([])来创建列表，标准写法是用 list() 来实例化 list 类。列表的方法有很多，可以实现列表末尾追加元素、指定位置插入元素、删除指定元素或指定索引位置的元素、返回元素索引、排序等操作。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; a = list() #创建一个空列表，可以传入列表、元组、字符串等迭代对象&gt;&gt;&gt; a.append(3) # 列表尾部追加元素3&gt;&gt;&gt; a.extend([4,5,6,7,8,7]) #列表后接列表[4,5,6,7,8,7]&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.insert(1,9) #在索引序号为1的位置插入元素9&gt;&gt;&gt; a[3, 9, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.index(9)1&gt;&gt;&gt; a.count(7) #返回列表中值为7的元素个数2&gt;&gt;&gt; a.pop(1) #删除并返回索引序号为1的元素，如果不指定索引，则删除最后一个元素9&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8, 7]&gt;&gt;&gt; a.remove(7) #删除列表中最靠前的元素7（无返回）&gt;&gt;&gt; a[3, 4, 5, 6, 8, 7]&gt;&gt;&gt; a.sort() #排序&gt;&gt;&gt; a[3, 4, 5, 6, 7, 8]&gt;&gt;&gt; a[-1] #Python引入-1做末尾的元素索引8&gt;&gt;&gt; a[1:-1] #掐头去尾 切片[4, 5, 6, 7]&gt;&gt;&gt; a[::2] #从头开始，隔一个取一个元素[3, 5, 7] &gt;&gt;&gt; a[::-1] #逆序[8, 7, 6, 5, 4, 3] 字典​ 字典（dict）的本质是 无序的键值对。 12345678910111213141516171819202122232425262728&gt;&gt;&gt; d = dict()&gt;&gt;&gt; d = dict(a=1,b=2)&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; d = dict([(&#x27;a&#x27;,1),(&#x27;b&#x27;,2)])&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; d.update(&#123;&#x27;c&#x27;:3&#125;)&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;&gt;&gt;&gt; d.pop(&#x27;c&#x27;)3&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; list(d.items())[(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2)]&gt;&gt;&gt; list(d.keys())[&#x27;a&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; list(d.values())[1, 2]&gt;&gt;&gt; for key in d:... print(key,d[key])...a 1b 2&gt;&gt;&gt; dict.fromkeys(&#x27;xyz&#x27;,0) #fromkeys 是字典类的静态方法，实例也可以调用&#123;&#x27;x&#x27;: 0, &#x27;y&#x27;: 0, &#x27;z&#x27;: 0&#125;&gt;&gt;&gt; 元组​ 元组（tuple）可以理解为限制版的列表，也是元素的有序集合，但这个集合一旦创建，就不允许增加、删除和修改元素。通常，元组用于表示特定的概念，如坐标、矩形区域等。 12345678910&gt;&gt;&gt; a =(3,4)&gt;&gt;&gt; a = tuple([3,4])&gt;&gt;&gt; a.count(3)1&gt;&gt;&gt; a.index(3)0&gt;&gt;&gt; a.append(1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;append&#x27; #不允许增加 集合​ 集合（set）有两个特点，一是集合内元素具有唯一性，二是集合内元素无需排列。集合有一个很经典的用法：去除列表内的重复元素。 123456789101112131415161718192021222324&gt;&gt;&gt; a = set()&gt;&gt;&gt; a.update(&#123;&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;)&gt;&gt;&gt; a&#123;&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;&gt;&gt;&gt; a.remove(&#x27;z&#x27;)&gt;&gt;&gt; a&#123;&#x27;x&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; a.add(&#x27;w&#x27;)&gt;&gt;&gt; a&#123;&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;&#125;&gt;&gt;&gt; a = &#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;&#125;&gt;&gt;&gt; b = &#123;&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;&gt;&gt;&gt; a.difference(b) #返回a有b没有的元素集合&#123;&#x27;A&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; a - b #简写&#123;&#x27;A&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; a.union(b) #返回a和b的并集&#123;&#x27;D&#x27;, &#x27;B&#x27;, &#x27;E&#x27;, &#x27;A&#x27;, &#x27;C&#x27;&#125;&gt;&gt;&gt; a.intersection(b) #返回a和b重复元素的集合&#123;&#x27;C&#x27;&#125;&gt;&gt;&gt; a.symmetric_difference(b) #返回a和b非重复元素的集合&#123;&#x27;E&#x27;, &#x27;A&#x27;, &#x27;D&#x27;, &#x27;B&#x27;&#125;&gt;&gt;&gt; list(set([1,2,5,2,3,4,5,&#x27;x&#x27;,5,&#x27;x&#x27;])) #去除数组中的重复元素[1, 2, 3, 4, 5, &#x27;x&#x27;] 字符串​ 字符穿对象可以像列表那样进行索引和切片，但无法改变字符串对象的内容，这有点类似元组不可以增加、删除和修改元素。 123456789101112131415161718192021222324252627282930313233343536373839404142&gt;&gt;&gt; str(3.14)&#x27;3.14&#x27;&gt;&gt;&gt; str([&#x27;a&#x27;,1])&quot;[&#x27;a&#x27;, 1]&quot;&gt;&gt;&gt; str(&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;)&quot;&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;&quot;&gt;&gt;&gt; s = &quot;hello world&quot;&gt;&gt;&gt; s[1:-1]&#x27;ello worl&#x27;&gt;&gt;&gt; s[::2]&#x27;hlowrd&#x27;&gt;&gt;&gt; s[::-1]&#x27;dlrow olleh&#x27;&gt;&gt;&gt; s.upper()&#x27;HELLO WORLD&#x27;&gt;&gt;&gt; s.lower()&#x27;hello world&#x27;&gt;&gt;&gt; s.capitalize()&#x27;Hello world&#x27;&gt;&gt;&gt; s.title()&#x27;Hello World&#x27;&gt;&gt;&gt; s.startswith(&#x27;hello&#x27;)True&gt;&gt;&gt; s.endswith(&#x27;world&#x27;)True&gt;&gt;&gt; s.find(&#x27;ll&#x27;)2&gt;&gt;&gt; s.split()[&#x27;hello&#x27;, &#x27;world&#x27;]&gt;&gt;&gt; s.replace(&#x27;world&#x27;, &#x27;python&#x27;)&#x27;hello python&#x27;&gt;&gt;&gt; &#x27;1&#x27;.isalpha()False&gt;&gt;&gt; &#x27;asd&#x27;.isalpha()True&gt;&gt;&gt; &#x27;asd12&#x27;.isalpha()False&gt;&gt;&gt; &#x27;asd12&#x27;.isalnum()True&gt;&gt;&gt; &#x27;\\t sasd1231 \\n&#x27;.strip()&#x27;sasd1231&#x27;&gt;&gt;&gt;","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--数据类型","slug":"python基础--数据类型","date":"2020-12-31T02:14:00.000Z","updated":"2020-12-31T02:55:00.000Z","comments":true,"path":"python基础--数据类型.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","excerpt":"​ python中，数据被分为四种类型，分别是：整型、浮点型、布尔型和字符串，并提供了 int 类，float 类，bool 类和 str 类这四个内置类与之相对应。使用 type() 函数可以看到他们各自的类名。","text":"​ python中，数据被分为四种类型，分别是：整型、浮点型、布尔型和字符串，并提供了 int 类，float 类，bool 类和 str 类这四个内置类与之相对应。使用 type() 函数可以看到他们各自的类名。 整型​ 整型数据就是数学上的整数，包括正整数，负整数和零。python不像C，C++把整型分为多种，所以不用担心超过系统限制。 一个整型的例子，可以区别python与其他的语言 1234567&gt;&gt;&gt; def factorial(n):... if n == 0:... return 1... return n*factorial(n-1)...&gt;&gt;&gt; factorial(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 浮点型​ 浮点型数据既可以表示很大的数，也可以表示很小的数。精度是浮点型数据最重要的指标，也是最容易出问题的。 一个特殊的例子（精度相关的）： 12345678&gt;&gt;&gt; 0.1+0.20.30000000000000004&gt;&gt;&gt; 0.1+0.2 ==0.3False&gt;&gt;&gt; 1.1+1.22.3&gt;&gt;&gt; 1.1+1.2 == 2.3True ​ 关于0.1+0.2 != 0.3 ，可以看链接里的回答。 布尔型​ python定义了两个常量：True 和 False ，用来表示布尔型的真和假。True 表示真、非空、非零等概念，False 表示 假、空、零等概念。 1234567891011121314&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool(&#x27;&#x27;)False&gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool([&#x27;x&#x27;])True&gt;&gt;&gt; bool(&#x27;x&#x27;)True&gt;&gt;&gt; bool([False])True 字符串​ 字符串是python语言的处理对象之一。python将 单引号（&#39;&#39;）、双引号（&quot;&quot;）、三引号（&#39;&#39;&#39;或者&quot;&quot;&quot;） 前后封闭起来的字符集视为字符串对象，并提供了一系列的处理方法。 12345678&gt;&gt;&gt; &#x27;hello world&#x27;&#x27;hello world&#x27;&gt;&gt;&gt; &quot;hello world&quot;&#x27;hello world&#x27;&gt;&gt;&gt; &#x27;&#x27;&#x27;hello world&#x27;&#x27;&#x27;&#x27;hello world&#x27;&gt;&gt;&gt; &quot;&quot;&quot;hello world&quot;&quot;&quot;&#x27;hello world&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--语句结构","slug":"python基础--语句结构","date":"2020-12-30T10:14:00.000Z","updated":"2020-12-30T10:55:00.000Z","comments":true,"path":"python基础--语句结构.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84.html","excerpt":"​ python和其他编程语言一样，支持：顺序、分支和循环三种语句结构。","text":"​ python和其他编程语言一样，支持：顺序、分支和循环三种语句结构。 顺序结构​ python 把缩进作为语法的一部分，缩进层次相同且连续的一段代码就是一个顺序结构的代码块。运行时，代码块内的代码从上到下，一次被解释执行。 分支结构​ python语言使用 if-else 描述分支结构，支持嵌套，并将 else if 简写成 elif 示例代码： 123456789101112131415161718192021222324252627&gt;&gt;&gt; a, b, c = 3, 4, 5&gt;&gt;&gt; if a &gt; b: #最简单的if-else分支结构... print(a)... else:... print(b)...4&gt;&gt;&gt; if a &gt; b and a &gt; c: #类似switch结构的分支结构... print(a)... elif b &gt; c:... print(b)... else:... print(c)...5&gt;&gt;&gt; if a &gt; b: #嵌套的 if-else 分支结构... if a &gt; c:... print(a)... else:... print(c)... else:... if b &gt; c:... print(b)... else:... print(c)...5 ​ 以上代码演示了三种最常见的分支结构。第一种是最简单的 if-else 分支结构，即使没有 else 分支也是合乎规则的；第二种是类似 switch 结构的分支结构；第三种是嵌套的 if-else 分支结构。 循环结构​ python的循环结构有两种： for 循环和 while 循环。for 循环一般用于循环次数确定的场合，如遍历列表、字典等。 while 循环一般用于循环次数不确定的场合，每次循环之后都要对循环条件进行判断。为了避免“死循环”，在 while 循环体内通常会存在影响循环条件的代码，除非希望while 循环永不停止。 ​ 循环体内有两个特殊语句会影响到 for 循环和 while 循环，这就是 continue 和 break 语句。 continue 语句可以立即结束本次循环，开始下一个循环；break 语句则是立即跳出循环，继续执行 for 或 while 循环后面的语句。 for循环示例：123456789101112131415161718192021222324&gt;&gt;&gt; for i in range(3): #这是 for循环最经典的用法... print(i)...012&gt;&gt;&gt; for i in [1,2,3,4,5,6,7,8,9,10]: #遍历数组是for循环最频繁的应用形式... if i%2 ==0:... continue... if i &gt; 8:... break... print(i*&#x27;*&#x27;)...****************&gt;&gt;&gt; d = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;&gt;&gt;&gt; for key in d: #遍历字典的标准写法... print(key, d[key])...a 1b 2&gt;&gt;&gt; while循环示例：123456789101112131415161718&gt;&gt;&gt; a = 3&gt;&gt;&gt; while a &gt; 0: #判断循环条件... print(a*&#x27;*&#x27;)... a -= 1 #影响循环的条件...******&gt;&gt;&gt; a = 0&gt;&gt;&gt; while True: #死循环... a += 1 #影响循环出口的条件... if a &gt; 3: #设置循环出口条件... break... print(a*&#x27;*&#x27;)...******","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python基础--类和函数","slug":"python基础--类和函数","date":"2020-12-30T08:14:00.000Z","updated":"2020-12-30T10:03:00.000Z","comments":true,"path":"python基础--类和函数.html","link":"","permalink":"https://www.lauyongyi.cn/python%E5%9F%BA%E7%A1%80--%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0.html","excerpt":"​ python有两个顶级的结构定义：函数和类。","text":"​ python有两个顶级的结构定义：函数和类。 函数定义（def）​ python的函数既可以有参数，也可以没有参数；既可以有返回值，也可以没有返回值。用关键字 def 来定义一个函数，用关键字 return 返回函数结果（如果需要返回）。 例子： 1234567891011&gt;&gt;&gt; def hello():... print(&quot;hello world&quot;)...&gt;&gt;&gt; hello()hello world&gt;&gt;&gt; def adder(x, y):... return x + y...&gt;&gt;&gt; adder (5, 6)11 ​ 以上的代码定义了两个函数，hello()函数没有参数，也没有返回指；adder()函数有两个参数，返回值市两个参数的和。 ​ !!! 定义和调用函数时，即使没有参数，函数名后面的圆括号也不能省略。 类定义（class）​ python类定义的规则非常灵活，既有强制性的，也有建议性的。关于类的定义，只需要了解以下几点,就能轻松应对各种 类: 使用关键字 class 定义类。 如果没有基类,类名之后不需要圆括号。 构造函数__init__()在类实例化时自动运行,类的属性要在这里定义或声明。 self不是关键词，虽可替换，但不建议。 类是属性和方法的混合体。 同一个类，可以生成很多实列。 类的各个实例之间是相互隔离的。 例子 12345678910111213141516171819202122232425class GameServer: def __init__(self, port): #构造函数 self.port = port #类属性：服务使用的端口 self.running = False #类属性：服务运行标志 def start(self): #定义类方法：启动服务 self.running = True def stop(self): #定义类方法：停止服务 self.running = False def status(self): #定义类方法：查看服务状态 if self.running: print(&#x27;服务运行于%d端口上。&#x27;%self.port) else: print(&#x27;服务已停止&#x27;)if __name__ == &#x27;__main__&#x27;: gs = GameServer(3721) #类实例化 print(gs.port) #对象属性，服务端口 gs.status() #对象方法，查看服务状态 gs.start() #对象方法：启动服务 gs.status() gs.stop() #对象方法：停止服务 gs.status()","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"Linux性能监控工具-Nmon","slug":"Linux监控工具-Nmon","date":"2020-12-29T06:00:00.000Z","updated":"2020-12-29T07:03:00.000Z","comments":true,"path":"Linux监控工具-Nmon.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-Nmon.html","excerpt":"​ Nmon是一种在AIX与各种Linux操作系统上广泛使用的监控与分析工具，相对于其它一些系统资源监控工具来说，nmon所记录的信息是比较全面的，它能在系统运行过程中实时地捕捉系统资源的使用情况，并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。","text":"​ Nmon是一种在AIX与各种Linux操作系统上广泛使用的监控与分析工具，相对于其它一些系统资源监控工具来说，nmon所记录的信息是比较全面的，它能在系统运行过程中实时地捕捉系统资源的使用情况，并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。 nmon所记录的数据包含以下一些方面： cpu占用率 内存使用情况 磁盘I/O速度、传输和读写比率 文件系统的使用率 网络I/O速度、传输和读写比率、错误统计率与传输包的大小 消耗资源最多的进程 计算机详细信息和资源 页面空间和页面I/O速度 用户自定义的磁盘组 网络文件系统 下载安装nmon1、下载安装包：http://nmon.sourceforge.net/pmwiki.php?n=Site.Download 选择下载相应的版本，我下载的是 nmon16m_helpsystems.tar.gz(截至目前最新的）。解压后里边有很多版本的nmon，我用的是nmon_x86_64_centos7，亲测可用。 2、直接在window中将解压好的nmon_x86_64_centos7通过sftp上传到要监控的linux系统中对应目录下 3、执行授权命令：# chmod +x nmon_x86_64_centos7 4、运行./nmon_x86_64_centos7，便可进入nmon的监控界面，如下图： 实时监控​ 在完成配置后，只需要“./nmon_x86_64_centos7”命令即可运行程序，通过一些快捷键调取关心的系统资源指标进行显示，如按键“C”可以查看CPU相 关信息；按键“D”可以查看磁盘信息；按键“T”可以查看系统的进程信息；“M”对应内存、“N”对应网络等等，完整的快捷键对应内容可以通过帮助（按键 “H”）查看，可以显示Linux系统CPU、内存、进程信息，包括了CPU的用户、系统、等待和空闲状态值，可用内存、缓存大小以及进程的CPU消耗等详细指标。该种方式显示信息实时性强，能够及时掌握系统承受压力下的运行情况，每颗CPU利用率是多少、内存使用多少、网络流量多少、磁盘读写……这些数据均是实时刷新，一目了然。 例如：“c“查看系统CPU使用情况 nmon数据采集数据采集为了实时监控系统在一段时间内的使用情况并将结果记录下来，可以通过运行以下命令实现： 1# .&#x2F;nmon_x86_64_centos7 -f -t -s 30 -c 180 -m &#x2F;home -f：按标准格式输出文件：_YYYYMMDD_HHMM.nmon； -t：输出中包括占用率较高的进程； -s 30：每30秒进行一次数据采集 -c 180：一共采集180次 -m 生成的数据文件的存放目录。 输入命令回车后，将在/home目录生成一个hostname_timeSeries.nmon的文件。 如果想停止该监控，需要通过#ps –ef|grep nmon查询进程号，然后杀掉该进程以停止监控。 生成图形化结果为了分析nmon监控获得的结果，IBM还提供了相应的图形化分析工具nmon_analyser，通过nmon analyser.xls工具可以把监控的结果文件转换成excel文件，方便分析系统的各项资源占用情况。下载nmon_analyser（生成性能报告的免费工具） nmon analyser.xls工具的使用方法如下： （1）打开nmonanalyser.xls工具； （2）调整excel宏安全性(office 2016以上版本可以在文件–选项–信任中心–信任中心设置–宏设置–勾选启用所有宏) （3）修改完后，确定-关闭nmon analyser.xls，重新打开； （4）点击Analyse nmondata按钮，加载之前下载的 nmon 文件。 生成的图形化结果如下图所示： 结束nmon运行nmon运行本身是会消耗系统资源，如需关闭nmon，直接kill掉 123# ps -ef | grep nmon (得到pid)# kill -9pid (安全kill) 定时任务除配合性能测试的短期监控，我们也可以实现对系统的定期监控，作为运营维护阶段的参考。定期监控实现如下：1) 执行命令：#crontab -e 在最后一行添加如下命令： 0 8 * * 1,2,3,4,5 /opt/nmon_x86_64_linux -f -N -m/nmon/log -s 30 -c 1200 **表示:**周一到周五，从早上08点开始，监控10个小时（到18:00整为止），输出到/nmon/log nmon关键指标列表系统汇总（对应excel标签的‘SYS_SUMM’）蓝线为cpu占有率变化情况；粉线为磁盘IO的变化情况； 磁盘读写情况汇总（对应excel标签的‘DISK_SUMM’）蓝色为磁盘读的速率KB/sec紫色为磁盘写的速率KB/sec 内存情况汇总（对应excel标签的‘MEM’）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"Linux常用监控命令","slug":"Linux常用监控命令","date":"2020-12-28T10:46:00.000Z","updated":"2020-12-29T05:46:00.000Z","comments":true,"path":"Linux常用监控命令.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4.html","excerpt":"​ 记录Linux下常用的监控命令","text":"​ 记录Linux下常用的监控命令 1、top –Linux 系统进程监控​ top 命令是性能监控程序，它可以在很多 Linux/Unix 版本下使用，并且它也是 Linux 系统管理员经常使用的监控系统性能的工具。Top 命令可以定期显示所有正在运行和实际运行并且更新到列表中，它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。它也会显示内存和 CPU 使用率过高的正在运行的进程。当我们对 Linux 系统需要去监控和采取正确的行动时，top 命令对于系统管理员是非常有用的。让我们看下 top 命令的实际操作。 1234567891011121314toptop - 19:23:49 up 10 days, 4:37, 1 user, load average: 0.37, 0.24, 0.13Tasks: 78 total, 2 running, 76 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.7 us, 0.3 sy, 0.0 ni, 99.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882012 total, 108880 free, 569200 used, 1203932 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 1124836 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 2848 root 20 0 162452 11300 1980 S 0.3 0.6 10:13.25 barad_agent 2849 root 20 0 611544 13716 2248 S 0.3 0.7 44:27.48 barad_agent 3548 root 20 0 935212 20344 10396 S 0.3 1.1 1:20.46 YDService 3565 root 20 0 642092 12424 11060 S 0.3 0.7 0:26.83 YDEdr 23237 root 20 0 2636376 440476 7888 S 0.3 23.4 14:38.07 java 30663 root 20 0 160032 2180 1512 R 0.3 0.1 0:00.01 top 信息说明如下：1234567891011121314151617181920212223PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒COMMAND — 进程名称（命令名&#x2F;命令行） 2、vmstat –虚拟内存统计vmstat 命令是用于显示虚拟内存、内核线程、磁盘、系统进程、I/O 模块、中断、CPU 活跃状态等更多信息。在默认的情况下，Linux 系统是没有 vmstat 这个命令的，如果你要使用它，必须安装一个包名叫 sysstat 的程序包。 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如: 123456789# vmstat 2 10procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 108484 134740 1069640 0 0 2 34 33 16 1 1 99 0 0 0 0 0 109832 134740 1069648 0 0 0 36 589 1173 1 2 97 1 0 0 0 0 111460 134740 1069652 0 0 0 6 857 1721 1 1 98 0 0 0 0 0 111500 134740 1069660 0 0 0 48 752 1492 1 1 98 0 0 0 0 0 111464 134740 1069668 0 0 0 0 196 375 1 1 98 0 0 0 0 0 111516 134740 1069672 0 0 0 52 166 375 2 1 97 0 0 2表示每个两秒采集一次服务器状态，10表示采集10次。 实际上，在应用过程中，会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如: 12345678# vmstat 2 procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 111268 134744 1069764 0 0 2 34 33 16 1 1 99 0 0 0 0 0 111020 134744 1069764 0 0 0 30 188 380 1 1 99 1 0 0 0 0 111004 134744 1069772 0 0 0 0 154 314 1 1 99 0 0 0 0 0 107632 134744 1069772 0 0 0 0 195 350 2 1 97 0 0 0 0 0 106712 134744 1069776 0 0 0 84 635 1276 2 2 96 1 0 这表示vmstat每2秒采集数据，一直采集，直到结束程序，这里采集了5次数据就结束了程序。 字段说明：12345678910111213141516171819202122232425262728293031323334353637383940414243Procs（进程）：r: 运行队列中进程数量b: 等待IO的进程数量Memory（内存）：swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小Swap：si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数系统：in: 每秒中断数，包括时钟中断。cs: 每秒上下文切换数。CPU（以百分比表示）：us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。wa: 等待IO时间 备注： 如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重。如果pi，po 长期不等于0，表示内存不足。如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好。Linux在具有高稳定性、可靠性的同时，具有很好的可伸缩性和扩展性，能够针对不同的应用和硬件环境调整，优化出满足当前应用需要的最佳性能。因此企业在维护Linux系统、进行系统调优时，了解系统性能分析工具是至关重要的。 3、losf –打开文件列表4、netstat –网络统计​ 参考另一篇笔记：Linux查看端口占用 5、tcpdump –网络数据包分析器​ tcpdump 是一种使用最广泛的命令行网络数据包分析器或数据包嗅探程序，主要用于捕获和过滤 TCP/IP 包收到或者转移在一个网络的特定借口信息。它也提供了一个选项参数去保存将捕获的包在一个文件中用于以后分析使用，tcpdump 几乎在所有的 Linux 版本中都是可用的。 默认启动1tcpdump 普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。 监视指定网络接口的数据包1tcpdump -i eth1 监视指定主机的数据包打印所有进入或离开sundown的数据包. 1tcpdump host sundown 也可以指定ip,例如截获所有192.168.10.1 的主机收到的和发出的所有的数据包 1tcpdump host 192.168.10.1 打印helios 与 hot 或者与 ace 之间通信的数据包 1tcpdump host helios and \\( hot or ace \\) 截获主机192.168.10.1 和主机192.168.10.2 或192.168.10.3 的通信 1tcpdump host 192.168.10.1 and \\ (192.168.10.2 or 192.168.10.3 \\) 打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包. 1tcpdump ip host ace and not helios 如果想要获取主机192.168.10.1除了和主机192.168.10.2之外所有主机通信的ip包，使用命令： 1tcpdump ip host 192.168.10.1 and ! 192.168.10.2 截获主机hostname发送的所有数据 1tcpdump -i eth0 src host hostname 监视所有送到主机hostname的数据包 1tcpdump -i eth0 dst host hostname 监视指定主机和端口的数据包如果想要获取主机192.168.10.1接收或发出的telnet包，使用如下命令 1tcpdump tcp port 23 and host 192.168.10.1 对本机的udp 123 端口进行监视 123 为ntp的服务端口 1tcpdump udp port 123 监视指定网络的数据包打印本地主机与Berkeley网络上的主机之间的所有通信数据包(nt: ucb-ether, 此处可理解为’Berkeley网络’的网络地址,此表达式最原始的含义可表达为: 打印网络地址为ucb-ether的所有数据包) 1tcpdump net ucb-ether 打印所有通过网关snup的ftp数据包(注意, 表达式被单引号括起来了, 这可以防止shell对其中的括号进行错误解析) 1tcpdump &#39;gateway snup and (port ftp or ftp-data)&#39; 打印所有源地址或目标地址是本地主机的IP数据包 (如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折,需补充).localnet 实际使用时要真正替换成本地网络的名字) 1tcpdump ip and not net localnet","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux查看端口占用","slug":"Linux查看端口占用","date":"2020-12-28T10:46:00.000Z","updated":"2020-12-28T09:09:00.000Z","comments":true,"path":"Linux查看端口占用.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.html","excerpt":"​ Linux查看端口占用得情况可以使用lsof和netstat 命令","text":"​ Linux查看端口占用得情况可以使用lsof和netstat 命令 lsof​ lsof(list open files) 是一个列出当前系统打开文件的工具。 lsf查看端口占用语法格式： lsof -i:端口号 实例1234# lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAMEjava 23237 root 57u IPv6 56034 0t0 TCP *:webcache (LISTEN) 可以看出8080端口已经被 java 服务占用。 lsof -i 需要 root 用户的权限来执行，如下图： 12345678910111213141516# lsof -iCOMMAND PID USER FD TYPE DEVICE SIZE&#x2F;OFF NODE NAMEdhclient 859 root 6u IPv4 14539 0t0 UDP *:bootpc sshd 1385 root 3u IPv4 16540 0t0 TCP *:ssh (LISTEN)ntpd 2343 ntp 16u IPv4 18157 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 17u IPv4 18158 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 18u IPv6 18159 0t0 UDP VM-0-12-centos:ntp ntpd 2343 ntp 19u IPv6 18162 0t0 UDP VM-0-12-centos:ntp YDService 3548 root 18u IPv4 15028196 0t0 TCP VM-0-12-centos:39406-&gt;169.254.0.55:lsi-bobcat (ESTABLISHED)sshd 17853 root 3u IPv4 15450643 0t0 TCP VM-0-12-centos:ssh-&gt;119.123.73.14:13428 (ESTABLISHED)sshd 18401 root 3u IPv4 15454393 0t0 TCP VM-0-12-centos:ssh-&gt;49.234.88.101:38420 (ESTABLISHED)sshd 18404 sshd 3u IPv4 15454393 0t0 TCP VM-0-12-centos:ssh-&gt;49.234.88.101:38420 (ESTABLISHED)sshd 18413 root 3u IPv4 15454481 0t0 TCP VM-0-12-centos:ssh-&gt;167.71.127.147:42390 (ESTABLISHED)sshd 18416 sshd 3u IPv4 15454481 0t0 TCP VM-0-12-centos:ssh-&gt;167.71.127.147:42390 (ESTABLISHED)java 23237 root 57u IPv6 56034 0t0 TCP *:webcache (LISTEN)java 23237 root 196u IPv6 56093 0t0 TCP VM-0-12-centos:mxi (LISTEN) lsof输出各列信息的意义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101COMMAND：进程的名称PID：进程标识符PPID：父进程标识符（需要指定-R参数）USER：进程所有者PGID：进程所属组FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序（3）lnn：library references (AIX);（4）er：FD information error (see NAME column);（5）jld：jail directory (FreeBSD);（6）ltx：shared library text (code and data);（7）mxx ：hex memory-mapped type number xx.（8）m86：DOS Merge mapped file;（9）mem：memory-mapped file;（10）mmap：memory-mapped device;（11）pd：parent directory;（12）rtd：root directory;（13）tr：kernel trace file (OpenBSD);（14）v86 VP&#x2F;ix mapped file;（15）0：表示标准输出（16）1：表示标准输入（17）2：表示标准错误一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等（1）u：表示该文件被打开并处于读取&#x2F;写入模式（2）r：表示该文件被打开并处于只读模式（3）w：表示该文件被打开并处于（4）空格：表示该文件的状态模式为unknow，且没有锁定（5）-：表示该文件的状态模式为unknow，且被锁定同时在文件状态模式后面，还跟着相关的锁（1）N：for a Solaris NFS lock of unknown type;（2）r：for read lock on part of the file;（3）R：for a read lock on the entire file;（4）w：for a write lock on part of the file;（文件的部分写锁）（5）W：for a write lock on the entire file;（整个文件的写锁）（6）u：for a read and write lock of any length;（7）U：for a lock of unknown type;（8）x：for an SCO OpenServer Xenix lock on part of the file;（9）X：for an SCO OpenServer Xenix lock on the entire file;（10）space：if there is no lock.TYPE：文件类型，如DIR、REG等，常见的文件类型（1）DIR：表示目录（2）CHR：表示字符类型（3）BLK：块设备类型（4）UNIX： UNIX 域套接字（5）FIFO：先进先出 (FIFO) 队列（6）IPv4：网际协议 (IP) 套接字DEVICE：指定磁盘的名称SIZE：文件的大小NODE：索引节点（文件在磁盘上的标识）NAME：打开文件的确切名称 更多 lsof 的命令如下123456789lsof -i:8080：查看8080端口占用lsof abc.txt：显示开启文件abc.txt的进程lsof -c abc：显示abc进程现在打开的文件lsof -c -p 1234：列出进程号为1234的进程所打开的文件lsof -g gid：显示归属gid的进程情况lsof +d &#x2F;usr&#x2F;local&#x2F;：显示目录下被进程开启的文件lsof +D &#x2F;usr&#x2F;local&#x2F;：同上，但是会搜索目录下的目录，时间较长lsof -d 4：显示使用fd为4的进程lsof -i -U：显示所有打开的端口和UNIX domain文件 netstat​ netstat -tunlp 用于显示tcp，udp 的端口和进程相关情况。 netstat 查看端口占用语法格式: netstat - tunlp | grep 端口号 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 例如查看 8080 端口的情况，使用以下命令： 12# netstat -tunlp | grep 8080tcp6 0 0 :::8080 :::* LISTEN 23237&#x2F;java 状态说明：123456789101112131415161718192021LISTEN：侦听来自远方的TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态 更多命令： 12netstat -ntlp &#x2F;&#x2F;查看当前所有tcp端口netstat -ntulp | grep 80 &#x2F;&#x2F;查看所有80端口使用情况 kill​ 在查到端口占用的进程后，如果要杀掉对应的进程，可以使用kill命令： 1kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;] 参数说明： -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称。 -s &lt;信息名称或编号&gt; 指定要送出的信息。 [程序] [程序]可以是程序的PID或是PGID，也可以是工作编号。 使用 kill -l 命令列出所有可用信号。最常用的信号是： 1 (HUP)：重新加载进程。 9 (KILL)：杀死一个进程。 15 (TERM)：正常停止一个进程。 如上实例，我们看到 8000 端口对应的 PID 为 26993，使用以下命令杀死进程： kill -9 23237 显示信号： 123456789101112131415# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux vi和vim","slug":"Linux vi和vim","date":"2020-12-22T02:09:00.000Z","updated":"2020-12-28T09:56:00.000Z","comments":true,"path":"Linux vi和vim.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%20vi%E5%92%8Cvim.html","excerpt":"​ 记录关于 Vi和Vim 相关的一些内容","text":"​ 记录关于 Vi和Vim 相关的一些内容 vi/vim 的使用vi命令 是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 vi/vim 的三种模式命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。 N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 **:q!**。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux查看日志","slug":"Linux查看日志","date":"2020-12-21T11:24:00.000Z","updated":"2020-12-22T02:06:00.000Z","comments":true,"path":"Linux查看日志.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html","excerpt":"​ 作为一名测试工程师，测试任务中和Linux打交道的地方有很多，比如查看日志、定位bug、修改文件、部署环境等。产品部署在linux上，如果某个功能发生错误，就需要去排查出错的原因，所以熟练的掌握查看log的方法显得尤为重要。","text":"​ 作为一名测试工程师，测试任务中和Linux打交道的地方有很多，比如查看日志、定位bug、修改文件、部署环境等。产品部署在linux上，如果某个功能发生错误，就需要去排查出错的原因，所以熟练的掌握查看log的方法显得尤为重要。 最常使用的命令1234567cat：由第一行开始显示文件内容tac：从最后一行开始显示，不知道你是否观察出来，tac是cat倒着写的，所以功能上两个是相反的nl：显示的时候，同时输出行号 more：一页一页地显示文件内容less：与more类似，相比于more，可以往前翻页head：只看前面几行tail：只看后面几行 cat、tac、nl想要直接查看一个文件的内容，可以使用cat，tac，nl命令 cat1234567891011121314151617cat --helpUsage: cat [OPTION]... [FILE]...Concatenate FILE(s), or standard input, to standard output. -A, --show-all 相当于-vET的整合，可列出一些特殊字符而不是空白而已； -b, --number-nonblank 列出行号，仅针对非空白行做出行号显示，空白行不标行号； -e 相当于 -vE -E, --show-ends 将结尾的换行符$显示出来； -n, --number 打印出行号，连同空白行也会有行号，与-b的选项不同； -s, --squeeze-blank 抑制重复的空输出行 -t 相当于 -vT -T, --show-tabs 将[tab]按键以^I显示出来 ； -u (ignored) -v, --show-nonprinting 列出一些看不出来的特殊字符； --help display this help and exit --version output version information and exit tac123456789101112tac --helpUsage: tac [OPTION]... [FILE]...Write each FILE to standard output, last line first.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too. -b, --before 在行前附加分隔符代替在行尾附加分隔符。 -r, --regex 将分隔符作为正则表达式来解析。 -s, --separator=STRING 使用指定字符串代替换行作为分隔标志。 --help display this help and exit --version output version information and exit nl12345678910111213141516171819202122232425262728293031323334353637383940414243nl --helpUsage: nl [OPTION]... [FILE]...Write each FILE to standard output, with line numbers added.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too. -b, --body-numbering=STYLE 指定行号指定的方式 -b a 表示不论是否为空行，也同样列出行号 -b t 如果有空行，空的那一行不要列出行号 -d, --section-delimiter=CC 使用指定的CC 分割逻辑页数 -f, --footer-numbering=STYLE 使用指定样式编号文件的页脚行目 -h, --header-numbering=STYLE 使用指定样式编号文件的页眉行目 -i, --line-increment=NUMBER 设置每一行遍历后的自动递增值 -l, --join-blank-lines=NUMBER 设置数值为多少的若干空行被视作一行 -n, --number-format=FORMAT 列出行号表示的方法 -n ln 行号在屏幕的最左方表示 -n rn 行号在自己栏位的最右方显示，且不加0 -n rz 行号在自己栏位的最右方显示，且加0 -p, --no-renumber 在逻辑页数切换时不将行号值复 -s, --number-separator=STRING 可能的话在行号后添加字符串 -v, --starting-line-number=NUMBER 每个逻辑页上的第一行的行 -w, --number-width=NUMBER 行号栏位的占用的字符数 --help display this help and exit --version output version information and exit默认的选项设置是-v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn。CC 是用于分隔逻辑页数的两个分界符，其中缺失的第二个字符暗含了&quot;:&quot;，如果您要指定&quot;\\&quot;，请输入&quot;\\\\&quot;。可用的样式如下： a 表示不论是否为空行，也同样列出行号 t 如果有空行，空的那一行不要列出行号 n 不编行号 pBRE 只对符合正则表达式BRE 的行编号FORMAT is one of: ln 行号在屏幕的最左方表示,且不加0 rn 行号在自己栏位的最右方显示，且不加0 rz 行号在自己栏位的最右方显示，且加0GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;For complete documentation, run: info coreutils &#x27;nl invocation&#x27; ​ nl可以将输出的文件内容自动地加上行号，其默认的结果与cat -n不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等的功能。 head、tail​ 只想关注日志内容的前一段或者最后一段的内容，可以使用 head、tail head（取出前面几行）12345head [-n number] 文件常用的选项与参数：-n : 后面接数字，代表显示几行的意思。# 默认情况下是显示前10行，如果想要显示前20行，使用head -n 20 文件# 行数可以为正数，也可以为负数。 tail（取出后面几行）12345tail [-n number] 文件选项与参数：-n : 后面接数字，代表显示几行的意思。-f : 表示持续刷新显示后面所接文件中的内容，按下ctrl -c 才会结束# 默认情况下是显示最后10行，如果想要显示最后20行，使用tail -n 20 文件 more、less​ 可以使用more和less命令，一页一页的查看文件的内容。 more(一页一页翻动)12345678more 文件--More--(52%) #这一行为重点，如果文件内容行数大于屏幕输出的行数时，就会展示出目前文件展示的百分比，此时光标也会停留在这里等待你输入信息，在more展示文件时，可以使用以下几个常用功能键：1. 空格键（space）: 代表向下翻一页2. Enter ：代表向下翻一行3. &#x2F;字符串 ：代表在这个显示的内容中，向下查找字符串这个关键词4. :f ：立刻显示出文件名以及当前显示的行数5. q : 代表立刻离开more，不再显示该文件内容6. b或[ctrl]-b ：代表往回翻页 less(一页一页翻动)123456789101112less 文件末行显示文件名 #这一行等待你输入信息,展示文件时，有几个功能按键可供使用：1. 空格键（space）: 代表往下翻动一页2. [pagedown] ：代表向下翻动一页3. [pageup] ：代表向上翻动一页4. &#x2F;字符串 ：向下查找字符串这个关键词5. ?字符串 ：向上查找字符串这个关键词6. n : 重复前一个查找（与&#x2F;或？有关）7. N：反向的重复前一个查找（与&#x2F;或？有关）8. g：前进到这个数据的第一行9. G：前进到这个数据的最后一行10. q : 退出 ​ 对比less和more，less的用法更加的灵活，more的缺点是没有办法向前翻页，只能往后翻，但是less既能往后翻也能往前翻页。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"mock工具moco","slug":"mock工具Moco","date":"2020-12-19T05:47:00.000Z","updated":"2021-06-24T15:29:30.000Z","comments":true,"path":"mock工具Moco.html","link":"","permalink":"https://www.lauyongyi.cn/mock%E5%B7%A5%E5%85%B7Moco.html","excerpt":"记录mock工具moco的一些基本操作","text":"记录mock工具moco的一些基本操作 项目地址与下载地址项目地址 https://github.com/dreamhead/moco 下载地址： https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/1.1.0/moco-runner-1.1.0-standalone.jar （此链接为2020.12.19日的版本） 如果需要最新的，可以到项目地址下，如图所示位置下载 Moco的优缺点：Moco的优点： 支持http、https、socket 支持设置headers、cookies、statuscode 支持GET、POST、PUT、DELETE请求 只需JRE环境即可运行 支持热更新 支持json、xml、text、file数据格式 能与JUnit、Maven、Gradle集成 Moco的缺点：​ Moco的使用很简单，配置也很方便。但也仅仅是能Stub出接口，模拟出简单的场景。 ​ 如果接收到请求后需要做一些处理，如需查询数据库、运算、或者一些复杂的操作，就无能为力了。 配置与启动：配置：​ 首先，下载好moco后，新建一个文件夹，用来存在 moco的jar和运行所需的json文件 这里暂时将接送文件名为 moce_test.json 启动命令：java -jar moco-runner-&lt;version&gt;-standalone.jar http -p 12306 -c moce_test.json 命令解释：&lt;version&gt; 是指下载的moco jar的版本 -p 为端口，可以自行指定，指定端口没有占用即可 -c 是配置所需的文件 json配置：设定URIJSON中无法添加注释，利用description字段可以清楚的说明接口的功能。 带参数GET请求http://localhost:12306/getparam?id=1&amp;status=100，参数通过queries设置k-v对。 带参数POST请求，参数通过forms设置k-v对，需要通过工具发送POST请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ &#123; &quot;description&quot;: &quot;设定URI&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/uri&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;Hello Moco GET URI&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;无参GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/get&quot;, &quot;method&quot;: &quot;get&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;无参GET请求返回-success&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;带参GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/getparam&quot;, &quot;method&quot;: &quot;get&quot;, &quot;queries&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;带参GET请求返回-success&quot; &#125; &#125;,&#123; &quot;description&quot;: &quot;带参数POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/postparam&quot;, &quot;method&quot;: &quot;post&quot;, &quot;forms&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;带参POST请求返回-success&quot;, &quot;headers&quot;: &#123; &quot;Content-Type&quot;: &quot;text/html;charset=gbk&quot; &#125; &#125;&#125;] 设定Headers及请求返回为JSON 1234567891011121314151617181920[&#123; &quot;description&quot;: &quot;带headers信息POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/post/headers&quot;, &quot;method&quot;: &quot;post&quot;, &quot;headers&quot;: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, &quot;json&quot;: &#123; &quot;name&quot;: &quot;isisiwish&quot;, &quot;sex&quot;: &quot;male&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;json&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125;&#125;] 设定Cookies如果不获取cookies，直接访问http://localhost:12306/get/with/cookies，则返回失败； 如果首先访问http://localhost:12306/getcookies，获取到服务器cookies，再访问http://localhost:12306/get/with/cookies，不用额外设定cookies也可以获得正确返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[&#123; &quot;description&quot;: &quot;返回cookies信息的GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/getcookies&quot;, &quot;method&quot;: &quot;get&quot; &#125;, &quot;response&quot;: &#123; &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125;, &quot;text&quot;: &quot;get cookies success&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;携带cookies信息的GET请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/get/with/cookies&quot;, &quot;method&quot;: &quot;get&quot;, &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;the cookies is okay&quot; &#125; &#125;, &#123; &quot;description&quot;: &quot;携带cookies信息的POST请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/post/with/cookies&quot;, &quot;method&quot;: &quot;post&quot;, &quot;cookies&quot;: &#123; &quot;key&quot;: &quot;63A9F0EA7BB98050796B649E85481845&quot; &#125;, &quot;json&quot;: &#123; &quot;name&quot;: &quot;isisiwish&quot;, &quot;age&quot;: &quot;30&quot; &#125; &#125;, &quot;response&quot;: &#123; &quot;status&quot;: 200, &quot;json&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;status&quot;: &quot;100&quot; &#125; &#125; &#125;] 使用postman或jmeter等接口测试工具是，需要配置cookies信息 postman 添加cookies时一定要修改 Domain的值，需要对应的域名 jmeter 需要添加对应的域和路径。 路径默认 / 重定向123456789101112131415161718192021222324[&#123; &quot;description&quot;: &quot;绝对路径重定向&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect&quot; &#125;, &quot;redirectTo&quot;: &quot;https://www.baidu.com/&quot; &#125;, &#123; &quot;description&quot;: &quot;相对重定向&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect/top&quot; &#125;, &quot;redirectTo&quot;: &quot;/redirect/max&quot; &#125;, &#123; &quot;description&quot;: &quot;被重定向的请求&quot;, &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/redirect/max&quot; &#125;, &quot;response&quot;: &#123; &quot;text&quot;: &quot;top == max&quot; &#125; &#125;] 返回类型为file内容对于比较大的JSON，可以通过文件方式返回。 需要先创建一个 data.json 文件 12345678[&#123; &quot;request&quot;: &#123; &quot;uri&quot;: &quot;/file&quot; &#125;, &quot;response&quot;: &#123; &quot;file&quot;: &quot;data.json&quot; &#125;&#125;]","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"}]},{"title":"记某数据处理公司的面试记录","slug":"20201105面试题记录","date":"2020-11-05T09:30:00.000Z","updated":"2020-11-06T06:39:00.000Z","comments":true,"path":"20201105面试题记录.html","link":"","permalink":"https://www.lauyongyi.cn/20201105%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95.html","excerpt":"记录一下某数据处理公司的笔试题","text":"记录一下某数据处理公司的笔试题 什么是敏捷研发，测试在什么阶段介入，分别做什么？参考链接：阮一峰：敏捷开发入门教程，知乎敏捷测试宣言 敏捷开发是：迭代开发+增量开发 迭代开发：将一个大任务，分解成多次连续的开发，本质就是逐步改进 增量开发：指的是软件的每个版本，都会新增一个用户可以感知的完整功能 全程的测试介入敏捷测试提倡测试左移和右移，从软件生命周期的早期（左侧）一直到产品发布上线后的生产环境，都需要有测试的介入和测试活动的开展。 左移是为了更好的理解和澄清需求，以减少需求理解不一致导致的浪费；而右移是充分利用生产环境的数据来优化开发和测试流程，以增强软件系统应对各种不可预测性的能力。 左移和右移并不仅仅是将测试活动移到两侧端点，更强调的是每个环节的参与，也就是全程测试介入，这是从流程上保障高质量软件交付的关键。 如何写好测试用例？见仁见智的问题，可以从以下几方面去写： 1、要参与需求评审，评审需求的过程实际也是熟悉业务需求的过程 2、要多阅读文档，其中包括产品策划书、规格说明书、需求文档，接口文档等 3、尽量多参加项目组内的会议 4、要善于沟通，多和客户、开发、测试人员进行沟通 5、测试用例名称，也叫测试用例标题，一定要写得简洁、明了，需要用概括的语言描述该用例的出发点和关注点，使得测试人员第一眼看到测试用例名称就能够明白测试用例的目的 6、预置条件要明确，包括测试环境、测试数据、测试场景 7、测试步骤描述要简单、清晰，并且要清楚每一个步骤的描述 8、用例的预期结果要完整而且清晰，并且要将各个输出的结果写出来、 9、测试用例级别要划分清楚 10、测试用例的划分也要单一，一个测试用例只检查功能点的一种情况 11、召开测试用例评审会议 12、站在用户的角度来设计用例 13、测试用例需要不断更新和维护 Redis和MySQL有什么区别？分别用在什么场景？介绍​ MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。 ​ Redis 是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但保存时间有限。 区别​ 1、类型上：​ Mysql是关系型数据库，redis是非关系型数据库 ​ 2、作用上：​ MySQL用于持久化存储数据到硬盘，功能强大，但速度较慢​ Redis用于存储使用较为频繁的数据到缓存中，读取速度快 ​ 3、需求上：​ MySQL和Redis因为需求的不同，一般都是配合使用 ​ 4、数据存放位置：​ MySQL存储在硬盘。Redis存储在内存 ​ 5、场景选型：​ Redis适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。​ MySQL适用于需要持久化，大量存储数据的系统。​ Redis和MySQL都要要根据具体业务场景去选型. ​ 6、适合存放的数据类型：​ Redis适合放一些频繁使用的数据，例如：排行版，计数器，消息队列推送，好友关注，点赞等。​ MySQL适合存放一些持久化，且不需要频繁调用的数据，例如：家庭住址等。 数据库中什么是死锁？一般是什么原因导致的？参考来源百度百科：数据库死锁 死锁：多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程A等待进程B释放他的资源，B又等待A释放他的资源，这样就互相等待就形成死锁。 死锁产生必要条件1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 死锁产生的原因一般情况只发生锁超时，就是一个进程需要访问数据库表或者字段的时候，另外一个程序正在执行带锁的访问（比如修改数据），那么这个进程就会等待，当等了很久锁还没有解除的话就会锁超时，报告一个系统错误，拒绝执行相应的SQL操作。 发生死锁的情况比较少，比如一个进程需要访问两个资源（数据库表或者字段），当获取一个资源的时候进程就对它执行锁定，然后等待下一个资源空闲，这时候如果另外一个进程也需要两个资源，而已经获得并锁定了第二个资源，那么就会死锁，因为当前进程锁定第一个资源等待第二个资源，而另外一个进程锁定了第二个资源等待第一个资源，两个进程都永远得不到满足。 左内右连接有什么区别？什么是索引，通常哪些具体情况要加索引?​ 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。​ 左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。​ 右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。 ​ 索引用于在数据库中快速地创建和检索数据。 要加索引的情况： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 不需要加索引的情况： 对于那些在查询中很少使用或者参考的列不应该创建索引。 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 绝对路径和相对路径的区别，无权限执行的执行文件一般报错是什么？如何赋予执行权限？绝对路径和相对路径的区别​ 相对路径：以引用文件的文件所在位置为参考基础，而建立出的目录路径。 ​ 绝对路径：以根目录为参考基础的目录路径。 ​ 区别： ​ 绝对路径就是写死的路径,缺点是换设备会出现路径找不到问题 ​ 相对路径就是灵活的路径,优点是不会因为设备更换出现路径问题。 无权限执行的执行文件一般报错是什么？如何赋予执行权限？​ 在执行Linux命令式，报错为：permission denied ​ 执行命令：上调权限：chmod 777或者chmod -R +x 或者使用授权语句 chmod -R 755 * shell指令中与网络相关的有哪些？分别对应什么功能？​ 常用的网络相关的命令有以下几个： ifconfig：用于显示网络接口，子网掩码 host和nslookup：DNS查找工具，当执行host是，会列出某个域名所有IP；nslookup是一个类似于host的命令，它用于查询DNS相关的细节信息，以及名字解析 route：显示路由表 traceroute：显示分组途径的所有网关地址 补充问题：netstat、ping、ifconfig这三个的区别，分别是什么功能，netstat里面一般服务器启动后的端口状态是什么 netstat:显示网络状态，利用netstat可以让你得知整个Linux系统的网络情况，语法为netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip] ping:功能是检测主机，因为执行ping命令会使用icmp传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常，语法为：ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址] ifconnfig：功能是显示或设置网络设备，其语法为：ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址] 服务器启动后一般为listening状态 怎么测试一种网络协议，可以假设HTTP或FTP？​ 协议测试主要关注三方面：一致性，互操作性，性能。 一致性测试：主要测试协议实现是否严格遵循相应的协议描述。 互操作性测试：对于同一个协议标准，不同协议时间之间的互联通问题。 性能测试：用实验的方法来观测被测协议实现葛总性能参数，如吞吐量和传输延迟。 如何测试一个系统的稳定性？参考链接测试教程网 压力测试（强度测试）压力测试方法测试系统在一定饱和状态下，例如CPU、内存在饱和使用情况下，系统能够处理的会话能力，以及系统是否会出现错误。 特点： 这种测试方法的主要目的是检查系统处于压力性能下时，应用的表现。 这种测试方法一般通过模拟负载等方法，使得系统的资源使用达到较高的水平。 这种测试方法一般用于测试系统的稳定性。 也就是说，这种测试是让系统处在很大强度的压力之下，看系统是否稳定，哪里会出问题。 配置测试配置测试方法通过对被测系统的软\\硬件环境的调整，了解各种不同对系统的性能影响的程度，从而找到系统各项资源的最优分配原则。 特点： 这种性能测试方法的主要目的是了解各种不同因素对系统性能影响的程度，从而判断出最值得进行的调优操作。 这种性能测试方法一般在对系统性能状况有初步了解后进行。 这种性能测试方法一般用于性能调优和规划能力。 也就是说，这种测试关注点是“微调”，通过对软硬件的不段调整，找出这他们的最佳状态，使系统达到一个最强的状态。 可靠性测试在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。 特点： 这种性能测试方法的主要目的是验证是否支持长期稳定的运行。 这种性能测试方法需要在压力下持续一段时间的运行。 测试过程中需要关注系统的运行状况。 也就是说，这种测试的关注点是“稳定”，不需要给系统太大的压力，只要系统能够长期处于一个稳定的状态。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.lauyongyi.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"session,cookie,token的区别","slug":"session，cookie，token","date":"2020-11-04T08:52:00.000Z","updated":"2020-11-04T09:31:30.000Z","comments":true,"path":"session，cookie，token.html","link":"","permalink":"https://www.lauyongyi.cn/session%EF%BC%8Ccookie%EF%BC%8Ctoken.html","excerpt":"Session，Cookie，token是测试工作中，经常听到的有关验证的方式，这里主要记录这三者的一些区别","text":"Session，Cookie，token是测试工作中，经常听到的有关验证的方式，这里主要记录这三者的一些区别 三者的作用Session 对象存储特定用户会话所需的属性及配置信息 Cookie 是“小型文本文件”，是网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常有加密），由用户客户端计算机暂时或永久保存的信息 Token 在计算机身份认证中是令牌（临时）的意思，在词法分析中是标记的意思。一般作为邀请、登录系统使用。 三者的区别1、浏览器接受服务器的Set-Cookie 指令，并把cookie保存到电脑上，每个网站保存的cookie只作用于自己的网站 2、Session 就是数据存储到服务端，只把关联数据的一个加密串放到cookie中标记 3、凭借认证信息获取token，或者通过后台配置好token，在相关请求中使用token，多数是以query参数的形式提供 4、token 是一个用户请求时附带的请求字段，用于验证身份和权限 5、Session 可以基于cookie，也可以基于query参数，用于关联用户相关数据 6、Android 原生系统（除非使用webview）不支持cookie，需要用token识别用户身份，还需要把sessionid保存到http请求中的header或者query字段中。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.lauyongyi.cn/tags/http/"}]},{"title":"shell基础进阶","slug":"shell基础进阶","date":"2020-10-22T05:30:00.000Z","updated":"2020-10-22T08:20:30.000Z","comments":true,"path":"shell基础进阶.html","link":"","permalink":"https://www.lauyongyi.cn/shell%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6.html","excerpt":"记录shell相关的进阶知识","text":"记录shell相关的进阶知识 判断的类型❖ 算术判断1234567891011121314[root@VM-0-12-centos ~]# [ 2 -eq 2 ];echo $? #如果两个表达式相等，则结果为真0[root@VM-0-12-centos ~]# [ 2 -ne 2 ];echo $? #如果两个表达式不等，则结果为真1[root@VM-0-12-centos ~]# [ 3 -gt 1 ];echo $? #如果前⼀个表达式⼤于后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -ge 3 ];echo $? #如果前⼀个表达式&gt;=后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -lt 4 ];echo $? #如果前⼀个表达式&lt;后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# [ 3 -le 3 ];echo $? #如果前⼀个表达式&lt;=后⼀个表达⼯，则结果为真0[root@VM-0-12-centos ~]# ((8&gt;=10));echo $? #(())也可以表⽰算术⽐较。1 ❖ 字符串判断 [ string1 = string2 ]如果两字符串相同,则结果为真 \\ 1234[root@VM-0-12-centos test]# [ &#x27;aa&#x27; = &#x27;aa&#x27; ];echo $?0[root@VM-0-12-centos test]# [ &#x27;aa&#x27; = &#x27;aA&#x27; ];echo $?1 [ string1 != string2 ] 如果两字符串不相同,则结果为真 1234[root@VM-0-12-centos test]# [ &#x27;aa&#x27; != &#x27;aA&#x27; ];echo $?0[root@VM-0-12-centos test]# [ &#x27;aa&#x27; != &#x27;aa&#x27; ];echo $?1 [ -n string ] 如果字符串不是空,则结果为真 1234[root@VM-0-12-centos test]# [ -n &#x27;&#x27; ];echo $?1[root@VM-0-12-centos test]# [ -n &#x27;aaa&#x27; ];echo $?0 [ -z string ] 如果字符串是空,则结果为真 1234[root@VM-0-12-centos test]# [ -z &#x27;aaa&#x27; ];echo $?1[root@VM-0-12-centos test]# [ -z &#x27;&#x27; ];echo $?0 [[ “xxxx” == x* ]] 在表达式中表⽰0或者多个字符 12345678910[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == a* ]];echo $?0[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == b* ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aa&#x27; == *a ]];echo $?0[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == *a ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a* ]];echo $?0 [[ xxx == x?? ]] 在表达式中表⽰单个字符 123456[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a? ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a??b ]];echo $?1[root@VM-0-12-centos test]# [[ &#x27;aab&#x27; == a?b ]];echo $?0 ❖ 逻辑判断12345678910[root@VM-0-12-centos ~]# [ ! 100 -ge 1 ];echo $? #非1[root@VM-0-12-centos ~]# [ 2 -ge 1 -a 3 -ge 4 ];echo $? #与1[root@VM-0-12-centos ~]# [ 2 -ge 1 -o 3 -ge 4 ];echo $? #或0[root@VM-0-12-centos ~]# [[ 2 -ge 1 &amp;&amp; 3 -ge 4 ]];echo $? #与1[root@VM-0-12-centos ~]# [[ 2 -ge 1 || 3 -ge 4 ]];echo $? #或0 ❖ shell内置判断 -e file 如果⽂件存在，则结果为真 1234[root@VM-0-12-centos test]# ls1.sh newtest[root@VM-0-12-centos test]# [ -e 1.sh ];echo $?0 -d file 如果⽂件是⼀个⼦⽬录，则结果为真 12345[root@VM-0-12-centos test]# [ -d test ];echo $?1[root@VM-0-12-centos test]# [ -d newtest ];echo $?0 -f file 如果⽂件是⼀个普通⽂件，则结果为真 1234[root@VM-0-12-centos test]# [ -f newtest ];echo $?1[root@VM-0-12-centos test]# [ -f 1.sh ];echo $?0 -r file 如果⽂件可读，则结果为真 -s file 如果⽂件的长度不为0，则结果为真 12345678[root@VM-0-12-centos test]# lltotal 4--w--w--w- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# [ -s 1.sh ];echo $?1[root@VM-0-12-centos test]# [ -s newtest ];echo $?0 -w file 如果⽂件可写，则结果为真 -x file 如果⽂件可执⾏，则结果为真 12345678910[root@VM-0-12-centos test]# lltotal 4-rw-rw-rw- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# [ -x newtest ];echo $?0[root@VM-0-12-centos test]# [ -x 1.sh ];echo $?0[root@VM-0-12-centos test]# [ -x 1.sh ];echo $?1 [[]]是[]的扩展语法，在⽼的sh⾥并不⽀持。推荐⽤[] 逻辑控制条件 if❖ if [ condition ] ; then …;fi1234567[root@VM-0-12-centos test]# lltotal 4-rw-r--r-- 1 root root 0 Oct 22 14:59 1.shdrwxr-xr-x 2 root root 4096 Oct 22 14:59 newtest[root@VM-0-12-centos test]# if [ -e newtest ];then echo exist;fiexist[root@VM-0-12-centos test]# if [ -e test ];then echo exist;fi ❖ if [ condition ] ; then …;else …;fi1234[root@VM-0-12-centos test]# if [ -e test ];then echo exist;else echo not exist;finot exist[root@VM-0-12-centos test]# if [ -e newtest ];then echo exist;else echo not exist;fiexist ❖ if [ condition ] ; then …;elif …;fi12[root@VM-0-12-centos test]# if [ -e test ];then echo test;elif [ -e newtest ];then echo newtest;else echo null;finewtest ❖ 简单的逻辑可以使⽤ &amp;&amp; || 去替代123456789101112[root@VM-0-12-centos test]# [ -e newtest ]&amp;&amp;echo exist||echo not existexist[root@VM-0-12-centos test]# [ -e test ]&amp;&amp;echo exist||echo not existnot exist# 首先执行echo&quot;1&quot;,然后执行2，因为是选择2或3，已经执行2，所以忽略3。其他同理[root@VM-0-12-centos test]# echo &quot;1&quot; &amp;&amp; echo &quot;2&quot; || echo &quot;3&quot; &amp;&amp; echo &quot;4&quot; || echo &quot;5&quot; || echo &quot;6&quot; &amp;&amp; echo &quot;7&quot; &amp;&amp; echo &quot;8&quot; || echo &quot;9&quot;12478 ❖ 条件可以⽤命令返回值代替 分⽀ case⽤于条件太多的情况。每⼀个条件最后使⽤两个分号结尾，不可缺少。 1234567case $var in p1) … ;; p2) … ;; … pn) … ;; *) …;; esac for 循环格式：123for(( c1 ; c2 ; c3 )); do … ;done 例子：1234567891011[root@VM-0-12-centos test]# for ((i=0;i&lt;10;i++));do echo $i;done01...9[root@VM-0-12-centos test]# array=(1 2 3 4 5)[root@VM-0-12-centos test]# for ((i=0;i&lt;$&#123;#array[*]&#125;;i++))do echo $i;done01..4 for循环遍历⽤于递归数组，还可以递归以空格隔开的字符串序列。或者是某个命令的返回值。 格式123for f in $array[*];do …..done 例子12345678[root@VM-0-12-centos test]# for x in $&#123;array[@]&#125;;do echo $x;done1...5[root@VM-0-12-centos test]# ss=(aa bb cc &quot;sss dd&quot;);for x in &quot;$&#123;ss[@]&#125;&quot;;do echo $x;doneaabbcc while 循环格式 1234name=valuewhile [xxxxxx];do ....;done 例子 1234[root@VM-0-12-centos test]# i=0;while [ $i -lt 3 ];do echo $i;((i=i+1));done012 ⼀个有⽤的⼩技巧。⼀⾏⾏的读取⽂件内容 while read line;do echo $line;done &lt; /路径/文件名 等价于 cat untilselect Select var in var_list;do ….;done; 菜单选择，⼀般与case结构⼀起⽤ Break 和 continue break 退出当前循环。默认为1 break 2 退出两层循环。 continue 跳过当前的循环，进⼊下⼀次循环。 continue 2 跳到上层循环的下⼀次循环中 return 函数返回 exit 脚本退出","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"}]},{"title":"shell基础","slug":"shell基础","date":"2020-10-20T08:57:00.000Z","updated":"2020-10-22T06:20:30.000Z","comments":true,"path":"shell基础.html","link":"","permalink":"https://www.lauyongyi.cn/shell%E5%9F%BA%E7%A1%80.html","excerpt":"记录shell学习过程中的一些知识点","text":"记录shell学习过程中的一些知识点 Shell 运⾏环境概念 bash是⼀个进程 ​ bash下还可以再重新启动⼀个shell，这个shell是sub shell，原shell会复制 ⾃⾝给他 ​ 在sub shell中定义的变量，会随着sub shell的消亡⽽消失 () ⼦shell中运⾏ {} 当前shell中执⾏ $$ 当前脚本执⾏的pid &amp; 后台执⾏ $!运⾏在后台的最后⼀个作业的PID(进程ID) 常用命令​ echo 用于字符串的输出 ​ 使用 $var 或 ${var} 来访问变量。后者更为严谨。 ​ 变量不需要定义也可以使用。引用未定义的变量，默认为空值 1234567[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# echo $a1[root@VM-0-12-centos ~]# echo $a_1[root@VM-0-12-centos ~]# echo $&#123;a&#125;_11_1 变量定义变量定义方法/原则= 左右不能有空格12[root@VM-0-12-centos ~]# a = 1-bash: a: command not found 如果内容有空格，需要使用单引号或者双引号12345[root@VM-0-12-centos ~]# a=hello word-bash: word: command not found[root@VM-0-12-centos ~]# a=&#x27;hello word&#x27;[root@VM-0-12-centos ~]# echo $ahello word 双引号用于括起一段字符串值，支持$var 形式的变量替换​ 单引号也可以表示其内容是字符串值，不支持转义 12345[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# echo &#x27;hello $a&#x27;hello $a[root@VM-0-12-centos ~]# echo &quot;hello $a&quot;hello 1 \\反斜线， 某些情况下表示转义123[root@VM-0-12-centos ~]# a=&quot;hello world \\&quot;haha\\&quot;&quot;[root@VM-0-12-centos ~]# echo $ahello world &quot;haha&quot; ​ $开头的变量会被自动替换 大小写敏感123456[root@VM-0-12-centos ~]# a=1[root@VM-0-12-centos ~]# A=2[root@VM-0-12-centos ~]# echo $a1[root@VM-0-12-centos ~]# echo $A2 `反引号可以执行命令1234567[root@VM-0-12-centos ~]# a=`ls`[root@VM-0-12-centos ~]# echo $aapache-ant-1.9.15-bin.tar.gz apache-jmeter-5.3.tgz chromedriver_linux64.zip chromedriver_linux64.zip.1 employees_db employees_db-full-1.0.6.tar.bz2 gradle-6.3-all.zip jdk-8u261-linux-x64.tar.gz learning-API-test mysql-community-release-el7-5.noarch.rpm openssl openssl-1.1.1h openssl-1.1.1h.tar.gz Python-3.8.5 Python-3.8.5.tgz Python-3.8.5.tgz.1 sdk-tools-linux-3859397.zip[root@VM-0-12-centos ~]# dateTue Oct 20 17:47:24 CST 2020[root@VM-0-12-centos ~]# echo `date`Tue Oct 20 17:47:27 CST 2020 ({1..10}) 等价于 seq 1 10。表示1到10123[root@VM-0-12-centos ~]# a=(&#123;1..10&#125;)[root@VM-0-12-centos ~]# echo $&#123;a[*]&#125;1 2 3 4 5 6 7 8 9 10 $(()) 对变量进行操作。比如相加123456[root@VM-0-12-centos ~]# a=2;b=4[root@VM-0-12-centos ~]# echo $((a+b))6[root@VM-0-12-centos ~]# c=5;d=10;e=10[root@VM-0-12-centos ~]# echo $((c*d-e))40 变量类型 字符串： a=“xxxx”取值 $&#123;value:offset&#125; $&#123;value:offset:length&#125; 从变量中提取⼦串 123456789[root@VM-0-12-centos ~]# a=&quot;hello shell by linux&quot;[root@VM-0-12-centos ~]# echo $&#123;a:6&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a:6:6&#125;shell[root@VM-0-12-centos ~]# echo $&#123;a:6:3&#125;she[root@VM-0-12-centos ~]# echo $&#123;a:6:10&#125;shell by l $&#123;#value&#125; 字符串长度 123[root@VM-0-12-centos ~]# a=&quot;hello shell by linux&quot;[root@VM-0-12-centos ~]# echo $&#123;#a&#125;20 $&#123;#array[*]&#125;和$&#123;#array[@]&#125;表⽰数组中元素的个数 数组变量 括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 1数组名&#x3D;(值1 值2 ... 值n) 例如： 1array_name&#x3D;(value0 value1 value2 value3) 读取数组 读取数组元素值的一般格式是： ${数组名[下标[^1]]} [^1]: 从 0 开始 例如： 1valuen&#x3D;$&#123;array_name[n]&#125; 使用 @ 符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length&#x3D;$&#123;#array_name[@]&#125;# 或者length&#x3D;$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn&#x3D;$&#123;#array_name[n]&#125; 掐头去尾与内容替换 $&#123;value#pattern&#125; $&#123;value##pattern&#125; #表⽰掐头 12345678[root@VM-0-12-centos ~]# echo $&#123;a#hello&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a##hello&#125;shell by linux[root@VM-0-12-centos ~]# echo $&#123;a##*l&#125;inux[root@VM-0-12-centos ~]# echo $&#123;a#*l&#125;lo shell by linux $&#123;value%pattern&#125; $&#123;value%%pattern&#125; %表⽰去尾 12345678[root@VM-0-12-centos ~]# echo $&#123;a%linux&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%%linux&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%l*&#125;hello shell by[root@VM-0-12-centos ~]# echo $&#123;a%%l*&#125;he $&#123;value/pattern/string&#125; $&#123;value//pattern/string&#125; /表⽰替换 123456[root@VM-0-12-centos ~]# echo $ahello shell by linux[root@VM-0-12-centos ~]# echo $&#123;a/by/to&#125;hello shell to linux[root@VM-0-12-centos ~]# echo $&#123;a//by/to&#125;hello shell to linux #与## %与%% /与//的区别：最短匹配模式VS最长匹配模式 $&#123;var/#Pattern/Replacement&#125; $&#123;var/%Pattern/Replacement&#125; 1234[root@VM-0-12-centos ~]# echo $&#123;a/#hello/good&#125;good shell by linux[root@VM-0-12-centos ~]# echo $&#123;a/%linux/to&#125;hello shell by to 数字：i=12132数字型变量操作123456[root@VM-0-12-centos ~]# i=1;echo $((i+1)) #计算2[root@VM-0-12-centos ~]# ((i=i+1));echo $i #更新2[root@VM-0-12-centos ~]# awk &#x27;BEGIN&#123;print 1/3&#125;&#x27; #浮点数运算0.333333 布尔： a=true;b=false​ $?，用于输出上一条命令的执行结果，成功为0，失败为1 1234567[root@VM-0-12-centos ~]# a=5;b=10[root@VM-0-12-centos ~]# ((a&gt;b))[root@VM-0-12-centos ~]# echo $?1[root@VM-0-12-centos ~]# ((a&lt;b))[root@VM-0-12-centos ~]# echo $?0 预定义变量12345678[root@VM-0-12-centos ~]# echo $PWD/root[root@VM-0-12-centos ~]# echo $USERroot[root@VM-0-12-centos ~]# echo $HOME/root[root@VM-0-12-centos ~]# echo $PATH/usr/local/jmeter/apache-jmeter-5.3/bin:/usr/local/java/jdk1.8/bin:/usr/local/ant/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk1.8/bin:/usr/local/java/jdk1.8/jre/bin:/opt/android/sdk:/opt/android/sdk/tools:/opt/android/sdk/platform-tools:/opt/android/sdk/emulator:/opt/android/sdk/tools/bin:/opt/gradle/gradle-6.3/bin:/root/bin:/root/bin","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"}]},{"title":"接口自动化学习中遇到的问题","slug":"python接口自动化学习","date":"2020-10-19T03:50:30.000Z","updated":"2020-10-19T03:05:30.000Z","comments":true,"path":"python接口自动化学习.html","link":"","permalink":"https://www.lauyongyi.cn/python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AD%A6%E4%B9%A0.html","excerpt":"记录python+requests学习中遇到的问题，原因和解决方法","text":"记录python+requests学习中遇到的问题，原因和解决方法 CookiesJar为空在做登录请求的时候，为了持续进行访问，需要保存cookie，对登录请求的cookies打印后，发现返回为空 原因： 使用fiddler抓包得出，在登录成功后，登录请求显示302（链接重定向），怀疑是requests默认重定向，导致cookies失效 解决方法：1allow_redirects=True 设为1allow_redirects=False 重定向链接为空场景同上，需要打印重定向链接，使用下面的代码进行重定向链接打印 12new_url &#x3D; r.headers[&quot;Location&quot;]print (new_url) 但提示KeyError: ‘location’ 原因：使用fiddler抓包得出，在登录成功后，登录请求自动重定向到登录后的页面 解决方法：1allow_redirects=True 设为 1allow_redirects=False","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"python排序","slug":"python排序","date":"2020-10-16T05:50:30.000Z","updated":"2020-10-16T06:15:30.000Z","comments":true,"path":"python排序.html","link":"","permalink":"https://www.lauyongyi.cn/python%E6%8E%92%E5%BA%8F.html","excerpt":"记录python排序常用的方法和内置函数","text":"记录python排序常用的方法和内置函数 为了验证排序是否正确，采用python生成随机数的方式进行验证 123import randomlist_1 = random.sample(range(1, 50),20)) #随机取1-49之间的20个随机数，不重复print (list_1) 常用的排序算法冒泡排序：相邻两个元素比较，大的排后面，第一次把最大的数排在最后一位；继续排，把第二大的数排在倒数第二位… 冒泡排序总共排的次数为：1+2+3+…+n-1,共 n(n-1)/2，时间复杂度为n平方； 方法一1234567def dubble_sort(li): s = range(len(li))[::-1] #交换次数 for i in s: for j in range(i): if li[j] &gt; li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] # 交换元素 return li 方法二： 12345678910def dubble_sort(li): for i in range(len(li)-1):#i是索引，表示趟数 change=False for j in range(len(li)-i-1):#j是除去i个元素后的列表的索引（循环进行了几次就说明有几个元素已经被排好序） if li[j]&gt;li[j+1]: li[j],li[j+1]=li[j+1],li[j] change=True if not change: return li return li 快速排序：快速排序：选取数组的某一个数作为基准（一般选第一个最后一位）， 排列整个数值，比基准小的排到左边，比基准大的数 排在右边继续选取新生成的数值的第一个数 进行排序 方法一：123456789def quick_sort(list): if len(list) &lt; 2: # 基线条件（停止递归的条件） return list else: # 递归条件 basevalue = list[0] # 以第一个为基准值 less = [m for m in list[1:] if m &lt; basevalue] # 比基准小的 equal = [n for n in list if n == basevalue] greater = [s for s in list[1:] if s &gt; basevalue] # 比基准大的 return quick_sort(less) + equal + quick_sort(greater) 方法二：1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] 选择排序 选择排序的思路是：第一轮的时候，所有的元素都和第一个元素进行比较，如果比第一个元素大，就和第一个元素进行交换，在这轮比较完后，就找到了最小的元素；第二轮的时候所有的元素都和第二个元素进行比较找出第二个位置的元素，以此类推。 方法一：1234567def selection_sort(list): length = len(list) for i in range(length - 1, 0, -1): for j in range(i): if list[j] &gt; list[i]: list[j], list[i] = list[i], list[j] return list 方法二：1234567891011def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr 插入排序 插入排序的思想是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。 是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置）， 而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 方法： 1234567891011def insert_sort(list): count = len(list) for i in range(1, count): key = list[i] j = i - 1 while j &gt;= 0: if list[j] &gt; key: list[j + 1] = list[j] list[j] = key j -= 1 return list 希尔排序 希尔排序是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。 该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少， 每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 12345678910111213def shell_sort(lis): n = len(lis) gap = int(n / 2) while gap &gt; 0: for i in range(gap, n): temp = lis[i] j = i - gap while j &gt;= 0 and lis[j] &gt; temp: lis[j + gap] = lis[j] j = j - gap lis[j + gap] = temp gap = int(gap / 2) return lis Python内置函数排序：Python中拥有内置函数实现排序，可以直接调用它们实现排序功能 Python 列表有一个内置的 list.sort() 方法可以直接修改列表。还有一个 sorted() 内置函数，它会从一个可迭代对象构建一个新的排序列表。 sorted () 函数sorted() 函数可以对输入的迭代对象元素排序后生成新的列表。sorted(iterable, cmp=None, key=None, reverse=False) 其中： iterable – 可迭代对象。 cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 示例：12345678&gt;&gt;&gt; sorted([3,7,2,8,5])[2, 3, 5, 7, 8]&gt;&gt;&gt; a = [[6, 5], [3, 7], [2, 8]]&gt;&gt;&gt; sorted(a, key=lambda x:x[0]) # 根据每一行的首元素排序，默认reverse=False[[2, 8], [3, 7], [6, 5]]&gt;&gt;&gt; sorted(a, key=lambda x:x[-1]) # 根据每一行的尾元素排序，设置reverse=True实现逆序[[6, 5], [3, 7], [2, 8]] sort()函数1list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False) 其中参数的含义是： cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。 示例：123list = [1,6,7,8,2,4,3,5,9]list.sort()print(list) sort()和sorted()虽然相似，都可以实现排序功能，但是它们有很大的不同： sort ()与sorted()区别：sort() 是应用在 list 上的方法，sorted() 可以对所有可迭代的对象进行排序操作。 list 的 sort() 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted() 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"SQL连接","slug":"SQL连接查询","date":"2020-10-16T04:38:00.000Z","updated":"2020-10-16T04:38:00.000Z","comments":true,"path":"SQL连接查询.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.html","excerpt":"SQL 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。","text":"SQL 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。 考虑下面两个表，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）另一个表是 ORDERS 表： 12345678+-----+---------------------+-------------+--------+|OID | DATE | CUSTOMER_ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这个两张表连接（JOIN）在一起： 123SQL&gt; SELECT ID, NAME, AGE, AMOUNT FROM CUSTOMERS, ORDERS WHERE CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句的运行结果如下所示： 12345678+----+----------+-----+--------+| ID | NAME | AGE | AMOUNT |+----+----------+-----+--------+| 3 | kaushik | 23 | 3000 || 3 | kaushik | 23 | 1500 || 2 | Khilan | 25 | 1560 || 4 | Chaitali | 25 | 2060 |+----+----------+-----+--------+ SQL 连接类型SQL 中有多种不同的连接： 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。 左连接（LEFT JOIN）：返回左表中的所有行，即使右表中没有匹配的行。 右连接（RIGHT JOIN）：返回右表中的所有行，即使左表中没有匹配的行。 全连接（FULL JOIN）：只要某一个表存在匹配，就返回行。 笛卡尔连接（CARTESIAN JOIN）：返回两个或者更多的表中记录集的笛卡尔积。 内连接最常用也最重要的连接形式是内连接，有时候也被称作“EQUIJOIN”（等值连接）。 内连接根据连接谓词来组合两个表中的字段，以创建一个新的结果表。SQL 查询会比较逐个比较表 1 和表 2 中的每一条记录，来寻找满足连接谓词的所有记录对。当连接谓词得以满足时，所有满足条件的记录对的字段将会结合在一起构成结果表。 语法：内连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1INNER JOIN table2ON table1.common_field &#x3D; table2.common_field; 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用内连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+----+----------+--------+---------------------+ 左连接左链接返回左表中的所有记录，即是右表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在右表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自右表的字段都为 NULL。 这就意味着，左连接会返回左表中的所有记录，加上右表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：左连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1LEFT JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用左连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 123456789101112+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL || 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL |+----+----------+--------+---------------------+ 左连接右链接返回左表中的所有记录，即是左表中没有任何满足匹配条件的记录。这意味着，如果 ON 子句在左表中匹配到了 0 条记录，该连接仍然会返回至少一条记录，不过返回的记录中所有来自左表的字段都为 NULL。 这就意味着，右连接会返回右表中的所有记录，加上左表中匹配到的记录，或者是 NULL （如果连接谓词无法匹配到任何记录的话）。 语法：右连接的基本语法如下所示： 1234SELECT table1.column1, table2.column2...FROM table1RIGHT JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在，让我们用右连接将这两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678+------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+------+----------+--------+---------------------+| 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+------+----------+--------+---------------------+ 全连接全连接将左连接和右连接的结果组合在一起。 语法：全连接的基本语法如下所受： 1234SELECT table1.column1, table2.column2...FROM table1FULL JOIN table2ON table1.common_field &#x3D; table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例：考虑如下两个表格，（a）CUSTOMERS 表： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY |+----+----------+-----+-----------+----------+| 1 | Ramesh | 32 | Ahmedabad | 2000.00 || 2 | Khilan | 25 | Delhi | 1500.00 || 3 | kaushik | 23 | Kota | 2000.00 || 4 | Chaitali | 25 | Mumbai | 6500.00 || 5 | Hardik | 27 | Bhopal | 8500.00 || 6 | Komal | 22 | MP | 4500.00 || 7 | Muffy | 24 | Indore | 10000.00 |+----+----------+-----+-----------+----------+ （b）ORDERS 表： 12345678+-----+---------------------+-------------+--------+| OID | DATE | ID | AMOUNT |+-----+---------------------+-------------+--------+| 102 | 2009-10-08 00:00:00 | 3 | 3000 || 100 | 2009-10-08 00:00:00 | 3 | 1500 || 101 | 2009-11-20 00:00:00 | 2 | 1560 || 103 | 2008-05-20 00:00:00 | 4 | 2060 |+-----+---------------------+-------------+--------+ 现在让我们用全连接将两个表连接在一起： 1234SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS FULL JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： 12345678910111213141516+------+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+------+----------+--------+---------------------+| 1 | Ramesh | NULL | NULL || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | NULL | NULL || 6 | Komal | NULL | NULL || 7 | Muffy | NULL | NULL || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 |+------+----------+--------+---------------------+ 如果你所用的数据库不支持全连接，比如 MySQL，那么你可以使用 UNION ALL子句来将左连接和右连接结果组合在一起： 123456789SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_IDUNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID &#x3D; ORDERS.CUSTOMER_ID 笛卡尔连接（交叉连接）笛卡尔连接或者交叉连接返回两个或者更多的连接表中记录的笛卡尔乘积。也就是说，它相当于连接谓词总是为真或者缺少连接谓词的内连接。 语法：笛卡尔连接或者说交叉连接的基本语法如下所示： 12SELECT table1.column1, table2.column2...FROM table1, table2 [, table3 ] 示例：123456789101112131415161718192021222324考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+（b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我用内连接将这两个表连接在一起： 12SQL&gt; SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS, ORDERS; 上述语句将会产生如下结果： 1234567891011121314151617181920212223242526272829303132+----+----------+--------+---------------------+| ID | NAME | AMOUNT | DATE |+----+----------+--------+---------------------+| 1 | Ramesh | 3000 | 2009-10-08 00:00:00 || 1 | Ramesh | 1500 | 2009-10-08 00:00:00 || 1 | Ramesh | 1560 | 2009-11-20 00:00:00 || 1 | Ramesh | 2060 | 2008-05-20 00:00:00 || 2 | Khilan | 3000 | 2009-10-08 00:00:00 || 2 | Khilan | 1500 | 2009-10-08 00:00:00 || 2 | Khilan | 1560 | 2009-11-20 00:00:00 || 2 | Khilan | 2060 | 2008-05-20 00:00:00 || 3 | kaushik | 3000 | 2009-10-08 00:00:00 || 3 | kaushik | 1500 | 2009-10-08 00:00:00 || 3 | kaushik | 1560 | 2009-11-20 00:00:00 || 3 | kaushik | 2060 | 2008-05-20 00:00:00 || 4 | Chaitali | 3000 | 2009-10-08 00:00:00 || 4 | Chaitali | 1500 | 2009-10-08 00:00:00 || 4 | Chaitali | 1560 | 2009-11-20 00:00:00 || 4 | Chaitali | 2060 | 2008-05-20 00:00:00 || 5 | Hardik | 3000 | 2009-10-08 00:00:00 || 5 | Hardik | 1500 | 2009-10-08 00:00:00 || 5 | Hardik | 1560 | 2009-11-20 00:00:00 || 5 | Hardik | 2060 | 2008-05-20 00:00:00 || 6 | Komal | 3000 | 2009-10-08 00:00:00 || 6 | Komal | 1500 | 2009-10-08 00:00:00 || 6 | Komal | 1560 | 2009-11-20 00:00:00 || 6 | Komal | 2060 | 2008-05-20 00:00:00 || 7 | Muffy | 3000 | 2009-10-08 00:00:00 || 7 | Muffy | 1500 | 2009-10-08 00:00:00 || 7 | Muffy | 1560 | 2009-11-20 00:00:00 || 7 | Muffy | 2060 | 2008-05-20 00:00:00 |+----+----------+--------+---------------------+","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"数据库基础知识","slug":"数据库基础知识","date":"2020-10-15T09:09:00.000Z","updated":"2020-10-15T09:09:30.000Z","comments":true,"path":"数据库基础知识.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html","excerpt":"什么是关系型数据库管理系统？RDBMS 是关系型数据库管理系统（Relational DataBase Management System)的缩写，它是 SQL 以及所有现代数据库系统，例如 MS SQL Server、IBM DB2、Oracle、MySQL 和 MS Access等的基础。 关系型数据库管理系统（RDBMS）是一种基于 E.F. 科德提出的关系模型的数据库管理系统。","text":"什么是关系型数据库管理系统？RDBMS 是关系型数据库管理系统（Relational DataBase Management System)的缩写，它是 SQL 以及所有现代数据库系统，例如 MS SQL Server、IBM DB2、Oracle、MySQL 和 MS Access等的基础。 关系型数据库管理系统（RDBMS）是一种基于 E.F. 科德提出的关系模型的数据库管理系统。 什么是表？RDBMS 中的数据存储在被称作表的数据库对象中。表是相互关联的数据记录的集合，由一系列的行和列组成。 谨记，表是关系型数据库中最常见也是最简单的数据存储形式。下面是一个客户信息表的例子： 1234567891011+----+----------+-----+-----------+----------+| ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ 什么是字段？每张表都能够划分成更小的实体——字段。例如，上面的客户信息表中有 ID、NAME、AGE、ADDRESS 和 SALARY 五个字段。 一个字段限定了数据表中的列，被用来维护表中所有记录的特定信息。 什么是记录或者数据行？记录或者说数据行是存在于数据表中的独立条目。例如，上面的客户信息表中有 7 条记录。下面是客户信息表中的一条记录： 123+----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | +----+----------+-----+-----------+----------+ 记录就是表中水平排列的数据构成的实体。 什么是列？列是表中竖直排列的实体，它包含了表中与某一特定字段相关的所有信息。 例如，上面的客户信息表中有字段为 ADDRESS 的列，存储了客户的地址，其内容如下所示： 1234567891011+-----------+ | ADDRESS | +-----------+ | Ahmedabad | | Delhi | | Kota | | Mumbai | | Bhopal | | MP | | Indore | +----+------+ 什么是 NULL 值？NULL 值是表中以空白形式出现的值，表示该记录在此字段处没有设值。 一定要明白 NULL 值同 0 值或者包含空格的字段是不同的。值为 NULL 的字段是在记录创建的时候就被留空的字段。 SQL 约束约束是表中的数据列必须遵守的规则，用于限制表中数据的类型。约束保证了数据库中数据的精确性和可靠性。 约束可以限制列或者表。列级的约束只限制单一的列，而表级的约束作用于整个表。 以下是 SQL 中常见的约束： NOT NULL 约束：保证列中数据不能有 NULL 值 DEFAULT 约束：提供该列数据未指定时所采用的默认值 UNIQUE 约束：保证列中的所有数据各不相同 主键：唯一标识数据表中的行/记录 外键：唯一标识其他表中的一条行/记录 CHECK 约束：此约束保证列中的所有值满足某一条件 索引：用于在数据库中快速创建或检索数据 NOT NULL 约束默认情况下，数据表中的字段接受 NULL 值。如果你不想让某个字段接受 NULL 值，那么请为该字段定义此约束，以指明该字段不接受 NULL 值。 NULL 并不是指没有数据，而是指该字段数据未知。 示例：例如，下述 SQL 语句创建了一个新的数据表 CUSTOMERS，并添加了五个字段，其中三个字段——ID、NAME 和 AGE——被指定为 NOT NULL： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 对于 Oracle 和 MySQL 来说，如果 CUSTOMERS 表已经存在，此时再要给 SALARY 字段添加 NOT NULL 约束的话，SQL 语句应当如下： 12ALTER TABLE CUSTOMERS MODIFY SALARY DECIMAL (18, 2) NOT NULL; DEFAULT 约束DEFAULT 约束在 INSERT INTO 语句没有提供的情况下，为指定字段设置默认值。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并添加了五个字段。这里，SALARY 字段的默认值为 5000。因此，如果 INSERT INTO 没有为该字段提供值的话，该字段就为默认值 5000。 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2) DEFAULT 5000.00, PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，此时再要给 SALARY 字段添加 DEFAULT 约束的话，你需要类似下面的语句： 12ALTER TABLE CUSTOMERS MODIFY SALARY DECIMAL (18, 2) DEFAULT 5000.00; 删除 DEFAULT 约束：要删除 DEFAULT 约束的话，请使用下面的 SQL 语句： 12ALTER TABLE CUSTOMERS ALTER COLUMN SALARY DROP DEFAULT; UNIQUE 约束UNIQUE 约束使得某一字段对任意两条记录来说都不能相同。例如，在 CUSTOMERS 表中，你或许想让任何人的年龄（age）都不相同。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并添加了五个字段，其中 AGE 字段被设为 UNIQUE，于是任意两条记录的 AGE 都不同： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL UNIQUE, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，再要为 AGE 字段添加 UNIQUE 约束的话，你需要像下面这样写 SQL 语句： 12ALTER TABLE CUSTOMERS MODIFY AGE INT NOT NULL UNIQUE; 还可以使用如下所示的语法，该语法还支持对作用于多个字段的约束进行命名： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT myUniqueConstraint UNIQUE(AGE, SALARY); 删除 UNIQUE 约束要删除 UNIQUE 约束的话，请使用如下 SQL 语句： 12ALTER TABLE CUSTOMERS DROP CONSTRAINT myUniqueConstraint; 如果你在使用 MySQL，那么下面的语法也是可行的： 12ALTER TABLE CUSTOMERS DROP INDEX myUniqueConstraint; 主键主键是数据表中唯一确定一条记录的字段。主键必须包含唯一值，并且不能为 NULL。 每张数据表只能有一个主键，不过一个主键可以包含一个或者多个字段。如果主键由多个字段组合而成，这些字段就被称作组合键。 如果一个字段被定义为了某表的主键，则任意两条记录在该字段处不能相同。 注意：在创建数据表的时候，需要用到这些概念。 创建主键：如下是将 ID 定义为 CUSTOMERS 表主键的语法： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在了，再要将 ID 定义为主键的话，请使用下面的语句： 1ALTER TABLE CUSTOMER ADD PRIMARY KEY (ID); 注意：如果你要使用 ALTER TABLE 语句来添加主键，那么主键所在的列必须已经被声明为 NOT NULL 了。 要用多个字段来定义主键的话，请使用如下 SQL 语法： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID, NAME)); 如果 CUSTOMERS 表已经存在，此时再要将 ID 和 NAMES 字段定义为主键的话，请使用如下 SQL 语法： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT PK_CUSTID PRIMARY KEY (ID, NAME); 删除主键你可以将主键约束从数据表中删除，语法如下： 1ALTER TABLE CUSTOMERS DROP PRIMARY KEY ; 外键外键用于将两个数据表连接在一起，有时候也被称作“参照键”。 外键为单一字段或者多个字段的组合，并与另外一个数据表的主键相匹配。 两个表之间的关系是：一个表的主键与另一个表的外键相匹配。 示例：考虑如下两个表的结构： CUSTOMERS 表： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); ORDERS 表： 1234567CREATE TABLE ORDERS ( ID INT NOT NULL, DATE DATETIME, CUSTOMER_ID INT references CUSTOMERS(ID), AMOUNT double, PRIMARY KEY (ID)); 如果 ORDERS 表已经存在，并且没有设置外键，那么可以使用下面的语法来修改数据表以指定外键。 12ALTER TABLE ORDERS ADD FOREIGN KEY (Customer_ID) REFERENCES CUSTOMERS (ID); 删除外键约束：要删除外键约束的话，语法如下所示： 12ALTER TABLE ORDERS DROP FOREIGN KEY; CHECK 约束CHECK 约束使用某一条件来对记录中的值进行检查。如果条件最终为假（false），即约束条件不能得到满足，则该记录不能写入数据表中。 示例：例如，下述 SQL 语句创建了一个名为 CUSTOMERS 的新表，并为其添加了五个字段。在此，我们为 AGE 字段设置了 CHECK 约束，以拒绝任何年龄低于 18 的顾客： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL CHECK (AGE &gt;&#x3D; 18), ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 如果 CUSTOMERS 表已经存在，再要为 AGE 字段设置 CHECK 约束的话，就需要像下面这样写 SQL 语句： 12ALTER TABLE CUSTOMERS MODIFY AGE INT NOT NULL CHECK (AGE &gt;&#x3D; 18 ); 或者也可以使用下面的语法，该语法还支持对作用于多个字段的约束命名： 12ALTER TABLE CUSTOMERS ADD CONSTRAINT myCheckConstraint CHECK(AGE &gt;&#x3D; 18); 删除 CHECK 约束：要删除 CHECK 约束的话，请使用下面的 SQL 语句，不过该语句在 MySQL 中不起作用： 12ALTER TABLE CUSTOMERS DROP CONSTRAINT myCheckConstraint; 索引索引用于在数据库中快速地创建和检索数据。索引可以由表中的一个或者多个字段创建。创建索引时，每一行都会获得一个 ROWID（在数据进行排序之前）。 合理运用索引可以提高大型数据库的性能。但是，创建索引之前还是要三思而后行。为哪些字段创建索引，则取决于 SQL 查询最常用到到哪些字段。 示例：例如，下面的 SQL 语句创建了一个名为 CUSTOMERS 的新表，并为其添加了五个字段： 12345678CREATE TABLE CUSTOMERS( ID INT NOT NULL, NAME VARCHAR (20) NOT NULL, AGE INT NOT NULL, ADDRESS CHAR (25) , SALARY DECIMAL (18, 2), PRIMARY KEY (ID)); 现在，你就可以使用下面的语法来为一个或者多个字段创建索引了： 12CREATE INDEX index_name ON table_name ( column1, column2.....); 例如，可以在 AGE 字段上创建索引，以优化对特定年龄的顾客的查询，其语法如下所示： 12CREATE INDEX idx_age ON CUSTOMERS ( AGE ); 删除索引约束：要删除索引约束的话，可以使用下面的 SQL 语句： 12ALTER TABLE CUSTOMERS DROP INDEX idx_age; 数据完整性下面几类数据完整性存在于各个 RDBMS 中： 实体完整性：表中没有重复的行 域完整性：通过限制数据类型、格式或者范围来保证给定列的数据有效性 参照完整性：不能删除被其他记录引用的行 用户定义完整性：施加某些不属于上述三种完整性的业务规则","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"Centos安装Mysql","slug":"centos安装MySQL","date":"2020-10-15T07:57:00.000Z","updated":"2020-10-15T07:57:00.000Z","comments":true,"path":"centos安装MySQL.html","link":"","permalink":"https://www.lauyongyi.cn/centos%E5%AE%89%E8%A3%85MySQL.html","excerpt":"记录Centos安装MySQL的全程过程","text":"记录Centos安装MySQL的全程过程 安装MySQL安装前的准备工作：检测系统是否自带安装 MySQL 1rpm -qa | grep mysql 如果系统有安装，那可以选择进行卸载： 12rpm -e mysql // 普通删除模式rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 安装 MySQL：需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ 1234wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum updateyum install mysql-server 权限设置：1chown mysql:mysql -R &#x2F;var&#x2F;lib&#x2F;mysql 初始化 MySQL：1mysqld --initialize 启动 MySQL：1systemctl start mysqld 查看 MySQL 运行状态：1systemctl status mysqld 验证 MySQL 安装1mysqladmin --version Mysql安装后需要做的Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： 1[root@host]# mysqladmin -u root password &quot;new_password&quot;; 使用Navicat链接MySQL刚安装完成时，使用Navicat链接MySQL，有可能会出现1130 - Host XXX is not allowed to connect to this MySQL server。错误提示 原因是：在MySQL的host配置里，没有你机器的IP地址（没有授权外网访问），所以无法访问 解决方法1（改表法）：在安装Mysql数据库的主机上登录root用户： mysql -u root -p 输入密码后访问，执行 12use mysql;select host from user where user&#x3D;&#39;root&#39;; 会出现类似的结果： 12345678+----------------+| host |+----------------+| localhost || 127.0.0.1 || ::1 || vm-0-12-centos |+----------------+ 将Host设置为通配符**%** update user set host = &#39;%&#39; where user =&#39;root&#39;; Host修改完成后记得执行flush privileges使配置立即生效 1flush privileges; 再次链接就可以成功了。 此方法会引发的问题：一但把localhost改为通配符**%**，服务端将无法直接使用mysql -uroot -p进行数据库登录 解决方法2（授权法）： 例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO &#39;myuser&#39;@&#39;%&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.3&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION; 最后一定要执行 flush privileges;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.lauyongyi.cn/tags/MySQL/"}]},{"title":"SQL概览","slug":"SQL是什么","date":"2020-10-15T03:47:00.000Z","updated":"2020-10-15T04:11:00.000Z","comments":true,"path":"SQL是什么.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E6%98%AF%E4%BB%80%E4%B9%88.html","excerpt":"SQL 是用于访问和处理数据库的标准的计算机语言。","text":"SQL 是用于访问和处理数据库的标准的计算机语言。 SQL简介：SQL是结构化查询语言（Structured Query Language），一种用于存储、操作或者检索存储在关系型数据库中数据的计算机语言。 SQL是关系型数据库系统（Relation Database System）的标准语言。所有关系性数据库系统，例如MySQL、MSAccess、Oracle、Sybase、Informix、Postgres SQL和SQL Server，都是用SQL作为其标准数据库语言。 SQL 是一个 ANSI（American National Standard Institute，美国国家标准协会）标准。不过，SQL 语言有很多不同的版本存在。 SQL的用途： 允许用户访问关系型数据库中的数据 SQL 面向数据库执行查询 SQL 可从数据库取回数据 允许用户对数据做出描述 允许用于定义数据库中的数据，并对其进行操作 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 允许通过 SQL 模块、库或者预编译器的等方式，嵌入到其他语言中 允许用户创建或删除数据库和表 SQL 可创建新数据库 SQL 可在数据库中创建新表 允许用户在数据库中创建视图、存储过程和函数 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 允许用户对表、过程和视图设进行权限设置 SQL的流程：在任何一种 RDBMS 上执行 SQL 命令，数据库管理系统都会判断出执行请求的最佳方式，并由 SQL 引擎推算出具体如何完成任务。 这一流程涉及到了各种各样的组件，包括查询调度器（Query Dispatcher）、优化引擎（Optimization Engines）、经典查询引擎（Classic Query Engine）和 SQL 查询引擎（SQL Query Engine）等等。经典查询引擎用于处理所有的非 SQL 查询，而 SQL 查询引擎则不处理逻辑文件。 SQL 命令用于与关系型数据库交互的标准 SQL 命令有 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP，这些命令按用途分成如下几组： 数据定义语言 命令 描述 CREATE 创建新的表、视图或者其他数据库中的对象 ALTER 修改现存数据库对象，比如一张表 DROP 删除表、视图或者数据库中的其他对象 数据操纵语言 命令 描述 SELECT 从一张或者多张表中检索特定的数据 INSERT 创建一条新记录 UPDATE 修改记录 DELETE 删除记录 数据控制语言 命令 描述 GRANT 赋予用户特权 REVOKE 收回赋予用户的特权","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"SQL语事务","slug":"SQL事务","date":"2020-10-15T02:47:00.000Z","updated":"2020-10-15T03:11:00.000Z","comments":true,"path":"SQL事务.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E4%BA%8B%E5%8A%A1.html","excerpt":"事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。","text":"事务是在数据库上按照一定的逻辑顺序执行的任务序列，既可以由用户手动执行，也可以由某种数据库程序自动执行。 事务实际上就是对数据库的一个或者多个更改。当你在某张表上创建更新或者删除记录的时，你就已经在使用事务了。控制事务以保证数据完整性，并对数据库错误做出处理，对数据库来说非常重要。实践中，通常会将很多 SQL 查询组合在一起，并将其作为某个事务一部分来执行。 事务的属性/条件：一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制：有四个命令用于控制事务： COMMIT：提交更改； ROLLBACK：回滚更改； SAVEPOINT：在事务内部创建一系列可以 ROLLBACK 的还原点； SET TRANSACTION：命名事务； COMMIT 命令：COMMIT 命令用于保存事务对数据库所做的更改。 COMMIT 命令会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。 ROLLBACK 命令：ROLLBACK 命令用于撤销尚未保存到数据库中的事务。 ROLLBACK 命令只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。 SAVEPOINT 命令：SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。 RELEASE SAVEPOINT 命令：RELEASE SAVEPOINT 命令用于删除先前创建的保存点。 保存点一旦被释放，你就不能够再用 ROLLBACK 命令来撤销该保存点之后的事务了。 SET TRANSACTION 命令：SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"SQL语句进阶","slug":"SQL进阶","date":"2020-10-13T02:47:00.000Z","updated":"2020-10-13T10:11:00.000Z","comments":true,"path":"SQL进阶.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E8%BF%9B%E9%98%B6.html","excerpt":"记录一些在sqlzoo.net 遇到的不太理解的SQL语句知识","text":"记录一些在sqlzoo.net 遇到的不太理解的SQL语句知识 concat函數函數concat 可以用來合拼兩個或以上的字串。 例子： “Mexico 墨西哥”的首都是”Mexico City”。顯示所有國家名字,其首都是國家名字加上”City”。 SELECT name FROM world WHERE capital = concat(name, &#39;City&#39;) 找出所有首都和其國家名字,而首都要有國家名字中出現。 SELECT capital, name FROM world WHERE capital LIKE concat(&#39;%&#39;,name,&#39;%&#39;) 找出所有首都和其國家名字,而首都是國家名字的延伸。你應顯示 Mexico City,因它比其國家名字 Mexico 長。你不應顯示 Luxembourg,因它的首都和國家名相是相同的。 select name,capital from world where capital Like concat(&#39;%&#39;,name,&#39;%&#39;) and capital != name REPLACE()字符串替换函数replace函数定义replace(original-string，search-string，replace-string) 参数original-string： 被搜索的字符串。可为任意长度。search-string： 要搜索并被 replace-string 替换的字符串。该字符串的长度不应超过 255 个字节。如果 search-string 是空字符串，则按原样返回原始字符串。replace-string： 该字符串用于替换 search-string。可为任意长度。如果 replacement-string 是空字符串，则删除出现的所有 search-string。 说明 用字符串表达式3替换字符串表达式1中出现的所有字符串表达式2的匹配项。返回新的字符串。 如果有某个参数为 NULL，此函数返回 NULL。 例子： “Monaco-Ville”是合併國家名字 “Monaco” 和延伸詞”-Ville”.顯示國家名字，及其延伸詞，如首都是國家名字的延伸。 SELECT name,replace(capital, name, &#39;&#39;) FROM world WHERE capital LIKE concat(name,&#39;%_&#39;) ROUND() 函数​ ROUND() 函数用于把数值字段舍入为指定的小数位数。 SQL ROUND() 语法​ SELECT ROUND(column_name,decimals) FROM table_name; 参数 描述 column_name 必需。要舍入的字段。 decimals 必需。规定要返回的小数位数。 例子： ​ Germany德國（人口8000萬），在Europe歐洲國家的人口最多。Austria奧地利（人口850萬）擁有德國總人口的11％。 顯示歐洲的國家名稱name和每個國家的人口population。以德國的人口的百分比作人口顯示。 SELECT name, CONCAT(round(population/(SELECT population FROM world WHERE name =&#39;Germany&#39;)*100, 0), &#39;%&#39;) FROM world WHERE continent =&#39;Europe&#39;;。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"Jenkins自动打包","slug":"Jenkins编译安卓包","date":"2020-09-23T06:24:00.000Z","updated":"2020-09-23T06:30:00.000Z","comments":true,"path":"Jenkins编译安卓包.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%93%E5%8C%85.html","excerpt":"记录一下，使用Jenkins进行安卓自动打包的操作过程。","text":"记录一下，使用Jenkins进行安卓自动打包的操作过程。 环境变量配置​ 首先，一定要先进行环境变量的配置，这里已经提前配置好了 JAVA_HOME 1、系统配置​ 路径：系统管理 – 系统配置 ​ 在全局属性添加ANDROID_HOME ​ 2、全局配置​ 路径：系统管理 – 全局工具配置 ​ 在 Gradle 添加 Gradle_HOME ​ 关于上面两个环境的安装，可以参考之前一篇笔记Centos配置SDK,gradle 项目配置​ 项目使用git进行源码管理，在源码管理选项里选择git，填写上对应的仓库地址。 ​ 可选项：构建触发器，可以根据项目需求，选择触发方式，由于这里时练手的个人项目，所以采用的是 轮询机制 ​ 项目的构建选择 ：Invoke Gradle script Gradle Version 选择手动配置的 Gradle_HOME Tasks 填写 clean assembleRelease #清除和构建（应该是清除之前的构建残余再重新构建的意思） 如果 clean assembleRelease 报错，可以先用 build 进行测试打包","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"jmeter参数化","slug":"jmeter参数化","date":"2020-09-18T09:24:00.000Z","updated":"2020-09-23T06:00:00.000Z","comments":true,"path":"jmeter参数化.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E5%8F%82%E6%95%B0%E5%8C%96.html","excerpt":"记录在使用jmeter进行测试时，常用的几种参数化方法","text":"记录在使用jmeter进行测试时，常用的几种参数化方法 用户参数​ 右键快捷菜单中：添加 – 前置处理器 – 用户参数。 用户参数可以设置多个值，以v2ex]的这个搜索链接为例https://www.v2ex.com/api/nodes/show.json?name=python 。 可以设置成以下参数 然后在HTTP请求，参数那里进行引用 然后将线程数设置为：3，运行，再查看结果树可以看到，请求了三次，每次请求都不同。 函数助手1、函数助手路径：点击菜单栏“选项”—-&gt;函数助手对话框，看下图 2、下面介绍一下常用系统函数： ​ time获取当前时间第一个参数为时间格式，第二个参数为存放获得当前时间值的参数名称，例在第一个参数输入yyyy-MM-dd HH:mm:ss，单击生成即可得到正确的函数表达式。 ​ Random随机数 ​ __StringFromFile从本地csv文件中读取记录存入参数与CSV Data Set Config相比，该函数的强大之处是它可以支持从多个文件中读取数据。第一个参数是文件名（使用绝对路径），第二个参数是存放取得数据的参数列表，第三个和第四个参数分别为数据文件的起始和终止顺序号。 3、举例 ​ 以https://api.apiopen.top/getJoke?count=20&amp;page=15&amp;type=all 为例。其中，count、page、type都可以参数化 ​ 1、Random随机数 ​ 如下图所示，将count，paga使用随机数作为参数 ​ 然后可以用用户参数的形式，将type进行参数化，配置好之后，如下图 将线程数设置成：10或以上，运行。从查看结果树可以看出，请求都是成功的，且请求链接都不相同。 ​ 2、CSVRead ​ 可以读取CSV文件里设置好的值，这里创建了一个名为：duanzi.csv的文件，用来存放参数值，具体参数值见下图： 打开函数助手CSV窗口，选择CSVRead，然后填写文件路径，以及取值的列（注：.csv文件第一列从0开始取），如下图所示 然后填写到测试链接里，线程数设置为：10，得到的结果都是正常运行，且链接里包含的参数值与csv里填写的值一样。 用户自定义变量右键快捷菜单中选择 添加-配置元件-用户自定义变量。 ​ 用户自定义变量中的定义的所有参数的值在测试计划的执行过程中不能发生取值的改变，因此一般仅将测试计划中不需要随迭代发生改变的参数（只取一次值的参数）设置在此处。以https://api.uomg.com/api/rand.music?sort=热歌榜&amp;format=json为例子。参数：sort、format 取样器中的sort和format用${sort}和${forma}代替，即使被测应用的部署服务器发生了变化，只需要简单地修改sort和format参数的取值即可。 正则表达式提取器右键快捷菜单中选择 添加-后置处理器-正则表达式提取器。 说明： ​ 引用名称：即变量名，后续请求中可以通过 ${引用名称} 来调用 ​ 正则表达式：按实际情况填写 ​ 模板：$$表示需要哪个正则表达式获取的值，1代表第一个，-1代表全部，0代表随机 ​ 匹配数字：1代表第一个，-1代表全部，0代表随机 ​ 缺省值：如果正则未匹配到，就会使用缺省值 正则说明： ​ . 表示除“\\r\\n”之外的任意字符 ​ ***** 表示匹配前面的子表达式任意次 ​ + 表示匹配前面的子表达式1次或多次 ​ ？ 表示匹配前面的子表达式0次或1次 ​ .*：贪婪匹配原则，即匹配到不能匹配为止 ​ .*?：非贪婪匹配，即在匹配成功的情况下尽可能少的匹配","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"jmeter-json断言","slug":"jmeter断言","date":"2020-09-18T09:04:00.000Z","updated":"2020-09-18T09:04:00.000Z","comments":true,"path":"jmeter断言.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E6%96%AD%E8%A8%80.html","excerpt":"记录jmeter使用过程中的断言使用情况","text":"记录jmeter使用过程中的断言使用情况 Json断言当相应结果为Json时，使用Json断言，会更加方便和快捷。 添加方式，右键快捷菜单 – 断言 –Json断言。界面如下： Assert JSON Path exists: #元素匹配 Additionally assert value # 等于特定值 Match as regular expression # 符合正则表达式 Expected Value： # 特定值 Expect null #预期空值 Invert assertion(will fail if abovew conditions met) #满足上面的条件则fail 判断方式： ​ 如果响应结果不是json格式的，fail ​ 如果json path找不到元素，fail ​ 如果json path找到元素，没有设置条件，pass ​ 如果json path找到元素了，不符合条件，fail ​ 如果json path找到元素，且符合条件，pass ​ 如果json path返回的是一个数组，迭代判断是否有元素符合条件，有则pass，无则fail 例子：使用随机的音乐推荐链接来进行验证：https://api.uomg.com/api/rand.music?sort=热歌榜&amp;format=json 响应结果如下： 123456789&#123; &quot;code&quot;: 1, &quot;data&quot;: &#123; &quot;name&quot;: &quot;你就不要想起我&quot;, &quot;url&quot;: &quot;http://music.163.com/song/media/outer/url?id=28018075&quot;, &quot;picurl&quot;: &quot;http://p3.music.126.net/aPnwHIJECLpQCoSV-qm_qA==/109951163571315498.jpg&quot;, &quot;artistsname&quot;: &quot;田馥甄&quot; &#125;&#125; json断言： 运行上面的断言，结果是成功的。 当去掉 Match as regular expression 断言是失败的 当加上了Invert assertion(will fail if abovew conditions met) 用例就会失败","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"jmeter相应编码转换","slug":"jmeter编码","date":"2020-09-18T03:24:00.000Z","updated":"2020-09-18T03:34:00.000Z","comments":true,"path":"jmeter编码.html","link":"","permalink":"https://www.lauyongyi.cn/jmeter%E7%BC%96%E7%A0%81.html","excerpt":"使用jmeter进行测试的时候，有些情况下会出现相应内容乱码的情况。","text":"使用jmeter进行测试的时候，有些情况下会出现相应内容乱码的情况。 以v2ex为例响应结果有Unicode编码 需要添加后置处理器，编写脚本进行转码 添加下列代码即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556String s=new String(prev.getResponseData(),&quot;UTF-8&quot;);char aChar;int len= s.length();StringBuffer outBuffer=new StringBuffer(len);for(int x =0; x &lt;len;)&#123;aChar= s.charAt(x++);if(aChar==&#x27;\\\\&#x27;)&#123;aChar= s.charAt(x++);if(aChar==&#x27;u&#x27;)&#123;int value =0;for(int i=0;i&lt;4;i++)&#123;aChar= s.charAt(x++);switch(aChar)&#123;case&#x27;0&#x27;:case&#x27;1&#x27;:case&#x27;2&#x27;:case&#x27;3&#x27;:case&#x27;4&#x27;:case&#x27;5&#x27;:case&#x27;6&#x27;:case&#x27;7&#x27;:case&#x27;8&#x27;:case&#x27;9&#x27;:value=(value &lt;&lt;4)+aChar-&#x27;0&#x27;;break;case&#x27;a&#x27;:case&#x27;b&#x27;:case&#x27;c&#x27;:case&#x27;d&#x27;:case&#x27;e&#x27;:case&#x27;f&#x27;:value=(value &lt;&lt;4)+10+aChar-&#x27;a&#x27;;break;case&#x27;A&#x27;:case&#x27;B&#x27;:case&#x27;C&#x27;:case&#x27;D&#x27;:case&#x27;E&#x27;:case&#x27;F&#x27;:value=(value &lt;&lt;4)+10+aChar-&#x27;A&#x27;;break;default:throw new IllegalArgumentException(&quot;Malformed \\\\uxxxx encoding.&quot;);&#125;&#125;outBuffer.append((char) value);&#125;else&#123;if(aChar==&#x27;t&#x27;)aChar=&#x27;\\t&#x27;;else if(aChar==&#x27;r&#x27;)aChar=&#x27;\\r&#x27;;else if(aChar==&#x27;n&#x27;)aChar=&#x27;\\n&#x27;;else if(aChar==&#x27;f&#x27;)aChar=&#x27;\\f&#x27;;outBuffer.append(aChar);&#125;&#125;elseoutBuffer.append(aChar);&#125;prev.setResponseData(outBuffer.toString());","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"Centos配置ant","slug":"Centos配置ant","date":"2020-09-17T03:24:00.000Z","updated":"2020-09-17T09:54:00.000Z","comments":true,"path":"Centos配置ant.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E9%85%8D%E7%BD%AEant.html","excerpt":"Jenkins需要用到Ant，这里记录一下Ant配置的步骤","text":"Jenkins需要用到Ant，这里记录一下Ant配置的步骤 一、到官网下载Ant​ 方法1：找到下图所示的位置，选择.tar.gz 结尾的包，点击下载，然后通过xftp上传到服务器 ​ 方法2：通过wget命令下载：wget http://mirror.netinch.com/pub/apache//ant/binaries/apache-ant-1.9.15-bin.tar.gz 配置Ant执行tar -zxvf apache-ant-1.9.15-bin.tar.gz #解压命令 再执行 mv apache-ant-1.9.15 /usr/local/ant #重名了，并移动到指定位置 vim /etc/profile #编辑环境变量 输入一下内容 12export ANT_HOME=/usr/local/antexport PATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH source /etc/profile #更新配置文件 检查 ant -version #ant版本检查 出现以下文字，说明环境变量配置ok Apache Ant(TM) version 1.9.15 compiled on May 10 2020","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Jenkins+ant+jmeter","slug":"Jmeter+jenkins","date":"2020-09-17T03:24:00.000Z","updated":"2020-09-24T06:43:00.000Z","comments":true,"path":"Jmeter+jenkins.html","link":"","permalink":"https://www.lauyongyi.cn/Jmeter+jenkins.html","excerpt":"记录一下使用Jenkins+ant+jmeter的接口测试过程","text":"记录一下使用Jenkins+ant+jmeter的接口测试过程 创建文件目录这里可以使用Git进行管理，方便后续的持续更新，我的demo仓库 –主目录 ​ –result ​ –html（用来存放测试报告） ​ –jtl （存放jtl文件） ​ –script （存放脚本） ​ –build.xml （核心配置文件） 使用Jmeter编写脚本​ 先使用Jmeter编写脚本，然后保存到 script中 编写build.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;project name=&quot;jmeter_test&quot; default=&quot;all&quot; basedir=&quot;.&quot;&gt; &lt;tstamp&gt; &lt;format property=&quot;time&quot; pattern=&quot;MM-dd-hh-mm&quot; /&gt; &lt;/tstamp&gt; &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt; &lt;property name=&quot;jmeter.home&quot; value=&quot;/usr/local/jmeter/apache-jmeter-5.3/&quot; /&gt; &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; &lt;property name=&quot;jmeter.result.jtl.dir&quot; value=&quot;./result/jtl&quot; /&gt; &lt;!-- jmeter生成html格式的结果报告的路径--&gt; &lt;property name=&quot;jmeter.result.html.dir&quot; value=&quot;./result/html&quot; /&gt; &lt;!-- 生成的报告的前缀 --&gt; &lt;property name=&quot;ReportName&quot; value=&quot;TestReport&quot; /&gt; &lt;property name=&quot;jmeter.result.jtlName&quot; value=&quot;$&#123;jmeter.result.jtl.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.jtl&quot; /&gt; &lt;property name=&quot;jmeter.result.htmlName&quot; value=&quot;$&#123;jmeter.result.html.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.html&quot; /&gt; &lt;target name=&quot;all&quot;&gt; &lt;antcall target=&quot;test&quot; /&gt; &lt;antcall target=&quot;report&quot; /&gt; &lt;/target&gt; &lt;target name=&quot;test&quot;&gt; &lt;taskdef name=&quot;jmeter&quot; classname=&quot;org.programmerplanet.ant.taskdefs.jmeter.JMeterTask&quot; /&gt; &lt;jmeter jmeterhome=&quot;$&#123;jmeter.home&#125;&quot; resultlog=&quot;$&#123;jmeter.result.jtlName&#125;&quot;&gt; &lt;!-- 声明要运行的脚本。&quot;*.jmx&quot;指包含此目录下的所有jmeter脚本 --&gt; &lt;testplans dir=&quot;./script/&quot; includes=&quot;*.jmx&quot; /&gt; &lt;property name=&quot;jmeter.save.saveservice.output_format&quot; value=&quot;xml&quot;/&gt; &lt;/jmeter&gt; &lt;/target&gt; &lt;path id=&quot;xslt.classpath&quot;&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/lib&quot; includes=&quot;xalan*.jar&quot;/&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/lib&quot; includes=&quot;serializer*.jar&quot;/&gt; &lt;/path&gt; &lt;target name=&quot;report&quot;&gt; &lt;tstamp&gt;&lt;format property=&quot;report.datestamp&quot; pattern=&quot;yyyy/MM/dd HH:mm&quot;/&gt;&lt;/tstamp&gt; &lt;xslt classpathref=&quot;xslt.classpath&quot; force=&quot;true&quot; in=&quot;$&#123;jmeter.result.jtlName&#125;&quot; out=&quot;$&#123;jmeter.result.htmlName&#125;&quot; style=&quot;$&#123;jmeter.home&#125;/extras/jmeter-results-detail-report_21.xsl&quot; &gt; &lt;param name=&quot;dateReport&quot; expression=&quot;$&#123;report.datestamp&#125;&quot;/&gt; &lt;/xslt&gt; &lt;!-- 因为上面生成报告的时候，不会将相关的图片也一起拷贝至目标目录，所以，需要手动拷贝 --&gt; &lt;copy todir=&quot;$&#123;jmeter.result.html.dir&#125;&quot;&gt; &lt;fileset dir=&quot;$&#123;jmeter.home&#125;/extras&quot;&gt; &lt;include name=&quot;collapse.png&quot; /&gt; &lt;include name=&quot;expand.png&quot; /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;/target&gt;&lt;/project&gt; 运行前的配置​ 需要将 /usr/local/jmeter/apache-jmeter-5.3/extras/里的ant-jmeter-1.1.1.jar复制到ant的lib目录下 jenkins创建项目 在Jenkins上创建一个自由风格的项目 然后使用在配置里进行管理配置，选择使用git管理。 构建步骤选择“Invoke Ant”，见下图 构建后操作分别选择：Publish Performance test result report和Publish HTML reports 见下图： 注意事项！！1.Ant环境变量配置由于时依赖Ant的，所有Jenkins需要先配置好Ant，路径是 系统管理–全局工具配置 2.构建操作也要记得选择Ant。3.jmeter.log (Permission denied)构建时出现报错，如下图所示，关键词：jmeter.log (Permission denied) ​ 原因是：jmeter.log 没有权限，需要到jmeter的安装目录去修改权限 一般情况下的jmeter安装目录：/usr/local/jmeter/apache-jmeter-5.3/bin","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"Centos安装python3.8.x","slug":"Centos安装python3.8.x","date":"2020-09-15T09:02:00.000Z","updated":"2020-09-23T11:48:00.000Z","comments":true,"path":"Centos安装python3.8.x.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85python3.8.x.html","excerpt":"最近使用centos重装了服务器之后，运行之前的python脚本，都会出现一些怪异的报错，但本地PC没有任何问题，这里怀疑是Python版本导致的，所以找了一些文章，这里记录一下安装的过程.","text":"最近使用centos重装了服务器之后，运行之前的python脚本，都会出现一些怪异的报错，但本地PC没有任何问题，这里怀疑是Python版本导致的，所以找了一些文章，这里记录一下安装的过程. 下载python3.8.x wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz 安装编译所需要的开发包 yum -y install gcc zlib* libffi-devel 解压python的tgz文件 tar -zxvf Python-3.8.5.tgz 进入python文件：cd Python-3.8.5/ 配置python3.8.5：./configure --prefix=/usr/local/bin/python3 编译python：make 安装python：make install 备份python3软链接：mv /usr/bin/python3 /usr/bin/python3.bak 备份pip3软链接： mv /usr/bin/pip3 /usr/bin/pip3.bak 删除软链接：rm -rf /usr/bin/python3 添加python软链接：ln -s /usr/local/bin/python3/bin/python3 /usr/bin/python3 添加pip3软链接：ln -sf /usr/local/bin/python3/bin/pip3 /usr/bin/pip3 查看升级后的版本：python3 -V 安装完成后，python3可用了，但感觉怪怪的，后续再找其他的方法试试","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux安装jmeter","slug":"Linux安装jmeter","date":"2020-09-15T03:24:00.000Z","updated":"2020-09-15T03:24:00.000Z","comments":true,"path":"Linux安装jmeter.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E5%AE%89%E8%A3%85jmeter.html","excerpt":"记录Linux安装jmeter的步骤和方法。","text":"记录Linux安装jmeter的步骤和方法。 大前提：都需要安装好jdk，可以参考Linux下jenkins部署遇到的问题记录 Centos新建jmeter目录：mkdir /usr/local/jmeter 进入jmeter目录：cd /usr/local/jmeter 下载最新版安装包： wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.3.tgz 解压：tar -zxvf apache-jmeter-5.3.tgz 配置系统环境变量：vim /etc/profile 在最后添加： 123export JMETER_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jmeter&#x2F;apache-jmeter-5.3export CLASSPATH&#x3D;$JMETER_HOME&#x2F;lib&#x2F;ext&#x2F;ApacheJMeter_core.jar:$JMETER_HOME&#x2F;lib&#x2F;jorphan.jar:$JMETER_HOME&#x2F;lib&#x2F;logkit-2.0.jar:$CLASSPATHexport PATH&#x3D;$JMETER_HOME&#x2F;bin:$PATH:$HOME&#x2F;bin 使配置生效：source /etc/profile 查看JMeter 版本：jmeter -v","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"}]},{"title":"UI自动化常见两种框架与区别","slug":"UI自动化常见框架与区别","date":"2020-09-03T12:16:00.000Z","updated":"2020-09-03T12:28:38.000Z","comments":true,"path":"UI自动化常见框架与区别.html","link":"","permalink":"https://www.lauyongyi.cn/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%8C%BA%E5%88%AB.html","excerpt":"关于Unittest与pytest的特点与区别","text":"关于Unittest与pytest的特点与区别 一、Unittest ​ Unittest是Python标准库中自带的单元测试框架，Unittest有时候也被称为PyUnit，就像JUnit是Java语言的标准单元测试框架一样，Unittest则是Python语言的标准单元测试框架。Unittest支持自动化测试，测试用例的初始化、关闭和测试用例的聚合等功能，它有一个很重要的特性：它是通过类(class)的方式，将测试用例组织在一起。 二、Pytest Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。pytest的特性有： 支持用简单的assert语句实现丰富的断言，无需复杂的self.assert* 函数自动识别测试模块和测试函数 模块化夹具用以管理各类测试资源对 unittest 完全兼容，对 nose基本兼容 支持Python3和PyPy3丰富的插件生态，已有300多个各式各样的插件，社区繁荣 Unittest pytest 用例编写规则 1、测试文件必须先import unittest2)测试类必须继承unittest.TestCase3)测试方法必须以“test_”开头4)测试类必须要有unittest.main()方法 1)测试文件名必须以“test_”开头或者”_test”结尾（如：test_ab.py）2)测试方法必须以“test_”开头3)测试类命名以”Test”开头 用例分类执行 默认执行全部用例，也可以通过加载testsuit，执行部分用例 可以通过@pytest.mark来标记类和方法，pytest.main加入参数(“-m”)可以只运行标记的类和方法 用例前置和后置 提供了setUp/tearDown，只能针对所有用例 pytest中的fixture显然更加灵活。可以任意自定义方法函数，只要加上@pytest.fixture()这个装饰器，那么被装饰的方法就可以被使用 参数化 需依赖ddt库 使用@pytest.mark.parametrize装饰器 断言 很多断言格式(assertEqual、assertIn、assertTrue、assertFalse) 只有assert一个表达式，用起来比较方便 报告 使用HTMLTestRunner库 有pytest-HTML、allure插件 失败重跑 无此功能 pytest支持用例执行失败重跑，pytest-rerunfailures插件","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"},{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"apache bench参数解释","slug":"apache bench参数解释","date":"2020-08-31T06:19:00.000Z","updated":"2020-09-01T07:46:12.000Z","comments":true,"path":"apache bench参数解释.html","link":"","permalink":"https://www.lauyongyi.cn/apache%20bench%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A.html","excerpt":"记录一下了解到的apache bench相关的知识","text":"记录一下了解到的apache bench相关的知识 设备条件有限，只能先用Windows来做试验，等改天把服务器腾出来就来倒腾 Windows平台下，使用Xampp安装 Apache等。然后进入安装目录 xampp\\apache\\bin&gt;，执行命令.\\ab.exe，出现下面的内容 1234567891011121314151617181920212223242526272829303132333435363738C:\\xampp\\apache\\bin\\ab.exe: wrong number of argumentsUsage: C:\\xampp\\apache\\bin\\ab.exe [options] [http:&#x2F;&#x2F;]hostname[:port]&#x2F;pathOptions are: Options are: -n requests 要执行请求总数，默认会执行一个请求 -c concurrency 一次执行多个请求的数量，也就是并发数 -t timelimit 用于基准测试的最大秒数，使用它在固定的总时间内对服务器进行基准测试。默认情况下，没有时间限制。 -s timeout 超时之前等待的最大秒数。 默认值是30秒。 -b windowsize TCP发送&#x2F;接收缓冲区的大小，以字节为单位。 -B address 进行传出连接时要绑定的地址。 -p postfile 包含数据到POST的文件。 还请记住设置-T。 -u putfile 包含PUT数据的文件。 还请记住设置-T 。 -T content-type Content-type用于POST &#x2F; PUT数据的内容类型内容类型标题，例如：&#39;application&#x2F;x-www-form-urlencoded&#39; 默认是&#39; &#39;text&#x2F;plain&#39; -v verbosity verbosity 要打印多少个疑难解答信息，设置详细级别 - 4和以上打印标题信息，3和以上打印响应代码（404,200等），2和以上打印警告和信息。 -w 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。 -i 执行HEAD请求，而不是GET。 -x attributes 用作&lt;table&gt;的属性的字符串。 属性被插入&lt;table here&gt;。 -y attributes 用作&lt;tr&gt;的属性的字符串。 -z attributes 用作&lt;td&gt;的属性的字符串。 -C attribute 将cookie添加到请求。 参数通常采用名称&#x3D;值对的形式。 这个字段是可重复的。 -H attribute 例如 ‘Accept-Encoding: gzip’ 插入所有普通标题行之后 -A attribute 添加基本的WWW认证，该属性是一个冒号分隔的用户名和密码，auth-username:password -P attribute 添加基本代理验证，属性是一个冒号分隔的用户名和密码，proxy-auth-username:password -X proxy:port 使用代理服务器和端口号。 -V 打印版本号并退出。 -k 使用HTTP KeepAlive功能。 -d 不要显示百分点服务表。 -S 不要显示信心估计和警告。 -q 做超过150个请求时不要显示进度。 -g filename 将收集的数据输出到gnuplot格式文件。 -e filename 输出提供百分比的CSV文件。 -r 不要退出套接字接收错误。 -h 显示使用情况信息（此消息）。 -Z ciphersuite 密码套件指定SSL &#x2F; TLS密码套件（请参阅openssl密码） -f protocol 指定SSL &#x2F; TLS协议 (SSL3, TLS1, TLS1.1, TLS1.2 or ALL) 进行一次操作之后，发现了一些报告名词 ab -c 100 -n 100 -t 200 https://www.baidu.com/ 1234567891011121314151617181920212223242526272829303132333435Server Software: ##apache版本Server Hostname: ##请求的机子Server Port: ##请求端口Document Path: &#x2F;a.htmlDocument Length: ##页面长度Concurrency Level: ##并发数Time taken for tests: ##共使用了多少时间Complete requests: ##请求数Failed requests: ##失败请求Write errors: 0 Total transferred: ##总共传输字节数，包含http的头信息等HTML transferred: ##html字节数，实际的页面传递字节数Requests per second: ##每秒多少请求，这个是非常重要的参数数值，服务器的吞吐量Time per request: ##用户平均请求等待时间Time per request: ##服务器平均处理时间，也就是服务器吞吐量的倒数Transfer rate: ##每秒获取的数据长度Connection Times (ms) min mean[+&#x2F;-sd] median maxConnect: 25 50 19.3 51 81Processing: 7 20 24.7 9 73Waiting: 7 13 16.1 8 59Total: 33 70 25.3 73 108Percentage of the requests served within a certain time (ms) 50% 73 ## 50%的请求在73ms内返回 66% 86 ## 60%的请求在86ms内返回 75% 90 80% 98 90% 108 95% 108 98% 108 99% 108100% 108 (longest request)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"apache bench","slug":"apache-bench","permalink":"https://www.lauyongyi.cn/tags/apache-bench/"}]},{"title":"一个搜索输入框测试实例","slug":"一个搜索输入框测试实例","date":"2020-08-14T06:16:00.000Z","updated":"2020-08-14T06:28:38.000Z","comments":true,"path":"一个搜索输入框测试实例.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E8%BE%93%E5%85%A5%E6%A1%86%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B.html","excerpt":"记录一个关于搜索框相关的测试实例","text":"记录一个关于搜索框相关的测试实例 1）验证可获得结果的查询以及翻页：使用普通关键字，查看搜索结果是否符合预期，查询结果是否包含该关键字。 ​ 注意：找出能在电脑版上查询出结果的3个关键字，而且查询结果超过一页显示，这样能够同时测试翻页后的结果是否准确，例如“a”，“vic”等。 2）测试不同页面的搜索 3）检查系统定制的“404 Not Found”页面是否能正确显示，需要使用一个无法查到结果的关键字。这个点是查看对异常处理的流程是否正确。 例如：一个能显示出404的关键字，“error_found_aaa_bbb”。 4）测试特定文本查询 例如：淘宝、京东的”百亿补贴“。 5）特殊符号处理：一般文本输入框对特殊字符处理得不够好，如何区分特殊符号？区分特殊符号的基本原则如下。 ​ ▼特殊字符：在程序代码中被作为特殊符号、特殊用法去使用，例如“! @#$%”； 例如：测试人员可以快速使用“! @#$%^&amp;*（）_+{}|:”&lt;&gt;? ”这样的文本，输入后点击查询，看是否会出现异常。 ​ ▼界定文本范围：在数据库中被用来作为通配符，以及单引号和双引号等。 6）测试关键字联合查询：类似在Google里使用空格分开多个关键字进行联合查询一样 测试过程中，用多个关键字做联合查询，发现系统除了支持用空格、分号做分隔符，还自动把一些特殊符号作为分隔符（例如“!@#$%^&amp;*（）_+{}:”&lt;&gt;? ”等）。需要查看使用这些特殊符号做分隔符后，查询结果是否正常。 7）测试多语言支持：该网站是英文版，但不排除有人使用其他语种文字进行查询，这里需要测试输入其他语种文字的处理情况，不应该抛出500 ERROR页面。 除英文以外的字符，使用其他字符集的文本，例如“ﻡﻼﺴﻟﺍ ﻢﻜﻴﻠﻋ”和“中文”。 8）验证过长字符串：验证输入过长的字符串是否处理正确。 ​ 注意：这里可以 通过修改html代码限制实现更多的输入 9）多个输入域关联查询：除了关键字输入框外，该网页还有其他输入域，需要把它们都设置值后进行关联查询，看查询结果是否准确。10）在不同手机浏览器上查看界面显示：这主要在项目需要支持的各种真实手机上测试，可以有效避免模拟器漏掉Bug，横竖屏都进行测试，查看是否出现界面变形、难以点击与输入等问题，以及输入框内的背景文字等是否能正常显示等。 11）字段值回填功能：用户输入数据后，如果重新修改过滤条件，系统就会把用户最初填写过的数据回填到对应的输入框中，以便用户修改。 注意：这里主要注意英文大小写回填是否正常。 12）测试联合查询生成URL的情况：在已上线运行的电脑版网站中搜索关键字，并查询，页面会跳转到结果页面，URL也会做对应改变。开发已把电脑版网站上对应的URL拷贝到手机网站上打开，需要查询结果相同。测试过程就不能只简单针对一个关键字，而是需要考虑这个关键字输入框以及页面上其他输入域联合查询后生成的URL的情况。 13）安全问题：考虑会不会出现XSS或者Sql Injection的安全问题。","categories":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/categories/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}]},{"title":"安卓命令行打包","slug":"命令行打包apk","date":"2020-07-24T08:28:00.000Z","updated":"2020-07-24T09:03:55.000Z","comments":true,"path":"命令行打包apk.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%8C%85apk.html","excerpt":"为了配合Jenkins做持续集成，研究了安卓的打包方式。这里做个记录，方便后续查看。","text":"为了配合Jenkins做持续集成，研究了安卓的打包方式。这里做个记录，方便后续查看。 Android Apk 打包方式有两种 一种是使用Android Studio自带工具 build =&gt; debug/release. （签名包需要生成签名）另一种一中方式 是通过命令行使用gradlew命令打包。命令行在生成签名包同样需要在gradlew中 配置签名信息。 打包命令的配置，参考链接：简书cuzzyapp下gradle中配置手动配置方法File-&gt; Project Structure-&gt; module -&gt; app -&gt; Signing Configs（填写签名文件信息）-&gt;Default Config （选中debug/release）选择需要的Signing Config-&gt;Apply 同步后app下gradle文件会出现下方配置 1234567891011121314signingConfigs &#123; release &#123; storeFile file(&#x27;..\\\\testdemo.jks&#x27;) storePassword &#x27;aa123456&#x27; keyPassword &#x27;aa123456&#x27; keyAlias &#x27;key0&#x27; &#125; debug &#123; storeFile file(&#x27;..\\\\testdemo.jks&#x27;) storePassword &#x27;aa123456&#x27; keyPassword &#x27;aa123456&#x27; keyAlias &#x27;key0&#x27; &#125; &#125; terminal命令行中使用 gradlew assembleRelease 运行 即可生成签名包可简写为 gradlew aR 同理如果测试需要debug包则为gradlew aD apk自定义命名的配置为了回归测试，需要将包命名根据日期进行命名，找到了一下方法，参考链接：简书MonkeyLei 123456789101112android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; def date = new Date().format(&quot;yyyyMMddHHmm&quot;, TimeZone.getTimeZone(&quot;GMT+08&quot;)) if (variant.buildType.name.equals(&#x27;debug&#x27;)) &#123; ///&quot;commonui_$&#123;date&#125;_$&#123;versionName&#125;.apk&quot; outputFileName = &quot;commonpop.apk&quot; &#125; if (variant.buildType.name.equals(&#x27;release&#x27;)) &#123; outputFileName = &quot;commonpop_$&#123;date&#125;.apk&quot; &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"Centos配置SDK,gradle","slug":"centos配置SDK","date":"2020-07-24T02:28:00.000Z","updated":"2020-07-24T02:28:00.000Z","comments":true,"path":"centos配置SDK.html","link":"","permalink":"https://www.lauyongyi.cn/centos%E9%85%8D%E7%BD%AESDK.html","excerpt":"为了配合Jenkins做持续集成，找了一些关于Centos Android打包的环境变量配置，这里记录一下，方便后期的继续使用。","text":"为了配合Jenkins做持续集成，找了一些关于Centos Android打包的环境变量配置，这里记录一下，方便后期的继续使用。 Android SDK安装123456789101112131415161718192021# 下载sdk工具包$ wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip# 创建sdk工具文件夹和解压工具包$ mkdir -p /opt/android/sdk$ unzip sdk-tools-linux-3859397.zip -d /opt/android/sdk# 使用sdkmanager工具配置构建工具和平台版本$ cd /opt/android/sdk/tools/bin/$ ./sdkmanager --list #可以查看有哪些版本，自行选择对应的版本$ ./sdkmanager &quot;build-tools;29.0.3&quot; &quot;platforms;android-29&quot; &quot;platform-tools&quot; # 增加系统环境变量$ vim /etc/profileexport ANDROID_HOME=/opt/android/sdkPATH=$PATH:$ANDROID_HOME:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/emulator:$ANDROID_HOME/tools/bin$ adb versionAndroid Debug Bridge version 1.0.41Version 30.0.4-6686687Installed as /opt/android/sdk/platform-tools/adb 安装gradle12345678910111213141516171819$ wget https://downloads.gradle-dn.com/distributions/gradle-6.3-all.zip$ mkdir /opt/gradle$ unzip gradle-6.3-all.zip -d /opt/gradle/$ vim /etc/profileexport PATH=$PATH:/opt/gradle/gradle-6.3/bin$ source /etc/profile$ gradle -v------------------------------------------------------------Gradle 6.3------------------------------------------------------------Build time: 2020-03-24 19:52:07 UTCRevision: bacd40b727b0130eeac8855ae3f9fd9a0b207c60Kotlin: 1.3.70Groovy: 2.5.10Ant: Apache Ant(TM) version 1.10.7 compiled on September 1 2019JVM: 1.8.0_261 (Oracle Corporation 25.261-b12)OS: Linux 4.18.0-80.el8.x86_64 amd64","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"},{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"pytest脚本遇到 missing from arguments","slug":"pytest脚本missing from arguments","date":"2020-07-03T10:47:00.000Z","updated":"2020-07-03T10:47:30.000Z","comments":true,"path":"pytest脚本missing from arguments.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E8%84%9A%E6%9C%ACmissing%20from%20arguments.html","excerpt":"写自动化脚本的时候遇到了报错：“TypeError: required field “posonlyargs” missing from arguments”","text":"写自动化脚本的时候遇到了报错：“TypeError: required field “posonlyargs” missing from arguments” 原因：版本兼容问题，或者说allure插件版本的问题。 解决方法：建议降低python版本号（改为python 3.6）。如果不想卸载python，可以升allure：如果安装的是allure adaptor,此版本最新是1.7,不能继续往上升级，所以先把电脑里的allure卸载了，命令是：pip uninstall pytest-allure-adaptor然后再升级，直接安装allure-pytest，命令是：pip install allure-pytest","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"pytest前置和后置","slug":"pytest前置和后置","date":"2020-06-25T07:30:00.000Z","updated":"2020-09-16T10:24:21.000Z","comments":true,"path":"pytest前置和后置.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE.html","excerpt":"概 念 前置是指在用例执行前需要执行的代码，如连接数据库、打开浏览器等，后置是指用例执行完毕后需要执行的代码，比如关闭数据库连接、关闭浏览器等。","text":"概 念 前置是指在用例执行前需要执行的代码，如连接数据库、打开浏览器等，后置是指用例执行完毕后需要执行的代码，比如关闭数据库连接、关闭浏览器等。 前置和后置都有很多种类，他们根据种类的不同，执行的顺序也不同，我们可以根据他们执行顺序的规则来进行设定，比如，先连接数据库，再打开浏览器，先关闭浏览器，再关闭数据库连接等。 当然，我们不使用前置和后置，通过把需要先执行的代码写到前面，需要后执行的代码写到后面的方式也可实现效果，但前置和后置为我们提供了一种更方便的解决方案，实际开发中需不需要使用看业务及个人习惯。 种类简介pytest的前置和后置包括如下几种： 模块级（setup_module/teardown_module）开始于模块始末，作用于全局（总用各执行一次） 函数级（setup_function/teardown_function）仅对函数用例生效。（即不在类中，每个函数执行一次） 类级（setup_class/teardown_class）只在类中前后运行一次。（在类中） 方法级（setup_method/teardown_method）开始于方法始末（在类中，每个方法执行一次） 类里面的（setup/teardown）运行在调用方法的前后（每个方法执行一次） Demo代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env python# -*- coding:utf-8 -*-def setup_module(): print(&quot;\\n setup_module,只执行一次，当有多个测试类的时候使用&quot;)def teardown_module(): print(&quot;\\n teardown_module,只执行一次，当有多个测试类的时候使用&quot;)class TestPytest1(object): @classmethod def setup_class(cls): print(&quot;\\n setup_class1,只执行一次&quot;) @classmethod def teardown_class(cls): print(&quot;\\n teardown_class1, 只执行一次&quot;) def setup_mtehod(self): print(&quot;\\nsteup_method1，每个测试方法都执行一次&quot;) def teardown_method(self): print(&quot;teardown_method1，每个测试方法都执行一次&quot;) def test_three(self): print(&quot;test_three,测试用例&quot;) def test_four(self): print(&quot;test_four,测试用例&quot;)class TestPytest2(object): @classmethod def setup_class(cls): print(&quot;\\nteardown_class2,只执行一次&quot;) @classmethod def teardown_class(cls): print(&quot;\\nteardown_class2，只执行一次&quot;) def setup_method(self): print(&quot;\\nsetup_method2，每个测试方法都执行一次&quot;) def teardown_method(self): print(&quot;teardown_method2，每个测试方法都执行一次&quot;) def test_two(self): print(&quot;test_two，测试用例&quot;) def test_one(self): print(&quot;test_one，测试用例&quot;) 运行结果如下： setup_module是在所有用例执行的时候最先运行的，teardown_module是所有用例结束时执行的 setup_class是在其他用例执行前运行的，teardown_class是在其他用例执行完成后运行的。 setup_method是在每一条用例执行前，且在setup执行前运行的，teardown_method是在每一条用例执行完成后，且在teardown执行完成后运行的。 setup是在每条用例执行前运行，teardown是在每条用例执行完成后运行。 所以，它们的调用顺序是 setup_module &gt; setup_class &gt; setup_method &gt; setup &gt; teardown &gt; teardown_method &gt; teardown_class &gt; teardown_module","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"Pytest用例失败重跑","slug":"pytest失败重跑","date":"2020-06-25T06:19:00.000Z","updated":"2020-09-25T09:40:12.000Z","comments":true,"path":"pytest失败重跑.html","link":"","permalink":"https://www.lauyongyi.cn/pytest%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91.html","excerpt":"用例重跑有两种方法，利用pytest-rerunfailures包，和直接使用@pytest.mark.flaky(reruns=重跑次数,reruns_delay=间隔时间)装饰器。","text":"用例重跑有两种方法，利用pytest-rerunfailures包，和直接使用@pytest.mark.flaky(reruns=重跑次数,reruns_delay=间隔时间)装饰器。 pytest-rerunfailures包pip install pytest-rerunfailures #安装pytest-rerunfailures 安装好后，只要执行命令 pytest test_study.py –reruns n 即可实现失败重跑。 其中n代表重跑次数，如，输入 pytest test_add.py -–reruns 3 代表用例失败后尝试重新执行3次，注意，是用例执行失败后尝试执行3次，加上第一次失败的那次，总共执行4次。 执行结果： @pytest.mark.flaky(reruns=n,reruns_delay=t)装饰器装饰器 @pytest.mark.flaky(reruns=n,reruns_delay=t) ，其中n是指重跑次数，t是指间隔时间。 直接使用结果如下图： 把参数设为变量结果如下图：","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"Pytest基础学习记录","slug":"Pytest基础学习记录","date":"2020-06-25T03:19:00.000Z","updated":"2020-09-16T09:40:12.000Z","comments":true,"path":"Pytest基础学习记录.html","link":"","permalink":"https://www.lauyongyi.cn/Pytest%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html","excerpt":"Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。","text":"Pytest是Python的另一个第三方单元测试库。它的目的是让单元测试变得更容易，并且也能扩展到支持应用层面复杂的功能测试。 在了解了Pytest的一些基础之后，照着网上的教程，写了一个简单的Demo，用来验证和记录一些基础。 12345678910111213141516171819#! /usr/bin/env python# -*- coding:utf-8 -*-def add(x,y): return x + ydef test_add(): assert add(1, 10) == 11 assert add(1, 1) == 2 assert add(1, 99) == 100class TestClass: def test_two(self): x = &quot;hello&quot; assert hasattr(x, &quot;check&quot;) @pytest.mark.add def test_one(self): x = &quot;this&quot; assert &quot;h&quot; in x 关于Pytest的运行参数记录：（可以使用pytest –help 查看帮助文档） 无参数模式：​ 读取路径下所有符合规则的文件，类，方法，函数全部执行。使用方法如下pytest 或 py.test。 运行结果如下： 12345678910111213141516171819202122&gt;py.test======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py ..F [100%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x00000280287AD070&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:19: AssertionError=================================================================== 1 failed, 2 passed in 0.10s ==================================================================== 结果比较简略，没有太多的运行细节。 -v 参数：​ 打印详细运行日志信息，一般在调试的时候加上这个参数，终端会打印出每条用例的详细日志信息，方便定位问题。 -s 参数: 带控制台输出效果，代码中带有“print”语句时，才有效果，常用于调试。 pytest -s 123456789101112131415161718192021222324252627&gt;pytest -v test_add.py======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#x27;Python&#x27;: &#x27;3.8.4rc1&#x27;, &#x27;Platform&#x27;: &#x27;Windows-10-10.0.18362-SP0&#x27;, &#x27;Packages&#x27;: &#123;&#x27;pytest&#x27;: &#x27;5.2.1&#x27;, &#x27;py&#x27;: &#x27;1.9.0&#x27;, &#x27;pluggy&#x27;: &#x27;0.13.1&#x27;&#125;, &#x27;Plugins&#x27;: &#123;&#x27;html&#x27;: &#x27;2.1.0&#x27;, &#x27;metadata&#x27;: &#x27;1.10.0&#x27;, &#x27;rerunfailures&#x27;: &#x27;7.0&#x27;&#125;, &#x27;JAVA_HOME&#x27;: &#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#x27;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_one PASSED [ 66%]test_add.py::TestClass::test_two FAILED [100%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x0000017441950610&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:19: AssertionError=================================================================== 1 failed, 2 passed in 0.10s ==================================================================== 相较于没有参数的运行方式，-v 多了执行结果。 -k 参数:​ 执行指定关键字的用例。用法如下： ​ pytest -k ‘类名’ ​ pytest -k ‘方法名’ ​ pytest -k ‘类名 and not 方法名’ #运行类里所有方法，不包含某个方法 -x 参数:​ 遇到用力失败立即停止运行。 12345678910111213141516171819202122232425&gt;pytest -x -v======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#x27;Python&#x27;: &#x27;3.8.4rc1&#x27;, &#x27;Platform&#x27;: &#x27;Windows-10-10.0.18362-SP0&#x27;, &#x27;Packages&#x27;: &#123;&#x27;pytest&#x27;: &#x27;5.2.1&#x27;, &#x27;py&#x27;: &#x27;1.9.0&#x27;, &#x27;pluggy&#x27;: &#x27;0.13.1&#x27;&#125;, &#x27;Plugins&#x27;: &#123;&#x27;html&#x27;: &#x27;2.1.0&#x27;, &#x27;metadata&#x27;: &#x27;1.10.0&#x27;, &#x27;rerunfailures&#x27;: &#x27;7.0&#x27;&#125;, &#x27;JAVA_HOME&#x27;: &#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#x27;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]============================================================================= FAILURES =============================================================================________________________________________________________________________ TestClass.test_two ________________________________________________________________________self = &lt;test_add.TestClass object at 0x00000204DCDDEBE0&gt; def test_two(self): x = &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False = hasattr(&#x27;hello&#x27;, &#x27;check&#x27;)test_add.py:15: AssertionError=================================================================== 1 failed, 1 passed in 0.11s ==================================================================== –maxfail参数:​ 用例失败个数达到阀值停止运行，具体用法如下：pytest –maxfail=[num] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;pytest -v --maxfail&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#39;Python&#39;: &#39;3.8.4rc1&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.18362-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;5.2.1&#39;, &#39;py&#39;: &#39;1.9.0&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;html&#39;: &#39;2.1.0&#39;, &#39;metadata&#39;: &#39;1.10.0&#39;, &#39;rerunfailures&#39;: &#39;7.0&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#39;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]test_add.py::TestClass::test_one PASSED [100%]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;________________________________________________________________________ TestClass.test_two ________________________________________________________________________self &#x3D; &lt;test_add.TestClass object at 0x000001DD58CFFBB0&gt; def test_two(self): x &#x3D; &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False &#x3D; hasattr(&#39;hello&#39;, &#39;check&#39;)test_add.py:15: AssertionError&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed, 2 passed in 0.11s &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;pytest -v --maxfail&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; test session starts &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1 -- c:\\python\\python.execachedir: .pytest_cachemetadata: &#123;&#39;Python&#39;: &#39;3.8.4rc1&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.18362-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;5.2.1&#39;, &#39;py&#39;: &#39;1.9.0&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;html&#39;: &#39;2.1.0&#39;, &#39;metadata&#39;: &#39;1.10.0&#39;, &#39;rerunfailures&#39;: &#39;7.0&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_191&#39;&#125;rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items test_add.py::test_add PASSED [ 33%]test_add.py::TestClass::test_two FAILED [ 66%]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; FAILURES &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;________________________________________________________________________ TestClass.test_two ________________________________________________________________________self &#x3D; &lt;test_add.TestClass object at 0x000001D5B04F3B80&gt; def test_two(self): x &#x3D; &quot;hello&quot;&gt; assert hasattr(x, &quot;check&quot;)E AssertionError: assert FalseE + where False &#x3D; hasattr(&#39;hello&#39;, &#39;check&#39;)test_add.py:15: AssertionError&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 1 failed, 1 passed in 0.10s &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; -m参数:​ 将用例进行分类，使用 @pytest.mark.XXX进行标记。运行是执行：pytest -m XXX 1234567D:\\Git\\pytestDemo&gt;pytest -m add======================================================================= test session starts ========================================================================platform win32 -- Python 3.8.4rc1, pytest-5.2.1, py-1.9.0, pluggy-0.13.1rootdir: D:\\Git\\pytestDemoplugins: html-2.1.0, metadata-1.10.0, rerunfailures-7.0collected 3 items / 2 deselected / 1 selected test_add.py . -n 参数：​ pytest-xdist 是 pytest 分布式执行插件，可以多个CPU或者主机执行，插件预先用户将测试并发执行（进程级并发），插件是动态决定测试用例执行顺序的，为了保证各个测试能在各个独立线程里正确的执行，应该保证测试用例的独立性。多个CPU 并行执行用例，需要在 pytest 后面添加 -n 参数，如果参数为 auto ，会自动检查系统的PCU数目，如果参数为数字，则指定运行测试的处理器进程数。使用方法： ​ pytest -n auto ​ pytest -n [num]","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"}]},{"title":"python简易爬虫获取壁纸","slug":"python简易爬虫获取壁纸","date":"2020-06-20T06:16:00.000Z","updated":"2020-06-20T06:28:38.000Z","comments":true,"path":"python简易爬虫获取壁纸.html","link":"","permalink":"https://www.lauyongyi.cn/python%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E5%A3%81%E7%BA%B8.html","excerpt":"记录一下只用re，request，os编写的简易爬虫","text":"记录一下只用re，request，os编写的简易爬虫 需要爬取的页面：https://wallhaven.cc/latest 页面分析，获取壁纸详情页的链接使用浏览器自带的控制台（快捷键F12）对页面元素进行分析,找到壁纸详情页的链接，如图中红框。编写相关的正则表达式， 123456# 第一次正则匹配，获取图片部分的全部html代码（记得转成str类型）detailed_context = str(re.findall(&#x27;&lt;section class=&quot;thumb-listing-page&quot;&gt;(.*?)&lt;/section&gt;&#x27;, detailed_html, re.S))# 第二次匹配，获取图片url的具体html代码detailed_html = str(re.findall(&#x27;&lt;li&gt;(.*?)&lt;/li&gt;&#x27;, detailed_context, re.S))# 第三次匹配，提示图片详情的urldetailed_list = re.findall(&#x27;&lt;a class=&quot;preview&quot; href=&quot;(.*?)&quot; target=&quot;_blank&quot; &gt;&lt;/a&gt;&#x27;, detailed_html, re.S) 因为只用了“re”用来提取URL，所以为了方便展示用了3次正则匹配来提示壁纸详情的URL。PS：编写的正则表达式可以用在线正则表达式测试进行验证 获取壁纸的下载地址用https://wallhaven.cc/w/xlmgjo举例。使用控制台进行元素定位之后，可以看到有一个后缀位.jpg的链接（也有可能是.png),这个就是我们要的链接。 1img_url = re.search(&#x27;&lt;img id=&quot;wallpaper&quot; src=&quot;(.*?)&quot;&#x27;, html, re.S).group(1) 完整代码如下：1234567891011121314151617181920212223242526import requests, os, reheaders = &#123; &quot;Host&quot;: &quot;wallhaven.cc&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot; &#125;start_url = &#x27;https://wallhaven.cc/latest&#x27;detailed_html = requests.get(start_url,headers=headers).text# 第一次正则匹配，获取图片部分的全部html代码（记得转成str类型）detailed_context = str(re.findall(&#x27;&lt;section class=&quot;thumb-listing-page&quot;&gt;(.*?)&lt;/section&gt;&#x27;, detailed_html, re.S))# 第二次匹配，获取图片url的具体html代码detailed_html = str(re.findall(&#x27;&lt;li&gt;(.*?)&lt;/li&gt;&#x27;, detailed_context, re.S))# 第三次匹配，提示图片详情的urldetailed_list = re.findall(&#x27;&lt;a class=&quot;preview&quot; href=&quot;(.*?)&quot; target=&quot;_blank&quot; &gt;&lt;/a&gt;&#x27;, detailed_html, re.S)for i in detailed_list: html = requests.get(i, headers=headers).text img_url = re.search(&#x27;&lt;img id=&quot;wallpaper&quot; src=&quot;(.*?)&quot;&#x27;, html, re.S).group(1) img_name = img_url.split(&#x27;/&#x27;)[-1] os.makedirs(&#x27;F:\\img&#x27;, exist_ok=True) r = requests.get(img_url, stream=True) with open(&#x27;F:\\img\\%s&#x27; % img_name, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=3072): f.write(chunk) print(&#x27;Saved %s&#x27; % img_name)","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"Robot Framework No keyword with name 'Get Json Value' found.","slug":"Robot Framework不同Py版本出现的问题","date":"2020-06-20T03:49:00.000Z","updated":"2020-06-20T03:53:19.000Z","comments":true,"path":"Robot Framework不同Py版本出现的问题.html","link":"","permalink":"https://www.lauyongyi.cn/Robot%20Framework%E4%B8%8D%E5%90%8CPy%E7%89%88%E6%9C%AC%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"解决办法： Get Json Value关键字只支持python2.x RequestsLibrary中的to json关键字 Get Json Value改为to json","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"Jenkins配置项目出现的错误","slug":"Jenkins配置项目出现的错误","date":"2020-06-17T03:10:00.000Z","updated":"2020-09-24T08:39:00.000Z","comments":true,"path":"Jenkins配置项目出现的错误.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF.html","excerpt":"记录Jenkins使用过程中遇到的一些问题和解决方法。","text":"记录Jenkins使用过程中遇到的一些问题和解决方法。 服务器没有安装GitJenkins新建项目中源码管理使用Git时遇到如下问题： Failed to connect to repository : Error performing command: git ls-remote -h …. 问题原因：没有安装Git 解决方法：安装Git，执行命令yum install git，出现选择提示的时候，输入Y即可。 没有安装谷歌浏览器和驱动执行selenium的时候，还没开始就结束了，查看运行日志得出，服务器没有安装浏览器以及驱动。 先安装最新版的Chrome：yum install https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm 或者： yum install google-chrome-stable_current_x86_64.rpm 安装成功后，检查版本号，根据版本号，下载驱动： 12&gt;google-chrome -version Google Chrome 85.0.4183.102 下载chromedriver驱动：历史版本 http://npm.taobao.org/mirrors/chromedriver 找到对应的驱动版本 使用wget下载Zip包 wget https://cdn.npm.taobao.org/dist/chromedriver/85.0.4183.87/chromedriver_linux64.zip 解压 ：unzip chromedriver_linux64.zip 解压后把chromedriver移动到/usr/bin/目录下 mv chromedriver /usr/bin/ 查看chromedriver版本号 12&gt;chromedriver --version ChromeDriver 75.0.3770.90 (a6dcaf7e3ec6f70a194cc25e8149475c6590e025-refs&#x2F;branch-heads&#x2F;3770@&#123;#1003&#125;) 配置全局Java变量运行Jmeter脚本的时候，提示：Neither the JAVA_HOME nor the JRE_HOME environment variable is defined 进入到全局变量查看，发现少配置了JAVA_HOME，然后按照下图进行配置 路径为java的安装路径","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"Jenkins集成selenium脚本的流程","slug":"Jenkins集成selenium脚本的流程","date":"2020-06-17T02:24:00.000Z","updated":"2020-06-17T06:57:56.000Z","comments":true,"path":"Jenkins集成selenium脚本的流程.html","link":"","permalink":"https://www.lauyongyi.cn/Jenkins%E9%9B%86%E6%88%90selenium%E8%84%9A%E6%9C%AC%E7%9A%84%E6%B5%81%E7%A8%8B.html","excerpt":"记录一下这两天使用Jenkins集成selenium的操作流程","text":"记录一下这两天使用Jenkins集成selenium的操作流程 Jenkins安装完默认插件后，还需要安装另外几个插件Startup Trigger，Groovy，HTML Publisher。 创建项目在Jenkins控制台，选择创建一个Freestyle project（自由格式的项目） 确定之后，进入项目配置页面。 添加Git在源码管理模块，选择Git构建触发器里选择Poll SCM（轮询），然后设置时间间隔例如：H/2 * * * *具体的其他时间间隔，可以点击旁边的问号图标，会有详细的例子说明 构建操作（Bulid）点击增加构建步骤（Add bulid step）选择对应的平台执行方法Windows选择Execute Windows batch commandLinux选择Execute shell 然后写上对应的执行语句。（Linux可能需要加上# !/bin/bash避免出现一个奇怪的问题） 构建后的操作点击增加构建步骤（Add bulid step），选择Execute system Groovy script使用默认的Groovy command，写入脚本语句System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;,&quot; &quot;) 这个操作是为了防止报告生成后，样式出错的措施。然后点击 Add post-build action(构建后操作)，选择添加Publish HTML reports HTML directory to archive 填写报告存放的路径，大部分情况下，都是test_report Index page[s] 添加默认的报告位置，大部分情况下是 **/report.html Index page title[s] (Optional) 报告的标题，可以随便填写 Report title 同上点击 Add post-build action(构建后操作)添加Publish JUnit test result report(构建统计用的插件）测试报告（XML）填写pytest生成的xml文件路径即可test_report/**/*.xml其他的保持默认选项即可，然后保存应用就行了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"Centos下Jenkins运行selenium遇到的问题","slug":"Centos下Jenkins运行selenium遇到的问题","date":"2020-06-16T14:00:00.000Z","updated":"2020-06-17T06:56:59.000Z","comments":true,"path":"Centos下Jenkins运行selenium遇到的问题.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E4%B8%8BJenkins%E8%BF%90%E8%A1%8Cselenium%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"使用Jenkins对selenium脚本进行持续集成，遇到了一些奇葩问题，所以用这篇文章记录一下","text":"使用Jenkins对selenium脚本进行持续集成，遇到了一些奇葩问题，所以用这篇文章记录一下 工程运行提示“权限不够”1234567PermissionError: [Errno 13] 权限不够: &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;atomicwrites&#39;Traceback (most recent call last): File &quot;run_tests.py&quot;, line 6, in &lt;module&gt; import clickModuleNotFoundError: No module named &#39;click&#39;Build step &#39;Execute shell&#39; marked build as failureFinished: FAILURE 属于权限不够导致的，解决方案，在Bulid(构建)选项里添加# !/bin/bash然后再到xshell执行pip3 install click即可 出现error: unrecognized arguments:1234ERROR: usage: run_tests.py [options] [file_or_dir] [file_or_dir] [...]run_tests.py: error: unrecognized arguments: --html&#x3D;F:\\Git\\JenkinsDemo&#x2F;test_report&#x2F;2020_06_16_20_58_22\\report.html --self-contained-html inifile: None rootdir: F:\\Git\\JenkinsDemo 原因是缺少 pytest-html，执行 install pytest-html```就可以了解决了。12#### 提示error: unrecognized arguments: --reruns 1 sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper2020-06-16 21:10:10,183 - INFO - 回归模式，开始执行✈✈！ERROR: usage: run_tests.py [options] [file_or_dir] [file_or_dir] […]run_tests.py: error: unrecognized arguments: –reruns 1 inifile: None rootdir: /var/lib/jenkins/workspace/GitTestDemo ```原因是缺少 pytest-rerunfailures，执行pip3 install pytest-rerunfailures即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"npm install 遇到的灵异问题","slug":"npm install 遇到的灵异问题","date":"2020-06-12T08:18:00.000Z","updated":"2020-06-12T08:46:23.000Z","comments":true,"path":"npm install 遇到的灵异问题.html","link":"","permalink":"https://www.lauyongyi.cn/npm%20install%20%E9%81%87%E5%88%B0%E7%9A%84%E7%81%B5%E5%BC%82%E9%97%AE%E9%A2%98.html","excerpt":"使用 123npm -g install newman遇到了：npm WARN checkPermissions Missing write access to &#x2F;usr&#x2F;local&#x2F;lib","text":"使用 123npm -g install newman遇到了：npm WARN checkPermissions Missing write access to &#x2F;usr&#x2F;local&#x2F;lib 具体报错信息如下： 官方给出的一个解决办法是给npm的global安装位置换个地方，因为默认的安装位置是/usr/local/lib所在的文件夹，这是系统的文件夹所在地，所以可能会出现一些读写问题。将module的安装根目录设置在一般的文件夹下则没有这么多问题，下面是官方方法： 12345678# 第一步：在你的用户文件下新建一个文件夹，这个.npm-global 名字可以用你自己喜欢的名字替换，推荐直接使用这个名字。mkdir ~&#x2F;.npm-global# 第二步：更改node的安装连接npm config set prefix &#39;~&#x2F;.npm-global&#39;# 第三步：在用户的profile下增加path，为的是系统能够找到可执行文件的目录 export PATH&#x3D;~&#x2F;.npm-global&#x2F;bin:$PATH# 第四步：update profile。使其生效source ~&#x2F;.profile 再次执行 1npm -g install newman 出现 1npm ERR! Maximum call stack size exceeded 解决方案 12rm package-lock.jsonnpm cache clean --force 然后在执行安装命令","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"}]},{"title":"Linux下jenkins部署遇到的问题记录","slug":"Linux下jenkins部署遇到的问题记录","date":"2020-06-11T09:48:00.000Z","updated":"2021-01-22T05:58:00.000Z","comments":true,"path":"Linux下jenkins部署遇到的问题记录.html","link":"","permalink":"https://www.lauyongyi.cn/Linux%E4%B8%8Bjenkins%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html","excerpt":"开始不定时的捣腾以前没有捣腾过的一些项目，首先尝试的是在Ubuntu和centos上安装Jenkins","text":"开始不定时的捣腾以前没有捣腾过的一些项目，首先尝试的是在Ubuntu和centos上安装Jenkins Ubuntu遇到的问题首先一定要安装JDK安装openjdk-8-jdk： 12apt-get updatesudo apt-get install openjdk-8-jdk 安装成功后查看版本，确认是否真的安装成功了（之前安装失败了，以为安装成功了，吐血) 1java -version 编辑/etc/profile，在文件尾添加java环境变量： 1sudo vi &#x2F;etc&#x2F;profile 或者 sudo vim &#x2F;etc&#x2F;profile 使用openjdk 1export JAVA_HOME&#x3D;&quot;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64&#x2F;jre&#x2F;bin&quot; Jenkins安装将存储库密钥添加到系统 1wget -q -O - https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian&#x2F;jenkins-ci.org.key | sudo apt-key add - 添加密钥后，系统将返回OK 。 接下来将Debian包存储库地址附加到服务器的sources.list ： 1echo deb http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;debian-stable binary&#x2F; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;jenkins.list 然后执行 12sudo apt-get updatesudo apt-get install jenkins Jenkins安装成功后的启动，一直卡在加载页面，查了之后，发现是权限问题。（因为用的不是root账号，所有文件权限有问题，需要将权限设置未“777”）显示用一下命令，找到Jenkins的安装位置（默认是在： /usr/share/jenkins） 1whereis jenkins 进入到 /usr/share/ 路径下，对 /jenkins 进行权限修改 1sudo chmod -R 777 jenkins&#x2F; 然后修改：/var/lib/jenkins/ 的 “hudson.model.UpdateCenter.xml” 123 &lt;url&gt;http:&#x2F;&#x2F;updates.jenkins-ci.org&#x2F;update-center.json&lt;&#x2F;url&gt;或者是： &lt;url&gt;http:&#x2F;&#x2F;mirror.esuni.jp&#x2F;jenkins&#x2F;updates&#x2F;update-center.json&lt;&#x2F;url&gt; 修改完成后，启动Jenkins服务。输入密码就可正常进入了 Centos安装JDK安装openjdkyum install java-1.8.0-openjdk-devel.x86_64编辑全局变量：vi /etc/profile复制粘贴以下内容 123export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-XXXXXXXexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jarexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin 注意：JAVA_HOME的路径后面的XXXXXXX为jdk 的对应版本，需要根据安装完成后做调整 然后执行source /etc/profile使全局变量立即生效然后执行java -version检查是否安装成功； 安装OracleJDK需要到Oracle下载最新的jdk，这里需要注册，除了邮箱地址需要正确填写（有个注册验证）其他信息可以随意填写。 将下图所示版本下载到本地 然后在centos 系统创建文件夹存放 方法1： 12345用Xftp把jdk-8u261-linux-x64.tar.gz上传到此目录tar -xzvf jdk-8u261-linux-x64.tar.gz #解压mv jdk1.8.0_261 /usr/local/java #重命名并移动到指定位置cd /usr/local #进入/usr/local目录 方法2： 12345678910cd /usr/local #进入/usr/local目录mkdir java #创建/usr/local/java目录cd java #进入java目录用Xftp把jdk-8u261-linux-x64.tar.gz上传到此目录tar -xzvf jdk-8u261-linux-x64.tar.gz #解压mv jdk1.8.0_261 jdk1.8 #重命名jdk1.8.0_261 配置系统环境变量：vim /etc/profile 添加 12345JAVA_HOME=/usr/local/java/ #方法1的配置JRE_HOME=/usr/local/java/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 使配置生效：source /etc/profile 查看java版本：java -version 安装jenkins123sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.reposudo rpm --import https:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat-stable&#x2F;jenkins.io.keyyum install jenkins 然后修改用户权限（不修改会出现启动失败的问题，很狗血） 123chown -R jenkins:jenkins &#x2F;var&#x2F;lib&#x2F;jenkinschown -R jenkins:jenkins &#x2F;var&#x2F;cache&#x2F;jenkinschown -R jenkins:jenkins &#x2F;var&#x2F;log&#x2F;jenkins 修改权限之后，使用systemctl start jenkins启动jenkins。 如果是使用OracleJdk的，还需要修改/etc/rc.d/init.d/jenkins里的jdk路径，下图所示的位置（需要精确到java可执行文件），否则会提示启动失败。 然后对 “hudson.model.UpdateCenter.xml”进行修改（不修改也可以，启动可能会比较慢，安装插件可能会出现失败的情况），方法Cenots的修改方法。 systemctl status jenkins查看Jenkins运行状态出现下图所示就是运行成功了 如果访问不了，可以执行firewall-cmd --permanent --zone=public --add-port=8080/tcp,开启8080端口，然后重启防火墙systemctl reload firewalld在执行firewall-cmd --list-ports确认8080端口是否开放出现下面的内容就表示开启成功 12[root@localhost ~]# firewall-cmd --list-ports8080&#x2F;tcp","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"}]},{"title":"robotframework 出现的错误提示","slug":"robotframework出现类型错误","date":"2020-06-02T08:12:00.000Z","updated":"2020-06-03T03:25:01.000Z","comments":true,"path":"robotframework出现类型错误.html","link":"","permalink":"https://www.lauyongyi.cn/robotframework%E5%87%BA%E7%8E%B0%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF.html","excerpt":"问题：返回的数据是字典，直接当成字符串输出","text":"问题：返回的数据是字典，直接当成字符串输出 问题：返回的数据是字典，直接当成字符串输出 修改前的脚本：–输出返回内容– Log Json ${content} INFO 修改为： Log ${content}","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"通过adb命令发送指定的键值","slug":"通过adb命令发送指定的键值","date":"2020-05-28T10:07:00.000Z","updated":"2020-06-11T09:47:30.000Z","comments":true,"path":"通过adb命令发送指定的键值.html","link":"","permalink":"https://www.lauyongyi.cn/%E9%80%9A%E8%BF%87adb%E5%91%BD%E4%BB%A4%E5%8F%91%E9%80%81%E6%8C%87%E5%AE%9A%E7%9A%84%E9%94%AE%E5%80%BC.html","excerpt":"测试过程中，有需要将App置于后台的操作，单一设备可以通过直接操作设备，但多设备情况下，手动操作有点耗费时间","text":"测试过程中，有需要将App置于后台的操作，单一设备可以通过直接操作设备，但多设备情况下，手动操作有点耗费时间 这里我用到 adb shell 里的 input 功能，+ python，实现多设备同时操作先编写获取在线设备的方法 1234567891011import osimport reconnectDeviceid &#x3D; []# 使用adb命令，获取连接到电脑的设备p &#x3D;os.popen(&#39;adb devices&#39;)# 输出链接到电脑的设备outstr &#x3D; p.read()# 用正则表达式匹配connectDeviceid &#x3D; re.findall(r&#39;(.*?)\\s+device\\s&#39;, outstr) 然后根据加上对应的keyCode命令 123for adbDevices in connectDeviceid: adbs &#x3D; &quot;adb -s %s shell input keyevent KEYCODE_HOME&quot; % (adbDevices) KEYCODE_HOME &#x3D; os.system(adbs) 将两段代码结合起来，就可完成多设备触发返回桌面的操作。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Docker化安装STF","slug":"Docker化安装STF","date":"2020-05-26T08:03:00.000Z","updated":"2020-06-11T10:31:39.000Z","comments":true,"path":"Docker化安装STF.html","link":"","permalink":"https://www.lauyongyi.cn/Docker%E5%8C%96%E5%AE%89%E8%A3%85STF.html","excerpt":"在乌班图物理机上使用docker安装STF","text":"在乌班图物理机上使用docker安装STF 拉取STF相关联的镜像 sudo docker pull openstf/stf:latest # STF镜像 sudo docker pull sorccu/adb:latest # android adb 镜像 sudo docker pull rethinkdb:latest # rethinkdb 镜像 sudo docker pull openstf/ambassador:latest sudo docker pull nginx:latest # nginx 代理镜像 每个镜像拉取都需要一定的时间，如果出现超时的错误，重新执行拉取命令即可。 等所有镜像拉取命令执行完成后，使用命令 sudo docker images 确认是否已全部拉取成功。 启动镜像先启动一个数据库sudo docker run -d –name rethinkdb -v /srv/rethinkdb:/data –net host rethinkdb rethinkdb –bind all –cache-size 8192 –http-port 8090 再启动adb servicesudo docker run -d –name adbd –privileged -v /dev/bus/usb:/dev/bus/usb –net host sorccu/adb:latest 再启动stf 启动的时配置的IP地址为你的网址sudo docker run -d –name stf –net host openstf/stf stf local –public-ip 【IP地址】 再使用命令： sudo docker ps -a 查看 启动的docker 容器。 访问STF访问地址是：IP:7100可以使用随机字符来登录系统","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"},{"name":"openSTF","slug":"openSTF","permalink":"https://www.lauyongyi.cn/tags/openSTF/"}]},{"title":"Centos安装Docker","slug":"Centos安装docker","date":"2020-05-26T07:30:00.000Z","updated":"2020-06-11T10:31:39.000Z","comments":true,"path":"Centos安装docker.html","link":"","permalink":"https://www.lauyongyi.cn/Centos%E5%AE%89%E8%A3%85docker.html","excerpt":"因为时不时会在服务器上安装新的东西，有时候会导致其他已正常运行的服务受到影响，为此开始研究docker的一些基本操作。希望能较不必要的环境维护。","text":"因为时不时会在服务器上安装新的东西，有时候会导致其他已正常运行的服务受到影响，为此开始研究docker的一些基本操作。希望能较不必要的环境维护。 安装步骤： 下载docker-ce的repo： curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo 安装依赖： yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm 安装docker-ce: yum install docker-ce 启动docker： systemctl start docker","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"}]},{"title":"Docker删除所有容器","slug":"Docker删除所有容器","date":"2020-05-23T10:17:00.000Z","updated":"2020-05-26T08:13:31.000Z","comments":true,"path":"Docker删除所有容器.html","link":"","permalink":"https://www.lauyongyi.cn/Docker%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8.html","excerpt":"docker删除容器前，需要先停止容器的运行","text":"docker删除容器前，需要先停止容器的运行 删除所有处于同一状态的容器可以使用docker ps -a状态定位容器并对其进行过滤：创建，重新启动，运行，暂停或退出。要查看已退出容器的列表，可使用-f参数根据状态进行过滤。当确认要删除这些容器时，使用-q参数将容器ID传递给docker rm命令；eg： 列出所有处于停止状态的容器列表 1docker ps -a -f status&#x3D;exited 删除所有处于停止状态的容器 1docker rm $(docker ps -a -f status&#x3D;exited -q) 批量删除其他状态的容器方法同理。 删除所有容器首先需要停止所有容器 1docker stop $(docker ps -a -q) 删除所有容器 1docker rm $(docker ps -a -q) 非root用户需要在前面加上管理员权限sudo否则会提示权限不足 12sudo docker ps -a -f status&#x3D;exitedsudo docker rm $(docker ps -a -f status&#x3D;exited -q) 12sudo docker stop $(sudo docker ps -a -q)sudo docker rm $(sudo docker ps -a -q)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"}]},{"title":"解决Ride中FAIL：Variable","slug":"解决Ride中FAIL：Variable","date":"2020-05-23T07:42:00.000Z","updated":"2020-05-27T06:50:16.000Z","comments":true,"path":"解决Ride中FAIL：Variable.html","link":"","permalink":"https://www.lauyongyi.cn/%E8%A7%A3%E5%86%B3Ride%E4%B8%ADFAIL%EF%BC%9AVariable.html","excerpt":"RIDE中FAIL：Variable","text":"RIDE中FAIL：Variable 1234567891011TestCase16$&#123;nums&#125; set Variable $&#123;5&#125;$&#123;number&#125; set Variable $&#123;1&#125;Run keywork If $&#123;nums&#125;&gt;10 Log nums ELSE If $&#123;ints&#125;&gt;0 Log numberELSE Log nums 错误如下： Error:FAIL：Variable ‘${ints}’not found 修改为：Run Keyword If 缩进就可以了 123456789$&#123;nums&#125; Set Variable $&#123;5&#125;$&#123;ints&#125; Set Variable $&#123;1&#125;Run Keyword If $&#123;nums&#125; &gt;10 Log numsELSE If $&#123;ints&#125; &gt;0 Log intsELSE Log nums","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"content和text方法的区别","slug":"content和text方法的区别","date":"2020-05-23T06:13:00.000Z","updated":"2020-05-23T06:18:34.000Z","comments":true,"path":"content和text方法的区别.html","link":"","permalink":"https://www.lauyongyi.cn/content%E5%92%8Ctext%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"使用requests进行网页请求时，对页面内容进行解码和编码的时候，需要用到.content和.text。","text":"使用requests进行网页请求时，对页面内容进行解码和编码的时候，需要用到.content和.text。 Requests对象的get和post方法都会返回一个Response对象，这个对象里面存的是服务器返回的所有信息，包括响应头，响应状态码等。其中返回的网页部分会存在.content和.text两个对象中。两者区别在于，content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是’，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。所以简而言之，.text是现成的字符串，.content还要编码，但是.text不是所有时候显示都正常，这是就需要用.content进行手动编码。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"Request","slug":"Request","permalink":"https://www.lauyongyi.cn/tags/Request/"}]},{"title":"adb logcat 根据Tag 过滤日志","slug":"根据Tag 过滤日志","date":"2020-05-22T09:17:00.000Z","updated":"2021-05-10T13:52:38.000Z","comments":true,"path":"根据Tag 过滤日志.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%A0%B9%E6%8D%AETag%20%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97.html","excerpt":"adb logcat根据tag获取需要指定标签（tag）和日志级别","text":"adb logcat根据tag获取需要指定标签（tag）和日志级别 adb logcat [TAG:LEVEL ] [TAG:LEVEL ] … LEVEL: 可以选择:[V D I W E S]中其中一个 TAG:X 的作用为: 输出标签为TAG的log级别大于X的信息. 例如: adb logcat Test:I 输出 Test的I 和I 级别以上的log,包括 i, w, e 注意: (1)可以指定多个[TAG:LEVEL ] (2) level : S 表示为不输出该标签的日志,应为没有大于S级别的日志了 (3) [TAG:LEVEL ] 不会影响其他标签的日志, 所以如果要屏蔽其他log请使用 *:S adb logcat Test:I *:S 例子： 1adb logcat xx:V aa:V bb:V ReportWeb:V vac:V reqm:V Em:V cccc:V dddd:V *:S","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"python 打开/关闭命令行窗口","slug":"python 打开关闭命令行窗口","date":"2020-05-22T08:14:00.000Z","updated":"2020-05-23T07:46:29.000Z","comments":true,"path":"python 打开关闭命令行窗口.html","link":"","permalink":"https://www.lauyongyi.cn/python%20%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3.html","excerpt":"用python编写多设备安装APP脚本时，有个场景，APP安装成功后，允许，实时打印日志和设备CPU占用信息，就找了下面的方法","text":"用python编写多设备安装APP脚本时，有个场景，APP安装成功后，允许，实时打印日志和设备CPU占用信息，就找了下面的方法 123456789101112131415161718import osdevices = [&#x27;OJHA7P9PZLRWUWBA&#x27;, &#x27;ZTEBV0710T&#x27;]def adbtop(): for i in devices: adb = &#x27;start cmd /k &quot;adb -s %s shell top -m 10&quot;&#x27; %(i) os.system(adb)def adbLogcat(): logTag = &#x27;vc:V vs:V Vm:V ReportWeb:V vac:V reqm:V Em:V VPReportManager:V VpAdControl:V *:S&#x27; for i in devices: adbs = &#x27;start cmd /k &quot;adb -s %s logcat %s&quot;&#x27; % (i, logTag) os.system(adbs)def cmdKill(self): adbs = &#x27;start cmd /k &quot;tskill adb &amp;&amp; tskill cmd&quot;&#x27; kill = os.system(adbs) return killif __name__ == &#x27;__main__&#x27;: adbtop() adbLogcat() devices 是设备号。通过adb devices 获得 cmd窗口关闭命令中的 tskill adb （一般情况下是 tskill cmd）因为使用了adb 进程，所以在任务管理器显示成了adb，就需要改为 tskill adb 来结束进程。tskill adb &amp;&amp; tskill cmd 的用法是：结束adb窗口的同时，关闭CMD窗口","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"使用RIDE遇到的几个问题","slug":"使用RIDE遇到的几个问题","date":"2020-04-23T08:34:00.000Z","updated":"2020-05-23T08:15:09.000Z","comments":true,"path":"使用RIDE遇到的几个问题.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%BD%BF%E7%94%A8RIDE%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98.html","excerpt":"学习RobotFramework 遇到的几个小问题","text":"学习RobotFramework 遇到的几个小问题 启动Ride： 报错信息：AttributeError:模块“sys”没有属性“maxint”python2中: 1random.randint(0,sys.maxint) pyhon3引入sys模块，输出sys.maxint,发现会报错：FAIL:Evaluating expression ‘random.randint(0,sys.maxint)’ failed: AttributeError: module ‘sys’ has no attribute ‘maxint’解决办法修改为: 1random.randint(0,sys.maxsize) 遇到报AttributeError:模块“string”没有属性“letters”python2是用： 1string.letters python3是用： 1string.ascii_letters 目前我用的是python3以上的版本：string.letters修改为string.ascii_letters就可以解决问题","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"}]},{"title":"解决monkey压测的问题java.lang.SecurityException","slug":"monkey压测可能出现的问题","date":"2020-04-15T08:29:00.000Z","updated":"2020-05-23T07:35:42.000Z","comments":true,"path":"monkey压测可能出现的问题.html","link":"","permalink":"https://www.lauyongyi.cn/monkey%E5%8E%8B%E6%B5%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"使用adb跑monkey时，出现报错：java.lang.SecurityException: Injecting to another application requires INJECT_EV ENTS permission","text":"使用adb跑monkey时，出现报错：java.lang.SecurityException: Injecting to another application requires INJECT_EV ENTS permission 原因：没有USB模拟的权限 解决办法：设置——更多设置-开发者选项—USB调试（安全设置）【允许通过USB调试修改权限或模拟点击】点击打开按钮，再次允许脚本，问题就解决了","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"Python中解决UnicodeDecodeError","slug":"Python中解决UnicodeDecodeError","date":"2020-04-08T14:32:00.000Z","updated":"2020-05-23T07:50:13.000Z","comments":true,"path":"Python中解决UnicodeDecodeError.html","link":"","permalink":"https://www.lauyongyi.cn/Python%E4%B8%AD%E8%A7%A3%E5%86%B3UnicodeDecodeError.html","excerpt":"pycharm中打开文件需要使用open，遇到报错。","text":"pycharm中打开文件需要使用open，遇到报错。 代码如下： 123import os file = open(&quot;exercise01.py&quot;) print(file.read()) 此时会报错：UnicodeDecodeError: ‘gbk’ codec can’t decode byte……….处理方式是， 在open函数中加入文件读写模式的说明，其中二进制文件需要用“rb”读写，故将第二行代码改为 1file = open(&quot;exercise01.py&quot;, &quot;rb&quot;) 即可读出文件。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"模拟其它浏览器，包括移动浏览器","slug":"模拟其不同的浏览器","date":"2020-03-27T10:53:00.000Z","updated":"2020-05-23T07:22:46.000Z","comments":true,"path":"模拟其不同的浏览器.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%A8%A1%E6%8B%9F%E5%85%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8.html","excerpt":"测试Web页面兼容性的时候，总是要模拟不同的设备页面，本文主要是记录常用的设备模拟功能","text":"测试Web页面兼容性的时候，总是要模拟不同的设备页面，本文主要是记录常用的设备模拟功能 1、打开浏览器，使用F12，调出开发者调试工具，然后点击图下所示的选择设定 more tools （更多工具）- network condition （网络状态）2、Chrome浏览器修改 UA 模拟其它浏览器，见下图然后看到有个 user agent 去掉 select automatically （自动选择）就可以选择各种浏览器了，包括移动端，然后可以愉快的模拟了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}]},{"title":"adb shell top命令解析","slug":"adb shell top命令解析","date":"2020-03-26T02:42:00.000Z","updated":"2021-05-11T15:42:49.000Z","comments":true,"path":"adb shell top命令解析.html","link":"","permalink":"https://www.lauyongyi.cn/adb%20shell%20top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90.html","excerpt":"top命令提供了实时系统处理器的状态监视，它将显示系统中的任务列表，该命令可以按CPU使用&gt;内存使用和执行时间对任务进行排序。","text":"top命令提供了实时系统处理器的状态监视，它将显示系统中的任务列表，该命令可以按CPU使用&gt;内存使用和执行时间对任务进行排序。 top 用法 adb shell top --help Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [-t ] [ -h ] -m num Maximum number of processes to display. 最多显示多少个进程 -n num Updates to show before exiting. 刷新次数 -d num Seconds to wait between updates. 刷新间隔时间（默认5秒） -s col Column to sort by (cpu,vss,rss,thr). 按哪列排序 -t Show threads instead of processes. 显示线程信息而不是进程 -h Display this help screen. 显示帮助文档 返回信息解释：Android N（7.1系统，level = 25） 及之前12345678910111213141516171819202122232425262728User 5%, System 7%, IOW 0%, IRQ 0%User 67 + Nice 2 + Sys 87 + Idle 1005 + IOW 1 + IRQ 0 + SIRQ 0 &#x3D; 1162PID PR CPU% S # THR VSS RSS PCY UID Name3543 0 6% S 7 12728K 3740K bg logd &#x2F;system&#x2F;bin&#x2F;logd第一组数据的含义：- User 处于用户态的运行时间，不包含优先值为负进程- Nice 优先值为负的进程所占用的CPU时间- Sys 处于核心态的运行时间- Idle 除IO等待时间以外的其它等待时间- IOW IO等待时间- IRQ 硬中断时间- SIRQ 软中断时间第二组数据的含义：- PID 进程id- PR 优先级- CPU% 当前瞬时CPU占用率- S 进程状态:D&#x3D;不可中断的睡眠状态, R&#x3D;运行, S&#x3D;睡眠, T&#x3D;跟踪&#x2F;停止, Z&#x3D;僵尸进程- THR 程序当前所用的线程数- VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）- RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存）- PCY 调度策略优先级，SP_BACKGROUND&#x2F;SP_FOREGROUND- UID 进程所有者的用户id- Name 进程的名称 Android O（8.0系统，level = 26） 及之后:123456Tasks: 558 total, 1 running, 553 sleeping, 0 stopped, 1 zombie任务(进程) 系统现在共有558个进程，其中处于运行中的有1个，553个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。Mem: 5846936k total, 4524412k used, 1322524k free, 99464k buffers内存状态: 物理内存总量 (5.6G) 使用中的内存总量 空闲内存总量 缓存的内存量Swap: 2621436k total, 338868k used, 2282568k free, 2248048k cachedswap交换分区: 交换区总量 使用的交换区总量 空闲交换区总量 缓冲的交换区总量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546400%cpu 2%user 0%nice 4%sys 394%idle 0%iow 0%irq 0%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS23541 shell 20 0 10M 2.7M 1.4M R 4.6 0.0 0:31.89 top18117 root 20 0 0 0 0 S 0.6 0.0 0:06.88 [kworker&#x2F;u8:24]17638 root 20 0 0 0 0 S 0.6 0.0 0:01.00 [kworker&#x2F;1:0]22118 root 20 0 0 0 0 S 0.3 0.0 0:01.11 [kworker&#x2F;0:4]17910 root 20 0 0 0 0 S 0.3 0.0 0:05.94 [kworker&#x2F;u8:2] 2679 shell 20 0 15M 748K 580K S 0.3 0.0 0:19.43 adbd --root_sec+ 330 root RT 0 0 0 0 S 0.3 0.0 74:10.28 [cfinteractive] 20 root 20 0 0 0 0 S 0.3 0.0 5:24.44 [ksoftirqd&#x2F;3]23707 root 20 0 0 0 0 S 0.0 0.0 0:00.00 [kworker&#x2F;1:2]cpu状态 400%cpu -- CPU总量8%user -- 用户空间占用CPU的百分比。0%nice -- 改变过优先级的进程占用CPU的百分比41%sys -- 内核空间占用CPU的百分比394%idle -- 空闲CPU百分比0%iow -- IO等待占用CPU的百分比0%irq -- 硬中断（Hardware IRQ）占用CPU的百分比0%sirq -- 软中断（Software Interrupts）占用CPU的百分比0%host -- PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量(virtual memory usage)，单位kb。VIRT&#x3D;SWAP+RES 1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等 2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量RES — resident memory usage 常驻内存，单位kb。RES&#x3D;CODE+DATA 1、进程当前使用的内存大小，但不包括swap out 2、包含其他进程的共享 3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反 4、关于库占用内存的情况，它只统计加载的库文件所占内存大小SHR — 共享内存(shared memory)，单位kb 1、除了自身进程的共享内存，也包括其他进程的共享内存 2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小 3、计算某个进程所占的物理内存大小公式：RES – SHR 4、swap out后，它将会降下来S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒ARGS — 进程名称（命令名&#x2F;命令行） 常用的命令是：adb shell top -m 10adb shell top -t -m 10 查看设备cpu和内存占用情况：adb shell top 查看前N个进程：adb shell top -m 10/adb shell top -m 10 -t -d 10 打印每个进程使用CPU详情输出至cpu.txt：adb shell top &gt; CPU.txt 要监测单个应用，例如针对单一应用的CPU占用率~ 监测一次的CPU占用情况：adb shell top -n 1 | grep 包名 10秒刷新一次显示CPU占用情况：adb shell top -d 10 | grep 包名 实时监测指定包的CPU占用情况：adb shell top |grep 包名","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"adb 常用命令","slug":"adb 常用命令","date":"2020-03-24T07:37:00.000Z","updated":"2021-12-15T13:30:00.000Z","comments":true,"path":"adb 常用命令.html","link":"","permalink":"https://www.lauyongyi.cn/adb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"adb是什么?adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse/Android studio中通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse/Android studio时adb进程就会自动运行。 adb有什么用?借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作!","text":"adb是什么?adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse/Android studio中通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse/Android studio时adb进程就会自动运行。 adb有什么用?借助adb工具，我们可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作! 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（Android11 及以上）Android 11 及更高版本支持使用 Android 调试桥 (adb) 从工作站以无线方式部署和调试应用。例如，您可以将可调试应用部署到多台远程设备，而无需通过 USB 实际连接设备。这样就可以避免常见的 USB 连接问题，例如驱动程序安装方面的问题。 官方文档 操作步骤： 更新到最新版本的 SDK 平台工具(至少30.0.0)。 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 在开发者选项中启用无线调试。 在询问要允许在此网络上进行无线调试吗？的对话框中，点击允许。 选择使用配对码配对设备，使用弹窗中的 IP 地址和端口号。 1adb pair ipaddr:port 提示Enter pairing code: 时输入弹窗中的配对码，成功后会显示Successfully paired to ...。 使用无线调试下的 IP 地址和端口。 1adb connect ipaddr:port 确认连接状态。 1adb devices 如果能看到 1ipaddr:port device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 –abi abi-identifier 为特定 ABI 强制安装 apk，abi-identifier 可以是 armeabi-v7a、arm64-v8a、v86、x86_64 等 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mResumedActivity 输出示例： 1mResumedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125; 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 在 Windows 下以上命令可能不可用，可以尝试 adb shell dumpsys activity activities | findstr mResumedActivity 或 adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: &quot;android.intent.action.MAIN&quot; Category: &quot;android.intent.category.LAUNCHER&quot; AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125; applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125; codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125; flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125; installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:&#x2F;data&#x2F;app&#x2F;ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es ` --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity 指定Activity名称启动 命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot; 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 不指定Activity名称启动（启动主Activity） 命令格式： 1adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1 例如： 1adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1 表示调起微信主界面。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令： 1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 &#x27;........8.6.0.9.&#x27; 0x00000010: 00350035 00320030 00370037 00350038 &#x27;5.5.0.2.7.7.8.5.&#x27; 0x00000020: 00340030 00000031 &#x27;0.4.1... &#x27;) 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed &quot;s/\\r$//&quot; &gt; sc.png Mac OS X 1adb shell screencap -p | gsed &quot;s/\\r$//&quot; &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network=&#123; ssid=&quot;TP-LINK_9DFC&quot; scan_ssid=1 psk=&quot;123456789&quot; key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893&#125;network=&#123; ssid=&quot;TP-LINK_F11E&quot; psk=&quot;987654321&quot; key_mgmt=WPA-PSK sim_num=1 priority=17293&#125; ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 如果 Android O 或以后，WiFi 密码保存的地址有变化，是在 WifiConfigStore.xml 里面 123adb shellsucat /data/misc/wifi/WifiConfigStore.xml 输出格式： 数据项较多，只需关注 ConfigKey（WiFi 名字）和 PreSharedKey（WiFi 密码）即可 12&lt;string name=&quot;ConfigKey&quot;&gt;&amp;quot;Wi-Fi&amp;quot;WPA_PSK&lt;/string&gt;&lt;string name=&quot;PreSharedKey&quot;&gt;&amp;quot;931907334&amp;quot;&lt;/string&gt; 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn&#x27;t read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server&#39;s $ADB_VENDOR_KEYS is not setTry &#39;adb kill-server&#39; if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"python通过setup.py安装模块","slug":"python通过setup.py安装模块","date":"2020-03-12T08:00:00.000Z","updated":"2020-05-25T08:03:24.000Z","comments":true,"path":"python通过setup.py安装模块.html","link":"","permalink":"https://www.lauyongyi.cn/python%E9%80%9A%E8%BF%87setup.py%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97.html","excerpt":"python有些插件需要通过编译，才能安装，具体方法如下","text":"python有些插件需要通过编译，才能安装，具体方法如下 步骤: 使用命令行工具，到达安装目录（下载完成的目录） 执行以下命令： 12python setup.py build (构建编译）python setup.py install （安装） Windows平台在执行install的时候，需要使用管理员权限的命令行或者管理员权限的PowerShell。","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"}]},{"title":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示","slug":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示","date":"2020-03-10T03:34:00.000Z","updated":"2020-05-23T06:37:20.000Z","comments":true,"path":"安卓手机彻底关闭“已登录到Wlan网络”或者“登录到网络”的提示.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%AD%E2%80%9C%E5%B7%B2%E7%99%BB%E5%BD%95%E5%88%B0Wlan%E7%BD%91%E7%BB%9C%E2%80%9D%E6%88%96%E8%80%85%E2%80%9C%E7%99%BB%E5%BD%95%E5%88%B0%E7%BD%91%E7%BB%9C%E2%80%9D%E7%9A%84%E6%8F%90%E7%A4%BA.html","excerpt":"部分安卓手机会出现“登录wlan的提示”，在设置内无法关闭，只能通过ADB命令关闭","text":"部分安卓手机会出现“登录wlan的提示”，在设置内无法关闭，只能通过ADB命令关闭 命令如下： 123adb devices &#x2F;&#x2F;多设备情况下，需要查看设备名称，单一设备可以不输入，也可用来检查设备链接是否正常adb shell &#x2F;&#x2F;单一设备。多设备要使用 adb -s deviceName&#x2F;IP shellsettings put global captive_portal_detection_enabled 0","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"scrapy 基本命令","slug":"scrapy 基本命令","date":"2020-03-06T07:08:00.000Z","updated":"2020-05-23T08:09:47.000Z","comments":true,"path":"scrapy 基本命令.html","link":"","permalink":"https://www.lauyongyi.cn/scrapy%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html","excerpt":"记录一下scrapy常用命令。","text":"记录一下scrapy常用命令。 创建项目： scrapy startproject xxxx（项目名） 创建起始页面: scrapy genspider xxx(爬虫名）”url” 爬虫检查： scrapy check 爬虫列表： scrapy list 调试： scrapy shell //用于快速调试正则或者链接是否正确等 scrapy debug调试/已经快速运行的方法: 在爬虫根目录新建一个 main.py 12from scrapy import cmdline&lt;cmdline.execute(&#x27;scrapy crawl xxx(爬虫名)&#x27;.split())","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"adb 抓取指定包的日志（.bat方式）","slug":"adb logcat通过包名过滤（dos命令find后跟变量)","date":"2020-03-06T02:19:00.000Z","updated":"2020-05-23T07:46:12.000Z","comments":true,"path":"adb logcat通过包名过滤（dos命令find后跟变量).html","link":"","permalink":"https://www.lauyongyi.cn/adb%20logcat%E9%80%9A%E8%BF%87%E5%8C%85%E5%90%8D%E8%BF%87%E6%BB%A4%EF%BC%88dos%E5%91%BD%E4%BB%A4find%E5%90%8E%E8%B7%9F%E5%8F%98%E9%87%8F).html","excerpt":"在测试SDK的时候，遇到需要查看指定APP的日志情况（公司设备有点落后，跑AS容易卡死），就找了以下方法进行查看","text":"在测试SDK的时候，遇到需要查看指定APP的日志情况（公司设备有点落后，跑AS容易卡死），就找了以下方法进行查看 通过过滤进程的pid来过滤该应用的日志过滤条件：该app在运行实现原理： ​ 获取该app运行时的pid ​ 通过find命令，过滤pid的日志，就是该包的运行日志 实现： 1、在同一目录建立一文件：getpid.bat，输入以下代码 12@echo offadb shell &quot;ps | grep com.example.testprogram&quot; 2、在同一目录建立另外一个问文件：getpid1.bat 12345@echo offfor &#x2F;f &quot;tokens&#x3D;2 delims&#x3D; &quot; %%i in (&#39;getpid.bat&#39;) do set pid&#x3D;%%iecho %pid%adb logcat | find &quot;%pid%&quot;pause 链接手机，启动com.example.testprogram这个app 双击getpid1.bat即可获取该程序的日志： 123456789101112131415161718192021222324252627282930D&#x2F;dalvikvm( 9017): Late-enabling CheckJNII&#x2F;ActivityManager( 2272): Start proc com.example.testprogram for activity com.example.testprogram&#x2F;.MainActivity: pid&#x3D;9017 uid&#x3D;10070 gids&#x3D;&#123;50070, 1028&#125;D&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libEGL_mali.soD&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libGLESv1_CM_mali.soD&#x2F;libEGL ( 9017): loaded &#x2F;system&#x2F;lib&#x2F;egl&#x2F;libGLESv2_mali.soE&#x2F; ( 9017): Device driver API matchE&#x2F; ( 9017): Device driver API version: 17E&#x2F; ( 9017): User space API version: 17E&#x2F; ( 9017): mali: REVISION&#x3D;Linux-r3p1-01rel1 BUILD_DATE&#x3D;Tue Jul 2 15:06:24 KST 2013D&#x2F;OpenGLRenderer( 9017): Enabling debug mode 0D&#x2F;tag ( 9017): it&#39;s a log !D&#x2F;AndroidRuntime( 9017): Shutting down VMW&#x2F;dalvikvm( 9017): threadid&#x3D;1: thread exiting with uncaught exception (group&#x3D;0x418dc700)E&#x2F;AndroidRuntime( 9017): FATAL EXCEPTION: mainE&#x2F;AndroidRuntime( 9017): java.lang.ArithmeticException: divide by zeroE&#x2F;AndroidRuntime( 9017): at com.example.testprogram.MainActivity$2.onClick(MainActivity.java:33)E&#x2F;AndroidRuntime( 9017): at android.view.View.performClick(View.java:4247)E&#x2F;AndroidRuntime( 9017): at android.view.View$PerformClick.run(View.java:17728)E&#x2F;AndroidRuntime( 9017): at android.os.Handler.handleCallback(Handler.java:730)E&#x2F;AndroidRuntime( 9017): at android.os.Handler.dispatchMessage(Handler.java:92)E&#x2F;AndroidRuntime( 9017): at android.os.Looper.loop(Looper.java:137)E&#x2F;AndroidRuntime( 9017): at android.app.ActivityThread.main(ActivityThread.java:5289)E&#x2F;AndroidRuntime( 9017): at java.lang.reflect.Method.invokeNative(Native Method)E&#x2F;AndroidRuntime( 9017): at java.lang.reflect.Method.invoke(Method.java:525)E&#x2F;AndroidRuntime( 9017): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739)E&#x2F;AndroidRuntime( 9017): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:555)E&#x2F;AndroidRuntime( 9017): at dalvik.system.NativeStart.main(Native Method)I&#x2F;Process ( 9017): Sending signal. PID: 9017 SIG: 9I&#x2F;ActivityManager( 2272): Process com.example.testprogram (pid 9017) has died.W&#x2F;InputMethodManagerService( 2272): Got RemoteException sending setActive(false) notification to pid 9017 uid 10070","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"}]},{"title":"浏览器toast定位","slug":"浏览器toast定位","date":"2020-02-21T08:49:00.000Z","updated":"2020-05-23T06:38:19.000Z","comments":true,"path":"浏览器toast定位.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%B5%8F%E8%A7%88%E5%99%A8toast%E5%AE%9A%E4%BD%8D.html","excerpt":"在浏览器打开需要捕捉toast的页面，","text":"在浏览器打开需要捕捉toast的页面， 打开开发者工具（F12）切换到“Sources”分栏，触发toast，在 toast出现后立刻暂停，然后再去定位","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]},{"title":"爬虫遇到的问题与解","slug":"爬虫遇到的问题与解","date":"2019-10-20T15:00:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"爬虫遇到的问题与解.html","link":"","permalink":"https://www.lauyongyi.cn/%E7%88%AC%E8%99%AB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3.html","excerpt":"学习爬虫过程中遇到的一些问题","text":"学习爬虫过程中遇到的一些问题 requests的content和text方法的区别Requests对象的get和post方法都会返回一个Response对象，这个对象里面存的是服务器返回的所有信息，包括响应头，响应状态码等。其中返回的网页部分会存在.content和.text两个对象中。两者区别在于，content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是’，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。所以简而言之，.text是现成的字符串，.content还要编码，但是.text不是所有时候显示都正常，这是就需要用.content进行手动编码。 re.findall提示类型不匹配的问题外层找到后，下一步引用需要加上 str 进行转码，才不会报错 例子： 1toc_block=re.findall(&#x27;&lt;h2&gt;盗墓笔记(.*?)&lt;/div&gt;&#x27;,html,re.S) #需要转成str，否则会报类型错误的问题 1toc_url=re.findall(&#x27;href=&quot;(.*?)&quot;&#x27;,str(toc_block),re.S) 关于异步加载复杂json的解析多层json，解析后，可以用re.findall查找元素","categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"selenium模拟用户鼠标操作","slug":"selenium模拟用户鼠标操作","date":"2019-09-03T12:10:00.000Z","updated":"2019-09-03T12:28:38.000Z","comments":true,"path":"selenium模拟用户鼠标操作.html","link":"","permalink":"https://www.lauyongyi.cn/selenium%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C.html","excerpt":"在写selenium自动化脚本的时候，常常会遇到下拉菜单，这时候多半需要使用模拟事件来处理","text":"在写selenium自动化脚本的时候，常常会遇到下拉菜单，这时候多半需要使用模拟事件来处理 鼠标操作由selenium 的ActionChains类来完成模拟鼠标操作 主要操作流程：1、存储鼠标操作2、perform()来执行鼠标操作支持的操作如下：click 单击double_click 双击操作context_click 右键操作drag_and_drag 拖拽操作，左键按住拖动某一个元素到另外一个区域，然后释放按键move_to_element() -鼠标悬停，以后会经常遇到实例代码: ActionChains(driver).move_to_element(&#39;元素&#39;).perform()","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"selenium等待类型","slug":"selenium等待类型","date":"2019-09-01T06:16:00.000Z","updated":"2019-09-01T06:28:38.000Z","comments":true,"path":"selenium等待类型.html","link":"","permalink":"https://www.lauyongyi.cn/selenium%E7%AD%89%E5%BE%85%E7%B1%BB%E5%9E%8B.html","excerpt":"编写自动化脚本的时候，经常会出现定位不到元素或者元素为空的不稳定现象，这个时候，就需要在脚本中加入等待功能。","text":"编写自动化脚本的时候，经常会出现定位不到元素或者元素为空的不稳定现象，这个时候，就需要在脚本中加入等待功能。 在实际工作中等待机制可以保证代码的稳定性,从而代码不会因为网速、电脑性能等条件的约束而影响运行结果。等待就是当运行代码时,页面的渲染速度跟不上代码的运行速度时,就需要人为的去限制代码执行的速度,这就是等待。在做web自动化时,一般要等待页面元素加载完成后,才能执行操作,否则会报找不到元素等各种错误,这样就要求我们在有些场景下加等待时间。最常见的有三种等待方式: 隐式等待 显式等待 强制等待 隐式等待 ​ 设置一个等待时间,轮询查找(默认0.5秒)元素是否出现,如果没出现就抛出异常。这也是最常见的等待方法。 隐式等待的作用是全局的。 self.driver. implicitly_wait(30) 显式等待 ​ 显式等待是你在代码中定义等待一定条件发生后再进一步执行你的代码。WebDriverWait配合该类的 until和 untilnot方法,就能够根据判断条件进行等待。程序每隔一段时间(默认为0.5秒)进行条件判断,如果条件成立,则执行下一步,否则继续等待,直到超过设置的最长时间。当隐式等待不起作用时,就会用到显式等待。 123456from selenium. webdriver. support. wait import WebDriverWaitfrom selenium. webdriver. support import expected_conditionsWebDriverWait(driver, 10).until( expected_conditions.element_to_be_clickable(By.TAG_NAME,&quot;title&quot;)) 强制等待 ​ 线程休眠一定时间。强制等待一般在隐式等待和显示等待都不起作用时使用 12import timetime.sleep(10)","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"}]},{"title":"服务器+域名部署Hexo","slug":"服务器+域名部署Hexo","date":"2018-12-26T14:40:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"服务器+域名部署Hexo.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8+%E5%9F%9F%E5%90%8D%E9%83%A8%E7%BD%B2Hexo.html","excerpt":"​ 这是本站采用的建站教程","text":"​ 这是本站采用的建站教程 服务器操作部分在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置创建文件目录(用于博客站点文件存放) 123cd &#x2F;usr&#x2F;local&#x2F;mkdir hexochmod 775 -R &#x2F;usr&#x2F;local&#x2F;hexo&#x2F; 添加 index.html(用于检测配置 Nginx 是否成功) 1vim &#x2F;usr&#x2F;local&#x2F;hexo&#x2F;index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;&#x2F;p&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 配置 Nginx 服务器 1vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root &#x2F;usr&#x2F;local&#x2F;hexo&#x2F;; &#125; 启动nginx服务； 12centos 6 启动命令：service nginx startcentos 7 启动命令：systemctl start nginx 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd &#x2F;usr&#x2F;local&#x2F;mkdir hexoRepochmod 775 -R &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F; Git 初始化裸库。 12cd hexoRepo&#x2F;git init --bare hexo.git 创建 Git 钩子(hook)。 1vim &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!&#x2F;bin&#x2F;bashgit --work-tree&#x3D;&#x2F;usr&#x2F;local&#x2F;hexo --git-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git checkout -f 保存并退出后, 给该文件添加可执行权限。 1chmod +x &#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive 本地操作部分安装hexo-deployer-git插件在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo &#x2F;&#x2F;用户名@域名或 IP 地址:&#x2F;usr&#x2F;local&#x2F;hexoRepo&#x2F;hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 推送到GithubPages在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g #编译$ hexo d #部署到服务器 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。","categories":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}]},{"title":"网站分享","slug":"网站分享","date":"2018-12-22T14:30:00.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"网站分享.html","link":"","permalink":"https://www.lauyongyi.cn/%E7%BD%91%E7%AB%99%E5%88%86%E4%BA%AB.html","excerpt":"个人收藏，常用的网站,持续更新","text":"个人收藏，常用的网站,持续更新 视频茶泡饭 一个免费的视频分享下载网站 CK影视 快播时代残存下载的在线视频播放网站，新的资源基本都可以在线播放。 部分老旧资源需要按照要求下载绿色版的快播才能正常观看 图片wallhaven WallBase创办人失联后，前成员推出的网站。 一个很“强大”图片网站，具体强大到什么地步，还得自己慢慢探索 （我的电脑壁纸基本都来自这个网站） Windows资源下载msdn.itellyou 微软资源下载首推的网站，谁用谁知道","categories":[{"name":"分享","slug":"分享","permalink":"https://www.lauyongyi.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://www.lauyongyi.cn/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"SQL常用语句","slug":"SQL基础语句","date":"2018-12-13T10:47:00.000Z","updated":"2020-10-16T03:50:30.000Z","comments":true,"path":"SQL基础语句.html","link":"","permalink":"https://www.lauyongyi.cn/SQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5.html","excerpt":"记录工作中较常用的SQL语句。","text":"记录工作中较常用的SQL语句。 1、查看数据库:：SHOW databases;。2、选择数据库：USE database_name。3、表定义信息：DESCRIBE table_name。4、插入数据：INSERT INFO table_name (field_1...field_n) VALUES (value_1...value_n);。5、更新数据：UPDATE table_name SET field_1=value_1…field_n=value_n WHERE CONDITION;。6、删除记录：DELETE FROM table_name WHERECONDITION;。7、单表数据查询。 1）单表数据查询的基本语句：SELECT field_1,field_n FROM table_name;。 2）避免重复：SELECT DISTINCT field_1, field_n FROM table_name;。 3）排序查询：SELECT field_1, field_n FROM table_name WHERE CONDITION ORDER BY field_name [ASC|DESC];。 4）限制数据记录查询数量：SELECT field_1,field_n FROM table_name WHERE CONDITION LIMIT OFFSET_START,ROW_COUNT;。 5）统计数值列总和：SELECT SUM（field_name）FROM table_name;。 6）统计制定列的值的数目：SELECT COUNT（field_name）FROM table_name;。 7）根据列表查询：SELECT field_1, field_n FROM table_name WHERE field_1 IN (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);。 8）范围查询：SELECT field_1, field_n FROM table_name WHERE field_n BETWEEN value_1 AND value_2;。 9）分组查询：SELECT * FROM table_name WHERE field_1 LIKE &#39;%&#39; GROUP BY field_1 LIMIT 10;。 10）多条件查询：SELECT column1, columnN FROM table_name WHERE CONDITION-1 &#123;AND|OR&#125; CONDITION-2; 8、多表查询。 1）SELECT 字段1,字段2,字段3,…… FROM 表名1,表名2 WHERE 关联条件&#39;;。等同于SELECT 字段1,字段2,字段3,…… FROM 表名1 INNER JOIN 表名2 ON 关联条件;。 2）左连接查询：SELECT 字段1,字段2,字段3,…… FROM 表名1 LEFT JOIN 表名2 ON 关联条件;。 3）右连接查询：SELECT 字段1,字段2,字段3,…… FROM 表名1 RIGHT JOIN 表名2 ON 关联条件;。 4）自动删除重复行：SELECT语句1 UNION SELECT语句2;。 5）保留重复行（不自动排序）：SELECT语句1 UNION ALL SELECT语句2;。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]},{"title":"安卓App与iOSApp和Web测试的区别","slug":"安卓App与iOSApp和Web测试的区别","date":"2018-11-24T12:37:00.000Z","updated":"2018-11-27T06:42:21.000Z","comments":true,"path":"安卓App与iOSApp和Web测试的区别.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93App%E4%B8%8EiOSApp%E5%92%8CWeb%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"关于安卓App与iOSApp和Web测试的区别，经常会被人问起，然后就整理了一下","text":"关于安卓App与iOSApp和Web测试的区别，经常会被人问起，然后就整理了一下 WEB 测试和 App 测试从流程上来说，没有区别。 都需要经历测试计划方案，用例设计，测试执行，缺陷管理，测试报告等相关活动。 从技术上来说，WEB 测试和 APP 测试其测试类型也基本相似，都需要进行功能测 试、性能测试、安全性测试、GUI 测试等测试类型。 他们的主要区别在于具体测试的细节和方法有区别，比如：性能测试，在 WEB 测试只需要测试响应时间这个要素，在 App 测试中还需要考虑流量测试和耗电量测试。 ​ 兼容性测试：在 WEB 端是兼容浏览器，在 App 端兼容的是手机设备。而且相对应 的兼容性测试工具也不相 同，WEB 因为是测试兼容浏览器，所以需要使用不同 的浏览器进行兼容性测试（常见的是兼容 IE6，IE8，chrome，firefox）如果是 手机端， 那么就需要兼容不同品牌，不同分辨率，不同 android 版本甚至不同 操作系统的兼容。（常见的兼容方式是兼容市场占用率前 N 位的手机即可），有时候也可以使用到兼容性测试工具，但 WEB 兼容性工具多用 IETester 等工具， 而 App 兼容性测试会使用 Testin 这样的商业工具也可以做测试。 ​ 安装测试：WEB 测试基本上没有客户端层面的安装测试，但是 App 测试是存在客 户端层面的安装测试，那么就具备相关的测试点。 还有App测试基于手机设备，还有一些手机设备的专项测试。如交叉事件测试， 操作类型测试，网络测试（弱网测试，网络切换） ​ 交叉事件测试：就是在操作某个软件的时候，来电话、来短信，电量不足提示等 外部事件。 ​ 操作类型测试：如横屏测试，手势测试 ​ 网络测试：包含弱网和网络切换测试。需要测试弱网所造成的用户体验，重点要考虑回退和刷新是否会造成二次提交。弱网络的模拟，可以用fiddler等实现。 ​ 从系统架构的层面，WEB 测试只要更新了服务器端，客户端就会同步会更新。而 且客户端是可以保证每一个用户的客户端完全一致的。但是 APP 端是不能 够保 证完全一致的，除非用户更新客户端。如果是 APP 下修改了服务器端，意味着客 户端用户所使用的核心版本都需要进行回归测试一遍。 ​ 还有升级测试：升级测试的提醒机制，升级取消是否会影响原有功能的使用，升级后用户数据是否被清除了。 android 和 ios 测试区别 Android 长按 home 键呼出应用列表和切换应用，然后右滑则终止应用；目前都是基于全屏手势，更多的是关注不同的手势操作会带来什么样的响应事件 多分辨率测试，Android 端 不同厂商不同型号的，屏幕参数众多，需要选取有代表的进行测试。可以参考类似腾讯移动分析，ios 较少； 手机操作系统，Android 较多，ios 较少且不能降级，只能单向升级；新的 ios 系统中的资源库不能完全兼容低版本中的 ios 系统中的应用，低版本 ios 系统中 的应用调用了新的资源库，会直接导致闪退（Crash）； 操作习惯：Android虚拟导航键是否被重写（例如：单击返回，长按回到主页面），测试点击后的反馈是否正确；应用数据从内存移动到 SD 卡后能否正常运行等； push 测试：Android：点击 home 键，程序后台运行时，此时接收到 push，点 击后唤醒应用，此时是否可以正确跳转；ios，点击 home 键关闭程序和屏幕锁屏 的情况（红点的显示）； 安装卸载测试：Android 的下载和安装的平台和工具和渠道比较多，ios 主要 有 app store，iTunes 和 testflight 下载； 升级测试：可以被升级的必要条件：新旧版本具有相同的签名；新旧版本具有 相同的包名；有一个标示符区分新旧版本（如版本号）， 对于 Android 若有内置的应用需检查升级之后内置文件是否匹配（如内置的输入 法） 另外：对于测试还需要注意一下几点： 并发（中断）测试：闹铃弹出框提示，另一个应用的启动、视频音频的播放， 来电、用户正在输入等，语音、录音等的播放时强制其他正在播放的要暂停； 数据来源的测试：输入，选择、复制、语音输入，安装不同输入法输入等； push（推送）测试：在开关机、待机状态下执行推送，消息先死及其推送跳转 的正确性； 应用在开发、未打开状态、应用启动且在后台运行的情况下是 push 显示和跳转 否正确； 推送消息阅读前后数字的变化是否正确； 多条推送的合集的显示和跳转是否正确； 分享跳转：分享后的文案是否正确；分享后跳转是否正确，显示的消息来源是 否正确； 触屏测试：同时触摸不同的位置或者同时进行不同操作，查看客户端的处理情 况，是否会 crash 等","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"一个APP的组成","slug":"app相关的知识","date":"2018-11-24T07:37:00.000Z","updated":"2018-11-27T06:42:21.000Z","comments":true,"path":"app相关的知识.html","link":"","permalink":"https://www.lauyongyi.cn/app%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86.html","excerpt":"为了方便测试工作的展开，收集的一些APP相关基础知识和测试关注的点","text":"为了方便测试工作的展开，收集的一些APP相关基础知识和测试关注的点 Android 四大组件Android 四大基本组件：Activity、BroadcastReceiver 广播接收器、 ContentProvider 内容提供者、Service 服务。 Activity: 应用程序中，一个 Activity 就相当于手机屏幕，它是一种可以包含用户界面的 组件，主要用于和用户进行交互。一个应用程序可以包含许多活动，比如事件的 点击，一般都会触发一个新的 Activity。 BroadcastReceiver 广播接收器： 应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时， 或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然 而， 它们可以启动一个 activity 或 serice 来响应它们收到的信息，或者用 NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力 ──闪动背灯、震动、播放声音 等。一般来说是在状态栏上放一个持久的图标， 用户可以打开它并获取消息。 ContentProvider 内容提供者: 内容提供者主要用于在不同应用程序之间实现数据共享的功能，它提供了一套完 整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据 的 安全性。只有需要在多个应用程序间共享数据时才需要内容提供者。例如：通讯 录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处：统一 数 据访问方式。 Service 服务： 是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用 户交互而且还要长期运行的任务（一边打电话，后台挂着 QQ）。服务 的运行不 依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另一个应用程序， 服务扔然能够保持正常运行，不过服务并不是运行在一个独立的进程当 中，而 是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉后，所有 依赖于该进程的服务也会停止运行（正在听音乐，然后把音乐程序退出）。 ActivityActivity 是 Android 的四大组件之一，也是平时我们用到最多的一个组件，可 以用来显示 View。Activity 是一个 Android 的应用组件，它提供屏幕进行交互。每个 Activity 都 会获得一个用于绘制其用户界面的窗口，窗口可以充满哦屏幕也可以小于屏幕并 浮动在其他窗口之上。 一个应用通常是由多个彼此松散联系的 Activity 组成，一般会指定应用中的某 个 Activity 为主活动，也就是说首次启动应用时给用户呈现的 Activity。将 Activity 设为主活动的方法 当然 Activity 之间可以进行互相跳转，以便执行不同的操作。每当新 Activity 启动时，旧的 Activity 便会停止，但是系统会在堆栈也就是返回栈中保留该 Activity。 当新 Activity 启动时，系统也会将其推送到返回栈上，并取得用户的操作焦点。 当用户完成当前 Activity 并按返回按钮是，系统就会从堆栈将其弹出销毁，然 后回复前一 Activity 当一个 Activity 因某个新 Activity 启动而停止时，系统会通过该 Activity 的 生命周期回调方法通知其这一状态的变化。 Activity 因状态变化每个变化可能有若干种，每一种回调都会提供执行与该状 态相应的特定操作的机会。 Activity 生命周期1.运行（Active/Running）:Activity 处于活动状态，此时 Activity 处于栈顶， 是可见状态，可以与用户进行交互 2.暂停（Paused）:当 Activity 失去焦点时，或被一个新的非全面屏的 Activity， 或被一个 透明的 Activity 放置在栈顶时，Activity 就转化为 Paused 状态。此 刻并不会被销毁，只是失去了与用户交互的能力，其所有的状态信息及其 成员 变量都还在，只有在系统内存紧张的情况下，才有可能被系统回收掉 3.停止（Stopped）:当 Activity 被系统完全覆盖时，被覆盖的 Activity 就会进 入 Stopped 状态，此时已不在可见，但是资源还是没有被收回 4.系统回收（Killed）:当 Activity 被系统回收掉，Activity 就处于 Killed 状 态 如果一个活动在处于停止或者暂停的状态下，系统内存缺乏时会将其结束 （finish）或者杀死（kill）。这种非正常情况下，系统在杀死或者结束 之前 会调用 onSaveInstance()方法来保存信息，同时，当 Activity 被移动到前台时， 重新启动该 Activity 并调用 onRestoreInstance()方法加载保留的信息，以保 持原有的状态。 在上面的四中常有的状态之间，还有着其他的生命周期来作为不同状态之间的过 度，用于在不同的状态之间进行转换，生命周期的具体说明见下图所示。 导致app 出现 ANR的原因简单的总结有以下两点： 1.主线程执行了耗时操作，比如数据库操作或网络编程 2.其他进程（就是其他程序）占用 CPU 导致本进程得不到 CPU 时间片，比如其他 进程的频繁读写操作可能会导致这个问题。 细分的话，导致 ANR 的原因有如下几点： ​ 耗时的网络访问 ​ 大量的数据读写 ​ 数据库操作 ​ 硬件操作（比如 camera) ​ 调用 thread 的 join()方法、sleep()方法、wait()方法或者等待线程锁的时候 ​ service binder 的数量达到上限 ​ system server 中发生 WatchDog ANR ​ service 忙导致超时无响应 ​ 其他线程持有锁，导致主线程等待超时 ​ 其它线程终止或崩溃导致主线程一直等待。 App 出现 crash 的原因App 崩溃相关的几个因素：内存 管理错误，程序逻辑错误，设备兼容，网络因素等，如下： ​ 内存管理错误：可能是可用内存过低，app 所需的内存超过设备的限制，app 跑不起来导致 App crash。 或是内存泄露，程序运行的时间越长，所占用的内存越大，最终用尽全部内存， 导致整个系统崩溃。 亦或非授权的内存位置的使用也可能会导致 App crash。 ​ 程序逻辑错误：数组越界、堆栈溢出、并发操作、逻辑错误。 e.g. app 新添加一个未经测试的新功能，调用了一个已释放的指针，运行的时 候就会 crash。 ​ 设备兼容：由于设备多样性，app 在不同的设备上可能会有不同的表现。 ​ 网络因素：可能是网速欠佳，无法达到 app 所需的快速响应时间，导致 app crash。或者是不同网络的切换也可能会影响 app 的稳定性。 经常出现的异常（Exception） 常见的几种如下： NullPointerException - 空指针引用异常 ClassCastException - 类型强制转换异常 IllegalArgumentException - 传递非法参数异常 ArithmeticException - 算术运算异常 ArrayStoreException - 向数组中存放与声明类型不兼容对象异常 IndexOutOfBoundsException - 下标越界异常 NegativeArraySizeException - 创建一个大小为负数的数组错误异常 NumberFormatException - 数字格式异常 SecurityException - 安全异常 UnsupportedOperationException - 不支持的操作异常","categories":[{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"}]},{"title":"建站教程","slug":"本站建站教程","date":"2018-11-15T16:07:04.000Z","updated":"2021-04-24T00:45:38.899Z","comments":true,"path":"本站建站教程.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%9C%AC%E7%AB%99%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B.html","excerpt":"本站采用的blog服务是Hexo，采用的是GitPage部署的方式","text":"本站采用的blog服务是Hexo，采用的是GitPage部署的方式 官网教程地址：https://hexo.io/zh-cn/docs/ 参考资料基本的操作 https://www.simon96.online/2018/10/12/hexo-tutorial/ 进阶修改相关 https://segmentfault.com/a/1190000009544924 本站使用的主题Next https://github.com/theme-next/hexo-theme-next 官方的中文教程 https://theme-next.iissnan.com/getting-started.html","categories":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"}]},{"title":"浏览器输入 url 按回车背后经历了哪些","slug":"浏览器输入 url 按回车背后经历了哪些","date":"2018-10-02T06:16:00.000Z","updated":"2018-10-02T06:28:38.000Z","comments":true,"path":"浏览器输入 url 按回车背后经历了哪些.html","link":"","permalink":"https://www.lauyongyi.cn/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%20url%20%E6%8C%89%E5%9B%9E%E8%BD%A6%E8%83%8C%E5%90%8E%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B.html","excerpt":"一个日常生活中，最常见的操作，但也常常被忽略，那就是：浏览器输入 url 按回车背后经历了哪些","text":"一个日常生活中，最常见的操作，但也常常被忽略，那就是：浏览器输入 url 按回车背后经历了哪些 1、首先，在浏览器地址栏中输入 url，先解析 url，检测 url 地址是否合法 2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在 屏幕中显示页面内容。若没有，则跳到第三步操作。 浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求； 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)； 路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存； ISP 缓存：若上述均失败，继续向 ISP 搜索。 3、在发送 http 请求前，需要域名解析(DNS 解析)，解析获取相应的 IP 地址。 4、浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手。 5、握手成功后，浏览器向服务器发送 http 请求，请求数据包。 6、服务器处理收到的请求，将数据返回至浏览器 7、浏览器收到 HTTP 响应 8、浏览器解码响应，如果响应可以缓存，则存入缓存。 9、 浏览器发送请求获取嵌入在 HTML 中的资源（html，css，javascript，图片， 音乐······），对于未知类型，会弹出对话框。 10、 浏览器发送异步请求。 11、页面全部渲染结束。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"web测试","slug":"web测试","permalink":"https://www.lauyongyi.cn/tags/web%E6%B5%8B%E8%AF%95/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2018-10-01T06:16:00.000Z","updated":"2018-10-01T06:28:38.000Z","comments":true,"path":"HTTP状态码.html","link":"","permalink":"https://www.lauyongyi.cn/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html","excerpt":"HTTP状态码（HTTP Status Code）是指表示服务器HTTP响应状态的3位数字代码。","text":"HTTP状态码（HTTP Status Code）是指表示服务器HTTP响应状态的3位数字代码。 它的作用在于使客户端程序快速通过服务器返回的状态，决定下一步要如何处理。因为由于网络延迟、服务器内部错误等各种原因，都可能导致客户端发送的请求得不到正确的响应，但是这些错误原因千差万别，如果一一处理很不现实，所以更有效的方式是把它们分组归类，利用统一的状态码进行标记，这样客户端就可以根据状态码进行处理了。 HTTP状态码可以分为5大类。 1）1xx仅仅是作为通知的消息，例如：102 Processing。这一类型的状态码，代表请求已经被接受，需要继续处理。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是临时的，表示客户端应该采取其他行动。 2）2xx是代表请求成功，例如：200 OK。这一类型的状态码，代表请求已成功被服务器接收、理解并接受。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立， 且其 URI 已经随 Location 头信息返回 202 服务器已接受请求，但尚未处理 3）3x是代表HTTP重定向，例如：301 Moved Permanently。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应 （对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应 继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来 检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此 响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返 回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者 应继续使用原有位置来进行以后的请求。 4）4xx是代表客户端导致的错误，例如404 Not Found。这类的状态码代表客户端发生的错误妨碍了服务器的处理。 401 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书 403 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份 验证并不能提供任何帮助，而且这个请求也不应该被重复提交 404 请求失败，请求所希望得到的资源未被在服务器上发现 5）5xx是代表服务器导致的错误，例如：500 Internal Server Error。这类状态码代表服务器在处理请求的过程中有错误或者异常状态发生，当然也有可能是服务器当前的软硬件资源无法完成对请求的处理。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的 方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收 到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状 况是临时的，并且将在一段时间以后恢复。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"}]},{"title":"HTTP协议","slug":"关于HTTP协议","date":"2018-10-01T02:16:00.000Z","updated":"2021-08-12T10:18:38.000Z","comments":true,"path":"关于HTTP协议.html","link":"","permalink":"https://www.lauyongyi.cn/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE.html","excerpt":"http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。","text":"http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。 HTTP 请求报文与响应报文格式请求报文包含三部分： a、请求行：包含请求方法、URI、HTTP 版本信息 b、请求头部（headers）字段 c、请求内容实体(body) 响应报文包含三部分： a、状态行：包含 HTTP 版本、状态码、状态码的原因短语 b、响应头部（headers）字段 c、响应内容(body)实体 Request Header大小限制Request Header就是往服务器发送的请求头，HTTP协议中并没有限制Header的大小。 理论上无论我们的Header有多大都是可以的。但实际上各个主流浏览器都会对Header长度进行限制，从几十KB到几百MB不等，基本上能满足平时的需求。 此外，在服务端也可以对Heder长度做限制。比如Nginx就可以限制Header的长度。 HTTP Header如果不限制大小会有什么影响？ 如果某个网站的服务器是不限制Header大小的，那么它就有可能被黑客利用实施攻击，比如DDoS。 黑客可以利用这一点，发送一个非常大（比如几MB）的请求，会占用服务器一个进程来专门处理这个请求。此类请求数量过多时，服务器就无法提供其他对外服务。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接 6、浏览器将该 html 文本并显示内容; HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:&#x6a;&#x61;&#118;&#x61;&#45;&#110;&#x65;&#x74;&#64;&#x6a;&#97;&#118;&#x61;&#46;&#x73;&#x75;&#x6e;&#46;&#x63;&#111;&#x6d;。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。","categories":[{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Postman环境变量设置与返回值检查","slug":"Postman环境变量设置与返回值检查","date":"2018-09-17T10:47:00.000Z","updated":"2018-12-13T10:47:30.000Z","comments":true,"path":"Postman环境变量设置与返回值检查.html","link":"","permalink":"https://www.lauyongyi.cn/Postman%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC%E6%A3%80%E6%9F%A5.html","excerpt":"Postman的全局变量，方便环境管理和参数设置。","text":"Postman的全局变量，方便环境管理和参数设置。 Postman变量作用域Global：全局，比如可以将错误提示信息设置成全局变量 Environment：环境变量，比如可以将测试domain设置成环境变量 Local：本地变量，一般可以在sandbox中定义 Data：测试数据中导入变量，所谓的参数化 界面位置 简单的实例：使用的是v2ex的Api作为示例链接, url： https://www.v2ex.com/api/nodes/show.json?name=&#123;&#123;node_name&#125;&#125; 是环境变量 操作步骤：先点击Postman界面的眼睛图标 然后点击“Environment（环境变量）”的Add，进入到编辑页面，见下图。 环境变量的名称可以自由定义，建议设置成有代表性，这样才方便区分。 填写好之后，需要选择环境变量 添加断言： 1234567var jsonData &#x3D; JSON.parse(responseBody);var node_name &#x3D; pm.environment.get(&quot;node_name&quot;);console.log(node_name);---先获取并检查返回值是否是想要的结果pm.test(&quot;返回值的name必须等于node_name&quot;, function () &#123; pm.expect(jsonData.name).to.eql(node_name);---将返回值与变量作比较&#125;); 然后运行，就可以看到结果了","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"https://www.lauyongyi.cn/tags/Postman/"}]},{"title":"连接MySQL出现2059错误","slug":"使用Navicat连接MySQL出现2059错误","date":"2018-06-13T15:00:00.000Z","updated":"2021-04-24T00:45:38.898Z","comments":true,"path":"使用Navicat连接MySQL出现2059错误.html","link":"","permalink":"https://www.lauyongyi.cn/%E4%BD%BF%E7%94%A8Navicat%E8%BF%9E%E6%8E%A5MySQL%E5%87%BA%E7%8E%B02059%E9%94%99%E8%AF%AF.html","excerpt":"今天使用navicat链接mysql的时候报了2059的错误，找了很久才找到解决方法，这里记录一下。","text":"今天使用navicat链接mysql的时候报了2059的错误，找了很久才找到解决方法，这里记录一下。 出现2059这个错误的原因是在mysql8之前的版本中加密规则为mysql_native_password，而在mysql8以后的加密规则为caching_sha2_password。通过网络查找发现我们可以将mysql用户登录的加密规则修改为mysql_native_password。下面说下具体步骤：打开xshll或者命令行工具 输入mysql -uroot -p登陆mysql，如果提示commod not found，那我们需要先将mysql加入系统环境变量（安装在本地的情况）。 登录成功后输入ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER修改加密规则 加密规则修改完成后我们可以通过ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;我是新密码&#39;更新一下用户的密码。这样就可以顺利的去使用Navicat去链接Mysql了。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/categories/python/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/categories/Linux/"},{"name":"Android","slug":"Android","permalink":"https://www.lauyongyi.cn/categories/Android/"},{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.lauyongyi.cn/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/categories/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/categories/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"name":"分享","slug":"分享","permalink":"https://www.lauyongyi.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lauyongyi.cn/tags/python/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lauyongyi.cn/tags/Linux/"},{"name":"adb命令","slug":"adb命令","permalink":"https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"},{"name":"Http","slug":"Http","permalink":"https://www.lauyongyi.cn/tags/Http/"},{"name":"功能测试","slug":"功能测试","permalink":"https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"接口测试","slug":"接口测试","permalink":"https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"name":"工具使用","slug":"工具使用","permalink":"https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"Android开发","slug":"Android开发","permalink":"https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"面试","slug":"面试","permalink":"https://www.lauyongyi.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"http","slug":"http","permalink":"https://www.lauyongyi.cn/tags/http/"},{"name":"shell","slug":"shell","permalink":"https://www.lauyongyi.cn/tags/shell/"},{"name":"SQL","slug":"SQL","permalink":"https://www.lauyongyi.cn/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.lauyongyi.cn/tags/MySQL/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.lauyongyi.cn/tags/Jenkins/"},{"name":"jmeter","slug":"jmeter","permalink":"https://www.lauyongyi.cn/tags/jmeter/"},{"name":"pytest","slug":"pytest","permalink":"https://www.lauyongyi.cn/tags/pytest/"},{"name":"selenium","slug":"selenium","permalink":"https://www.lauyongyi.cn/tags/selenium/"},{"name":"apache bench","slug":"apache-bench","permalink":"https://www.lauyongyi.cn/tags/apache-bench/"},{"name":"测试基础","slug":"测试基础","permalink":"https://www.lauyongyi.cn/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.lauyongyi.cn/tags/python%E7%88%AC%E8%99%AB/"},{"name":"Robot Framework","slug":"Robot-Framework","permalink":"https://www.lauyongyi.cn/tags/Robot-Framework/"},{"name":"Docker","slug":"Docker","permalink":"https://www.lauyongyi.cn/tags/Docker/"},{"name":"openSTF","slug":"openSTF","permalink":"https://www.lauyongyi.cn/tags/openSTF/"},{"name":"Request","slug":"Request","permalink":"https://www.lauyongyi.cn/tags/Request/"},{"name":"建站教程","slug":"建站教程","permalink":"https://www.lauyongyi.cn/tags/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"name":"网站","slug":"网站","permalink":"https://www.lauyongyi.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"web测试","slug":"web测试","permalink":"https://www.lauyongyi.cn/tags/web%E6%B5%8B%E8%AF%95/"},{"name":"Postman","slug":"Postman","permalink":"https://www.lauyongyi.cn/tags/Postman/"}]}
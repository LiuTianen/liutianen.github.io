<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tianen</title>
  
  <subtitle>搞事情，搞事情</subtitle>
  <link href="https://www.lauyongyi.cn/atom.xml" rel="self"/>
  
  <link href="https://www.lauyongyi.cn/"/>
  <updated>2021-09-05T14:15:00.000Z</updated>
  <id>https://www.lauyongyi.cn/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用requests做简单的接口测试</title>
    <link href="https://www.lauyongyi.cn/python+request2.html"/>
    <id>https://www.lauyongyi.cn/python+request2.html</id>
    <published>2021-09-05T11:14:00.000Z</published>
    <updated>2021-09-05T14:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        <code>requests</code>除了用来做接口请求的发送，还可以用来做接口测试，使用方法跟最基础的发送请求一样，不同点就是多了一些处理方法和断言。<a id="more"></a></p><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        &lt;code&gt;requests&lt;/code&gt;除了用来做接口请求的发送，还可以用来做接口测试，使用方法跟最基础的发送请求一样，不同点就是多了一些处理方法和断言。</summary>
    
    
    
    <category term="python" scheme="https://www.lauyongyi.cn/categories/python/"/>
    
    
    <category term="python" scheme="https://www.lauyongyi.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用的几个命令</title>
    <link href="https://www.lauyongyi.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://www.lauyongyi.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2021-09-04T03:26:00.000Z</published>
    <updated>2021-12-14T11:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    记录几个日常工作中常用到的几个Linux命令如：<code>tail</code>、<code>cat</code>、<code>vi</code>、<code>grep</code>等以及相关的可选项的使用。<a id="more"></a></p><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>​    tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容. </p><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><p>tail [必要参数] [选择参数] [文件]  </p><h5 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h5><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><h5 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h5><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-f</td><td>循环读取</td></tr><tr><td>-q</td><td>不显示处理信息</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr><tr><td>-c&lt;数目&gt;</td><td>显示的字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示行数</td></tr><tr><td>–pid=PID</td><td>与-f合用,可以在指定进程结束后结束<code>tail -f</code></td></tr><tr><td>-q, –quiet, –silent</td><td>从不输出给出文件名的首部</td></tr><tr><td>-s, –sleep-interval=S</td><td>与-f合用,表示在每次反复的间隔休眠S秒</td></tr></tbody></table><h5 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h5><h6 id="显示文件末尾内容"><a href="#显示文件末尾内容" class="headerlink" title="显示文件末尾内容"></a>显示文件末尾内容</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tail -n 5 time.log </span><br><span class="line"></span><br><span class="line">BTW = FF</span><br><span class="line">USB = FF</span><br><span class="line">0x300</span><br><span class="line">Power Down%                 </span><br></pre></td></tr></table></figure><h6 id="循环查看文件内容"><a href="#循环查看文件内容" class="headerlink" title="循环查看文件内容"></a>循环查看文件内容</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.31.220  &gt; ip.log&amp;</span><br><span class="line">[1] 37763</span><br><span class="line">tail -f ip.log --pid 37763</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br><span class="line">Request timeout for icmp_seq 3</span><br><span class="line">Request timeout for icmp_seq 4</span><br><span class="line">Request timeout for icmp_seq 5</span><br><span class="line">Request timeout for icmp_seq 6</span><br><span class="line">Request timeout for icmp_seq 7</span><br><span class="line">Request timeout for icmp_seq 8</span><br><span class="line">Request timeout for icmp_seq 9</span><br><span class="line">Request timeout for icmp_seq 10</span><br><span class="line">Request timeout for icmp_seq 11</span><br><span class="line">Request timeout for icmp_seq 12</span><br><span class="line">Request timeout for icmp_seq 13</span><br><span class="line">Request timeout for icmp_seq 14</span><br><span class="line">Request timeout for icmp_seq 15</span><br><span class="line">Request timeout for icmp_seq 16</span><br><span class="line">Request timeout for icmp_seq 17</span><br><span class="line">Request timeout for icmp_seq 18</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>ping 192.168.31.220  &gt; ip.log&amp; &amp; //在后台ping远程主机。并输出文件到ip.log；这种做法也适用于一个以上的档案监视。可以Ctrl＋c来终止，也可以在另一个窗口 kill pid 来结束。</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>​    grep命令是Linux系统中一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p><p>grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><h5 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h5><p><code>grep [option] /path/file</code>：用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><h5 id="命令参数："><a href="#命令参数：" class="headerlink" title="命令参数："></a>命令参数：</h5><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-a  –text</td><td>不要忽略二进制的数据。</td></tr><tr><td>-A&lt;显示行数&gt;  –after-context=&lt;显示行数&gt;</td><td>除了显示符合范本样式的那一列之外，并显示该行之后的内容。</td></tr><tr><td>-b  –byte-offset</td><td>在显示符合样式的那一行之前，标示出该行第一个字符的编号。</td></tr><tr><td>-B&lt;显示行数&gt;  –before-context=&lt;显示行数&gt;</td><td>除了显示符合样式的那一行之外，并显示该行之前的内容。</td></tr><tr><td>-c  –count</td><td>计算符合样式的列数。</td></tr><tr><td>-C&lt;显示行数&gt;  –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</td><td>除了显示符合样式的那一行之外，并显示该行之前后的内容。</td></tr><tr><td>-d &lt;动作&gt;   –directories=&lt;动作&gt;</td><td>当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</td></tr><tr><td>-e&lt;范本样式&gt; –regexp=&lt;范本样式&gt;</td><td>指定字符串做为查找文件内容的样式。</td></tr><tr><td>-E   –extended-regexp</td><td>将样式为延伸的普通表示法来使用。</td></tr><tr><td>-f&lt;规则文件&gt; –file=&lt;规则文件&gt;</td><td>指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</td></tr><tr><td>-F  –fixed-regexp</td><td>将样式视为固定字符串的列表。</td></tr><tr><td>-G  –basic-regexp</td><td>将样式视为普通的表示法来使用。</td></tr><tr><td>-h  –no-filename</td><td>在显示符合样式的那一行之前，不标示该行所属的文件名称。</td></tr><tr><td>-H  –with-filename</td><td>在显示符合样式的那一行之前，表示该行所属的文件名称。</td></tr><tr><td>-i  –ignore-case</td><td>忽略字符大小写的差别。</td></tr><tr><td>-l  –file-with-matches</td><td>列出文件内容符合指定的样式的文件名称。</td></tr><tr><td>-L  –files-without-match</td><td>列出文件内容不符合指定的样式的文件名称。</td></tr><tr><td>-n  –line-number</td><td>在显示符合样式的那一行之前，标示出该行的列数编号。</td></tr><tr><td>-q  –quiet或–silent</td><td>不显示任何信息。</td></tr><tr><td>-r  –recursive</td><td>此参数的效果和指定“-d recurse”参数相同。</td></tr><tr><td>-s  –no-messages</td><td>不显示错误信息。</td></tr><tr><td>-v  –revert-match</td><td>显示不包含匹配文本的所有行。</td></tr><tr><td>-V  –version</td><td>显示版本信息。</td></tr><tr><td>-w  –word-regexp</td><td>只显示全字符合的列。</td></tr><tr><td>-x  –line-regexp</td><td>只显示全列符合的列。</td></tr><tr><td>-y</td><td>此参数的效果和指定“-i”参数相同。</td></tr></tbody></table><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><h6 id="查找指定进程"><a href="#查找指定进程" class="headerlink" title="查找指定进程"></a>查找指定进程</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep pycharm</span><br><span class="line">  501 36537     1   0  3:14下午 ??        17:29.34 /Users/......./Library/Application Support/JetBrains/Toolbox/apps/PyCharm-P/ch-0/212.5080.64/PyCharm.app/Contents/MacOS/pycharm</span><br><span class="line">  501 38003 36013   0  5:18下午 ttys000    0:00.00 grep pycharm</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>第一条记录是查找出的进程；第二条结果是grep进程本身，并非真正要找的进程。</p><h6 id="查找指定进程个数"><a href="#查找指定进程个数" class="headerlink" title="查找指定进程个数"></a>查找指定进程个数</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep pycharm -c</span><br><span class="line">2</span><br><span class="line">ps -ef | grep  -c pycharm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat（“ <strong>concatenate</strong> ”的缩写）命令是Linux / Unix等操作系统中最常用的命令之一。<strong>cat</strong>命令允许创建单个或多个文件，查看文件、连接文件以及在终端或文件中重定向输出。</p><h5 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h5><p>1、显示文件内容，如果没有文件或文件为-则读取标准输入。<br>2、将多个文件的内容进行连接并打印到标准输出。<br>3、显示文件内容中的不可见字符（控制字符、换行符、制表符等）。</p><h5 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h5><p><code>cat [OPTION]... [FILE]...</code><br>FILE（可选）：要处理的文件，可以为一或多个。<br>长选项与短选项等价<br>| 参数                                            | 解释                                                         |<br>| ———————————————– | ———————————————————— |<br>|-A, –show-all          |等价于”-vET”组合选项。<br>|-b, –number-nonblank    |只对非空行编号，从1开始编号，覆盖”-n”选项。|<br>|-e                       |等价于”-vE”组合选项。|<br>|-E, –show-ends          |在每行的结尾显示’$’字符。|<br>|-n, –number             |对所有行编号，从1开始编号。|<br>|-s, –squeeze-blank      |压缩连续的空行到一行。|<br>|-t                       |等价于”-vT”组合选项。|<br>|-T, –show-tabs          |使用”^I”表示TAB（制表符）。|<br>|-u                       |POSIX兼容性选项，无意义。|<br>|-v, –show-nonprinting   |使用”^”和”M-“符号显示控制字符，除了LFD（line feed，即换行符’\n’）和TAB（制表符）。|<br>|–help                   | 显示帮助信息并退出。|<br>|–version                | 显示版本信息并退出。|</p><h5 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 合并显示多个文件</span></span><br><span class="line">cat ./1.log ./2.log ./3.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示文件中的非打印字符、tab、换行符</span></span><br><span class="line">cat -A test.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件的空行</span></span><br><span class="line">cat -s test.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示文件并在所有行开头附加行号</span></span><br><span class="line">cat -n test.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示文件并在所有非空行开头附加行号</span></span><br><span class="line">cat -b test.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将标准输入的内容和文件内容一并显示</span></span><br><span class="line">echo &#x27;######&#x27; |cat - test.log</span><br></pre></td></tr></table></figure><h4 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi/vim"></a>vi/vim</h4><p>参考另一个笔记 :Linux vi和vim</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    记录几个日常工作中常用到的几个Linux命令如：&lt;code&gt;tail&lt;/code&gt;、&lt;code&gt;cat&lt;/code&gt;、&lt;code&gt;vi&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;等以及相关的可选项的使用。</summary>
    
    
    
    <category term="Linux" scheme="https://www.lauyongyi.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.lauyongyi.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用requests发送简单的接口请求</title>
    <link href="https://www.lauyongyi.cn/python+request.html"/>
    <id>https://www.lauyongyi.cn/python+request.html</id>
    <published>2021-08-29T11:14:00.000Z</published>
    <updated>2021-08-29T13:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        <code>requests</code>一个Python第三方库，用来做接口测试、爬虫特别方便<a id="more"></a></p><h4 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h4><p>安装命令如下：<code>pip install requests</code></p><p>如果遇到报错，windows可以使用管理员权限的命令行窗口执行、Linux等可以在前面加<code>sudo</code>。</p><p>使用<code>requests</code>非常简单，只需要<code>import requests</code>，然后调用即可。</p><h4 id="第一个Get请求"><a href="#第一个Get请求" class="headerlink" title="第一个Get请求"></a>第一个Get请求</h4><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">html = requests.get(<span class="string">&#x27;https://www.v2ex.com/api/nodes/show.json?name=python&#x27;</span>)</span><br><span class="line">print(html.status_code)</span><br><span class="line">print(html.text)</span><br><span class="line">print(html.headers)</span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><p>![](/images/2021/08/Interface Test/02.png)</p><h4 id="第一个Post请求"><a href="#第一个Post请求" class="headerlink" title="第一个Post请求"></a>第一个Post请求</h4><p>Post请求，相较于Get请求，要稍稍复杂一些，需要构造requestsBody。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://api.apishop.net/common/weather/getWeatherByGPS&quot;</span></span><br><span class="line"></span><br><span class="line">payload=&#123;<span class="string">&#x27;apiKey&#x27;</span>:<span class="string">&#x27;XXXXXXXXXXXXXXXXXXX&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;22.546534&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;lng&#x27;</span>: <span class="string">&#x27;113.931833&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;need3HourForcast&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;needMoreDay&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">headers = &#123;&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, headers=headers, data=payload)</span><br><span class="line"></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>由于返回的内容较多，这里就不加图了。</p><h5 id="携带User-Agent的请求"><a href="#携带User-Agent的请求" class="headerlink" title="携带User-Agent的请求"></a>携带User-Agent的请求</h5><p><strong>用户代理</strong>（英语：user agent）在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中指的是代表<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">用户</a>行为的程序（<a href="https://zh.wikipedia.org/w/index.php?title=%E8%BD%AF%E4%BB%B6%E4%BB%A3%E7%90%86%E7%A8%8B%E5%BA%8F&action=edit&redlink=1">软件代理程序</a>）。例如，<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>就是一个“帮助用户获取、渲染网页内容并与之交互”的用户代理</p><p>当一个软件在一个<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>进行操作时，它通常向它的operating peer提交一个特定的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>来标示自己，该字符串通常包含了其<a href="https://zh.wikipedia.org/wiki/%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">应用程序</a>类型、<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>、软件供应商……等等，有时还会包含软件修订版本等信息。在<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>、SIP以及SMTP/NNTP[<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86#cite_note-2">2]</a>协议中，这个识别是通过<em>user-agent</em>的<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E5%AD%97%E6%AE%B5">头字段</a>传送的。<br><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%BA%E5%99%A8%E4%BA%BA">网络机器人</a>，例如网络抓取工具，通常也会在用户代理的字符串中包含bot的操纵者的联系信息，例如一个<a href="https://zh.wikipedia.org/wiki/URL">URL</a>或一个<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80">电子邮件地址</a>，以便<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E5%91%98">网站管理员</a>可以用来联系操纵者。</p><p>在HTTP中，User-Agent字符串通常被用于<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">内容协商</a>，而原始服务器为该响应选择适当的内容或操作参数。例如，User-Agent字符串可能被网络服务器用以基于特定版本的客户端软件的已知功能选择适当的变体。</p><p>通过使用<a href="https://zh.wikipedia.org/wiki/Robots.txt">robots.txt</a>文件的可以设置<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7&action=edit&redlink=1">网络抓取工具</a>对网站的部分访问与否，而其设置标准之一就是用户代理字符串。换句话说，借由<a href="https://zh.wikipedia.org/wiki/Robots.txt">robots.txt</a>文件的设置，可以让网站不能被特定的浏览器访问。</p><p>以豆瓣为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">html = requests.get(<span class="string">&#x27;https://www.douban.com/&#x27;</span>)</span><br><span class="line">print(html.status_code)</span><br><span class="line"></span><br><span class="line">*****运行结果*****</span><br><span class="line"><span class="number">418</span></span><br></pre></td></tr></table></figure><p>返回的“418”表示请求被豆瓣的服务拒绝了，也就说明，豆瓣认为该次请求是爬虫请求。</p><p>这时候，添加一个User-Agent来模拟成六=浏览器发送的请求。</p><p>User-Agent可以从网上随便搜索到，也可用浏览器自带的控制台获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">html = requests.get(<span class="string">&#x27;https://www.douban.com/&#x27;</span>,headers=headers)</span><br><span class="line">print(html.status_code)</span><br><span class="line"></span><br><span class="line">******运行结果******</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>这时候，就可以添加一些其他打印了，如text、hearders等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        &lt;code&gt;requests&lt;/code&gt;一个Python第三方库，用来做接口测试、爬虫特别方便</summary>
    
    
    
    <category term="python" scheme="https://www.lauyongyi.cn/categories/python/"/>
    
    
    <category term="python" scheme="https://www.lauyongyi.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>adb shell dumpsys 命令解析</title>
    <link href="https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--dumpsys.html"/>
    <id>https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--dumpsys.html</id>
    <published>2021-08-28T15:17:00.000Z</published>
    <updated>2021-08-28T15:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    <code>dumpsys</code> 是一种在 Android 设备上运行的工具，可提供有关系统服务的信息。可以使用 ADB从命令行调用 <code>dumpsys</code>，获取在连接的设备上运行的所有系统服务的诊断输出。此输出通常比想要的更详细，因此可以使用下文所述的命令行选项仅获取您感兴趣的系统服务的输出。<a id="more"></a></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>使用 <code>dumpsys</code> 的一般语法如下：</p><p><code> adb shell dumpsys [-t timeout] [--help | -l | --skip services | service [arguments] | -c | -h]</code></p><p>要获取所连接设备的所有系统服务的诊断输出，只需运行 <code>adb shell dumpsys</code>。不过，这样输出的信息比想要的信息多得多。要使输出更加可控，可以通过在命令中添加相应服务来指定要检查的服务。</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-t timeout</code></td><td align="left">指定超时期限（秒）。如果未指定，默认值为 10 秒。</td></tr><tr><td align="left"><code>--help</code></td><td align="left">输出 <code>dumpsys</code> 工具的帮助文本。</td></tr><tr><td align="left"><code>-l</code></td><td align="left">输出可与 <code>dumpsys</code> 配合使用的系统服务的完整列表。</td></tr><tr><td align="left"><code>--skip services</code></td><td align="left">指定您不希望包含在输出中的 services。</td></tr><tr><td align="left"><code>service [arguments]</code></td><td align="left">指定您希望输出的 service。某些服务可能允许您传递可选 arguments。您可以通过将 <code>-h</code> 选项与服务名称一起传递来了解这些可选参数，如下所示：<code>adb shell dumpsys procstats -h    </code></td></tr><tr><td align="left"><code>-c</code></td><td align="left">指定某些服务时，附加此选项能以计算机可读的格式输出数据。</td></tr><tr><td align="left"><code>-h</code></td><td align="left">对于某些服务，附加此选项可查看该服务的帮助文本和其他选项。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    &lt;code&gt;dumpsys&lt;/code&gt; 是一种在 Android 设备上运行的工具，可提供有关系统服务的信息。可以使用 ADB从命令行调用 &lt;code&gt;dumpsys&lt;/code&gt;，获取在连接的设备上运行的所有系统服务的诊断输出。此输出通常比想要的更详细，因此可以使用下文所述的命令行选项仅获取您感兴趣的系统服务的输出。</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>adb shell am 命令解析</title>
    <link href="https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--am.html"/>
    <id>https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--am.html</id>
    <published>2021-08-28T02:42:00.000Z</published>
    <updated>2021-08-28T13:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    am全称：Activity Manager ，可以执行各种系统操作，如启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性，等等。<a id="more"></a></p><h4 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a>命令行语法</h4><table><thead><tr><th>环境</th><th>命令</th></tr></thead><tbody><tr><td><strong>adb 直接发出</strong></td><td><strong>adb shell am &lt;command&gt;</strong></td></tr><tr><td><strong>shell 中</strong></td><td><strong>am &lt;command&gt;</strong></td></tr></tbody></table><h4 id="intent-功能"><a href="#intent-功能" class="headerlink" title="intent 功能"></a>intent 功能</h4><p><code>Intent</code> 是一个消息传递对象，您可以用来从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><ul><li><p><strong>启动 Activity</strong></p><p><code>Activity</code> 表示应用中的一个屏幕。通过将 <code>Intent</code> 传递给 <code>startActivity()</code>，您可以启动新的 <code>Activity</code> 实例。<code>Intent</code> 用于描述要启动的 Activity，并携带任何必要的数据。</p><p>如果您希望在 Activity 完成后收到结果，请调用 <code>startActivityForResult()</code>。在 Activity 的 <code>onActivityResult()</code> 回调中，您的 Activity 将结果作为单独的 <code>Intent</code> 对象接收</p></li><li><p>启动服务</p><p><code>Service</code> 是一个不使用用户界面而在后台执行操作的组件。使用 Android 5.0（API 级别 21）及更高版本，您可以启动包含 <code>JobScheduler</code> 的服务。如需了解有关 <code>JobScheduler</code> 的详细信息，请参阅其 <code>API-reference documentation</code>。</p><p>对于 Android 5.0（API 级别 21）之前的版本，您可以使用 <code>Service</code> 类的方法来启动服务。通过将 <code>Intent</code> 传递给 <code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。<code>Intent</code> 用于描述要启动的服务，并携带任何必要的数据。</p><p>如果服务旨在使用客户端-服务器接口，则通过将 <code>Intent</code> 传递给 <code>bindService()</code>，您可以从其他组件绑定到此服务。</p></li><li><p>传递广播</p><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 <code>Intent</code> 传递给 <code>sendBroadcast()</code> 或 <code>sendOrderedBroadcast()</code>，您可以将广播传递给其他应用。</p></li></ul><h5 id="Intent-基础项"><a href="#Intent-基础项" class="headerlink" title="Intent 基础项"></a>Intent 基础项</h5><table><thead><tr><th>Intent</th><th>说明</th><th>例子</th><th>参数</th></tr></thead><tbody><tr><td>COMPONENT</td><td>指定带有软件包名称前缀的组件名称以创建显式 intent</td><td>com.example.app/.ExampleActivity</td><td>-n</td></tr><tr><td>ACTION</td><td>指定 intent 操作，比如调用拨打电话组件</td><td>android.intent.action.VIEW</td><td>-a</td></tr><tr><td>DATA_URI</td><td>指定 intent 数据 URI</td><td>content://contacts/people/1</td><td>-d</td></tr><tr><td>CATEGORY</td><td>指定 intent 类别</td><td>android.intent.category.APP_CONTACTS</td><td>-c</td></tr><tr><td>MIME_TYPE</td><td>传递给Intent的额外数据，以Bundle的形式定义，就是一些键值对</td><td>image/png</td><td>-t</td></tr><tr><td>EXTRA</td><td>添加字符串数据作为键值对</td><td></td><td>-e</td></tr><tr><td>FLAGS</td><td>将标志添加到 setFlags() 支持的 intent。</td><td></td><td>-f</td></tr></tbody></table><h5 id="Intent-EXTRA-附加的额外数据"><a href="#Intent-EXTRA-附加的额外数据" class="headerlink" title="Intent EXTRA(附加的额外数据)"></a>Intent EXTRA(附加的额外数据)</h5><table><thead><tr><th>Intent</th><th>说明</th><th>数据类型</th></tr></thead><tbody><tr><td>-e|–es extra_key extra_string_value</td><td>添加字符串数据作为键值对</td><td>字符串</td></tr><tr><td>–esn extra_key</td><td>添加一个 null extra。URI intent 不支持此选项。</td><td>null</td></tr><tr><td>–ez extra_key extra_boolean_value</td><td>添加布尔型数据作为键值对。</td><td>布尔型</td></tr><tr><td>–ei extra_key extra_int_value</td><td>添加整数型数据作为键值对。</td><td>整型</td></tr><tr><td>–el extra_key extra_long_value</td><td>添加长整型数据作为键值对。</td><td>长整型</td></tr><tr><td>–ef extra_key extra_float_value</td><td>添加浮点型数据作为键值对。</td><td>浮点型</td></tr><tr><td>–eu extra_key extra_uri_value</td><td>添加 URI 数据作为键值对。</td><td>URI</td></tr><tr><td>–ecn extra_key extra_component_name_value</td><td>添加组件名称，将其作为 ComponentName 对象进行转换和传递</td><td>COMPONENT</td></tr><tr><td>–eia extra_key extra_int_value[,extra_int_value…]</td><td>添加整数数组。</td><td>整数数组</td></tr><tr><td>–ela extra_key extra_long_value[,extra_long_value…]</td><td>添加长整型数组。</td><td>长整型数组</td></tr><tr><td>–efa extra_key extra_float_value[,extra_float_value…]</td><td>添加浮点型数组。</td><td>浮点型数组</td></tr></tbody></table><h5 id="Intent-activity-FLAG"><a href="#Intent-activity-FLAG" class="headerlink" title="Intent activity FLAG"></a>Intent activity FLAG</h5><table><thead><tr><th>Intent</th><th>说明</th></tr></thead><tbody><tr><td>–activity-brought-to-front</td><td>包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT</td></tr><tr><td>–activity-clear-top</td><td>包含标志 FLAG_ACTIVITY_CLEAR_TOP</td></tr><tr><td>–activity-clear-when-task-reset</td><td>包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</td></tr><tr><td>–activity-exclude-from-recents</td><td>包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</td></tr><tr><td>–activity-launched-from-history</td><td>包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</td></tr><tr><td>–activity-multiple-task</td><td>包含标志 FLAG_ACTIVITY_MULTIPLE_TASK</td></tr><tr><td>–activity-no-animation</td><td>包含标志 FLAG_ACTIVITY_NO_ANIMATION</td></tr><tr><td>–activity-no-history</td><td>包含标志 FLAG_ACTIVITY_NO_HISTORY</td></tr><tr><td>–activity-no-user-action</td><td>包含标志 FLAG_ACTIVITY_NO_USER_ACTION</td></tr><tr><td>–activity-previous-is-top</td><td>包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP</td></tr><tr><td>–activity-reorder-to-front</td><td>包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT</td></tr><tr><td>–activity-reset-task-if-needed</td><td>包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</td></tr><tr><td>–activity-single-top</td><td>包含标志 FLAG_ACTIVITY_SINGLE_TOP</td></tr><tr><td>–activity-clear-task</td><td>包含标志 FLAG_ACTIVITY_CLEAR_TASK</td></tr><tr><td>–activity-task-on-home</td><td>包含标志 FLAG_ACTIVITY_TASK_ON_HOME</td></tr></tbody></table><h5 id="Intent-FLAG"><a href="#Intent-FLAG" class="headerlink" title="Intent FLAG"></a>Intent FLAG</h5><table><thead><tr><th>Intent</th><th>说明</th></tr></thead><tbody><tr><td>–grant-read-uri-permission</td><td>包含标志 FLAG_GRANT_READ_URI_PERMISSION</td></tr><tr><td>–grant-write-uri-permission</td><td>包含标志 FLAG_GRANT_WRITE_URI_PERMISSION</td></tr><tr><td>–debug-log-resolution</td><td>包含标志 FLAG_DEBUG_LOG_RESOLUTION</td></tr><tr><td>–exclude-stopped-packages</td><td>包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES</td></tr><tr><td>–include-stopped-packages</td><td>包含标志 FLAG_INCLUDE_STOPPED_PACKAGES</td></tr><tr><td>–receiver-registered-only</td><td>包含标志 FLAG_RECEIVER_REGISTERED_ONLY</td></tr><tr><td>–receiver-replace-pending</td><td>包含标志 FLAG_RECEIVER_REPLACE_PENDING</td></tr><tr><td>–selector</td><td>需要使用 -d 和 -t 选项以设置 intent 数据和类型</td></tr></tbody></table><h4 id="am用法"><a href="#am用法" class="headerlink" title="am用法"></a>am用法</h4><h5 id="启动页面"><a href="#启动页面" class="headerlink" title="启动页面"></a>启动页面</h5><p>命令行语法</p><table><thead><tr><th>旧语法</th><th>adb shell am start [options] intent</th></tr></thead><tbody><tr><td><strong>新语法</strong></td><td><strong>adb shell am start-activity [options] intent</strong></td></tr></tbody></table><table><thead><tr><th>参数</th><th>说明</th><th></th></tr></thead><tbody><tr><td>-D</td><td>启用调试</td><td></td></tr><tr><td>-W</td><td>等待启动完成</td><td></td></tr><tr><td>-P file</td><td>类似于 –start-profiler，但当应用进入空闲状态时分析停止</td><td></td></tr><tr><td>-R count</td><td>重复 Activity 启动 count 次数。在每次重复前，将完成顶部 Activity</td><td></td></tr><tr><td>-S</td><td>启动 Activity 前强行停止目标应用</td><td></td></tr></tbody></table><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><table><thead><tr><th>旧语法</th><th>adb shell am startservice &lt;intent&gt;</th></tr></thead><tbody><tr><td><strong>新语法</strong></td><td><strong>adb shell am start-service &lt;intent&gt;</strong></td></tr></tbody></table><h5 id="启动广播"><a href="#启动广播" class="headerlink" title="启动广播"></a>启动广播</h5><table><thead><tr><th><strong>语法</strong></th><th><strong>adb shell am broadcast [options] intent</strong></th></tr></thead></table><h5 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h5><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>force-stop &lt;package&gt;</td><td>强行停止与package（应用的包名称）关联的所有应用</td></tr><tr><td>kill [options] &lt;package&gt;</td><td>终止与 package（应用的包名称）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。</td></tr><tr><td>kill-all</td><td>终止所有后台进程</td></tr></tbody></table><h5 id="内存快照"><a href="#内存快照" class="headerlink" title="内存快照"></a>内存快照</h5><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dumpheap [options] &lt;process&gt; &lt;file&gt;</td><td>转储 process 的堆，写入 file。  -n：转储原生堆，而非托管堆。 -g:  转储之前，强制执行GC</td></tr><tr><td>使用基本步骤： 1、执行命令：am dumpheap com.android.calculator2 /data/local/tmp/1.hprof 2、pull到计算机：adb pull /data/local/tmp/1.hprof d:\1 3、转换格式：hprof-conv 1.hprof 2.hprof  （hprof-conv 工具位于platform-toos） 4、使用MAT打开</td><td></td></tr></tbody></table><h5 id="UID监听"><a href="#UID监听" class="headerlink" title="UID监听"></a>UID监听</h5><table><thead><tr><th>watch-uids [–oom &lt;uid&gt;]</th><th>监听uid状态变化。–oom 指定监听的uid详细变化信息</th></tr></thead></table><p>用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">不加参数：adb shell am watch-uids</span><br><span class="line">10068 idle</span><br><span class="line">10068 cached</span><br><span class="line">10068 procstate CEM  seq 0</span><br><span class="line">10068 active</span><br><span class="line">10068 uncached</span><br><span class="line">10068 procstate TOP  seq 0</span><br><span class="line">10025 procstate BFGS seq 0     &#x2F;&#x2F;以上打开10068应用</span><br><span class="line">10025 procstate TOP  seq 0</span><br><span class="line">10068 cached</span><br><span class="line">10068 procstate LAST seq 0     &#x2F;&#x2F;10068 按home键回到主屏幕</span><br><span class="line">10068 procstate CRE  seq 0</span><br><span class="line">10068 idle</span><br><span class="line">10068 gone                                      &#x2F;&#x2F;10068从最近使用程序删除</span><br></pre></td></tr></table></figure><h5 id="异常监听"><a href="#异常监听" class="headerlink" title="异常监听"></a>异常监听</h5><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>monitor</td><td>启动对崩溃或 ANR 的监控。</td></tr><tr><td>crash &lt;PACKAGE|PID&gt;</td><td>在指定的包或进程中引发VM崩溃</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    am全称：Activity Manager ，可以执行各种系统操作，如启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性，等等。</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>adb命令之logcat</title>
    <link href="https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--logcat.html"/>
    <id>https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--logcat.html</id>
    <published>2021-08-26T02:19:00.000Z</published>
    <updated>2021-08-27T14:46:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        Logcat 是一个adb的一个工具命令，用于转储系统消息日志。<a id="more"></a></p><p>主要作用是：</p><p>​    1、抓取保存设备引发错误时的堆栈追踪</p><p>​    2、抓取保存使用 Log 类编写的消息</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>adb logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</code></p><p>输出到电脑：</p><p><code>adb logcat  &gt; /path/filename</code></p><p>shell链接下：</p><p><code>logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</code></p><h4 id="Android-日志缓冲区"><a href="#Android-日志缓冲区" class="headerlink" title="Android 日志缓冲区"></a>Android 日志缓冲区</h4><p>​        Android 日志记录系统是系统进程 <code>logd</code> 维护的一组结构化环形缓冲区。这组可用的缓冲区是固定的，并由系统定义。最相关的缓冲区为：<code>main</code>（用于存储大多数应用日志）、<code>system</code>（用于存储源自 Android 操作系统的消息）、 <code>crash</code>（用于存储崩溃日志）、<code>radio</code>(无线装置/电话相关消息)和<code>events</code>(事件相关消息)。每个日志条目都包含一个优先级（<code>VERBOSE</code>、<code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>、<code>ERROR</code> 或 <code>FATAL</code>）、一个标识日志来源的标记以及实际的日志消息。</p><h5 id="查看指定缓冲区"><a href="#查看指定缓冲区" class="headerlink" title="查看指定缓冲区"></a>查看指定缓冲区</h5><p>语法</p><p><code>adb logcat -b &lt;buffer&gt; </code></p><p>举例：</p><p><code>adb logcat -b radio </code></p><p><code>adb logcat -b events</code></p><h5 id="缓冲区操作"><a href="#缓冲区操作" class="headerlink" title="缓冲区操作"></a>缓冲区操作</h5><table><thead><tr><th>命令选项</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>清除（刷新）整个缓冲区日志并退出。</td></tr><tr><td>-d</td><td>将缓冲区日志转储到屏幕并退出。</td></tr><tr><td>-g</td><td>打印指定日志缓冲区的大小并退出。</td></tr><tr><td>-G</td><td>设置环形缓冲区大小，单位可以为K或者M</td></tr></tbody></table><h4 id="日志过滤"><a href="#日志过滤" class="headerlink" title="日志过滤"></a>日志过滤</h4><p>日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08-27 12:03:33.511  2454  2598 D MtkHotplugStatus: disable usb detect</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">日志时间：08-27 12:03:33.511</span><br><span class="line">UID--父进程：2454</span><br><span class="line">PID--进程号：2598</span><br><span class="line">输出级别：D</span><br><span class="line">输出标签：MtkHotplugStatus</span><br><span class="line">日志信息：disable usb detect</span><br></pre></td></tr></table></figure><h5 id="管道过滤"><a href="#管道过滤" class="headerlink" title="管道过滤"></a>管道过滤</h5><p>windows下：<code>adb logcat | findstr &lt;过滤字段&gt; </code></p><p>Linux下：<code>adb logcat | grep &lt;过滤字段&gt; </code></p><h5 id="根据进程过滤"><a href="#根据进程过滤" class="headerlink" title="根据进程过滤"></a>根据进程过滤</h5><table><thead><tr><th>–pid=&lt;pid&gt;</th><th>只打印给定的pid日志</th></tr></thead></table><p>语法：<code>adb logcat --pid &lt;pid&gt;</code></p><h5 id="使用正则过滤"><a href="#使用正则过滤" class="headerlink" title="使用正则过滤"></a>使用正则过滤</h5><table><thead><tr><th>最简单的正则符号</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>代表一个字符</td></tr><tr><td>*</td><td>代表0个和任意多个字符</td></tr></tbody></table><p>例子：</p><p>1234567890，转换成正则表达可以是：<code>.*789.*</code>，<code>.*678.*</code>。</p><p>用法：</p><table><thead><tr><th>-e &lt;expr&gt;, –regex=&lt;expr&gt;</th><th>打印输出通过设置perl兼容的正则表达式</th></tr></thead></table><p>例子：包含wifi字符串的日志：<code>adb logcat -e .*wifi.*</code></p><h5 id="行数时间过滤"><a href="#行数时间过滤" class="headerlink" title="行数时间过滤"></a>行数时间过滤</h5><table><thead><tr><th>参数选项</th><th>说明</th></tr></thead><tbody><tr><td>-m &lt;count&gt;</td><td>打印指定最大行数后退出，可以和**–regex**配合使用</td></tr><tr><td>-t &lt;count&gt;</td><td>只打印最近的指定行数（类似-d,输出完成跳出）</td></tr><tr><td>-t “&lt;time&gt;”</td><td>只打印指定时间之后的日志（类似 -d）</td></tr><tr><td>-T &lt;count&gt;</td><td>只打印最近的指定行数（不同于 -d，输出完成继续实时log）</td></tr><tr><td>-T “&lt;time&gt;”</td><td>只打印指定时间之后的日志（不同于 -d）</td></tr></tbody></table><p>例子：<code>adb logcat -t &#39;01-26 20:52:41.820&#39;</code></p><p><code>adb logcat -T &#39;01-26 20:52:41.820&#39;</code></p><table><thead><tr><th>时间格式</th></tr></thead><tbody><tr><td><strong>MM-DD hh:mm:ss.mmm</strong></td></tr><tr><td><strong>YYYY-MM-DD hh:mm:ss.mmm</strong></td></tr><tr><td><strong>ssss.mmm</strong></td></tr></tbody></table><h5 id="标签过滤"><a href="#标签过滤" class="headerlink" title="标签过滤"></a>标签过滤</h5><table><thead><tr><th>-s</th><th>设置默认的输出级别</th></tr></thead></table><p>语法：</p><p><code>adb logcat -s &lt;tag&gt;:&lt;priority&gt;</code></p><p><strong>tag</strong>：感兴趣的标签</p><p><strong>priority</strong>：优先级等于或者高于指定优先级的标签</p><h6 id="logcat日志优先级"><a href="#logcat日志优先级" class="headerlink" title="logcat日志优先级"></a>logcat日志优先级</h6><table><thead><tr><th>优先级</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>V</td><td>Verbose</td><td>详细，最低优先级</td></tr><tr><td>D</td><td>Debug</td><td>调试</td></tr><tr><td>I</td><td>Info</td><td>信息</td></tr><tr><td>W</td><td>Warn</td><td>警告</td></tr><tr><td>E</td><td>Error</td><td>错误</td></tr><tr><td>F</td><td>Fatal</td><td>致命</td></tr><tr><td>S</td><td>Silent</td><td>静默，最高优先级，不会打印任何信息</td></tr></tbody></table><h6 id="优先级设置说明"><a href="#优先级设置说明" class="headerlink" title="优先级设置说明"></a>优先级设置说明</h6><p>priority是最小的优先级，该标记标识的所有大于等于指定优先级的消息被写入日志。也可以在一个过滤器表达式中提供多个这样的过滤，它们之间用空格隔开。</p><p><img src="/images/2021/08/adb/01.png"></p><h6 id="Android-编程代码中使用日志"><a href="#Android-编程代码中使用日志" class="headerlink" title="Android 编程代码中使用日志"></a>Android 编程代码中使用日志</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Log 类允许您在 logcat 工具中显示的代码中创建日志条目。</span><br><span class="line">常用的日志记录方法包括：</span><br><span class="line">· Log.v(String, String)（详细）</span><br><span class="line">· Log.d(String, String)（调试）</span><br><span class="line">· Log.i(String, String)（信息）</span><br><span class="line">· Log.w(String, String)（警告）</span><br><span class="line">· Log.e(String, String)（错误）</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Log.i(<span class="string">&quot;MyActivity&quot;</span>, <span class="string">&quot;MyClass.getView() — get item number &quot;</span> + position);</span><br><span class="line">logcat 输出类似于如下：</span><br><span class="line">I/MyActivity( <span class="number">1557</span>): MyClass.getView() — get item number <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="输出格式控制"><a href="#输出格式控制" class="headerlink" title="输出格式控制"></a>输出格式控制</h4><table><thead><tr><th>-v &lt;format&gt;</th><th>设置日志消息的输出格式，默认值为 brief 格式有关支持的格式列表。</th></tr></thead></table><p><strong>输出格式</strong></p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>brief</td><td>显示优先级/标记以及发出消息的进程的 PID（默认格式）</td></tr><tr><td>process</td><td>仅显示 PID</td></tr><tr><td>tag</td><td>仅显示优先级/标记</td></tr><tr><td>raw</td><td>显示原始日志消息，不显示其他元数据字段</td></tr><tr><td>time</td><td>显示日期、调用时间、优先级/标记以及发出消息的进程的 PID。</td></tr><tr><td>threadtime</td><td>显示日期、调用时间、优先级、标记以及发出消息的线程的 PID 和 TID</td></tr><tr><td>long</td><td>显示所有元数据字段，并使用空白行分隔消息</td></tr></tbody></table><p><strong>输出对比</strong></p><table><thead><tr><th><strong>格式</strong></th><th><strong>日志 格式</strong>   <strong>元字段+日志消息</strong></th></tr></thead><tbody><tr><td><strong>默认</strong></td><td>03-22 14:47:38.220  630 1391 D asd_primary_out:L[0],R[0], continus 20 times!</td></tr><tr><td><strong>brief</strong></td><td>D/asd_primary_out( 630): L[0],R[0], continus 20 times!</td></tr><tr><td><strong>process</strong></td><td>D( 630)L[0],R[0], continus 20 times! (asd_primary_out)</td></tr><tr><td><strong>tag</strong></td><td>D/asd_primary_out: L[0],R[0], continus 20 times!</td></tr><tr><td><strong>raw</strong></td><td>L[0],R[0], continus 20 times!</td></tr><tr><td><strong>time</strong></td><td>03-22 14:47:38.220 D/asd_primary_out( 630):L[0],R[0], continus 20 times!</td></tr><tr><td><strong>threadtime</strong></td><td>03-22 14:47:38.220  630 1391 D asd_primary_out: L[0],R[0], continus 20 times!</td></tr><tr><td><strong>long</strong></td><td>[03-22 14:47:38.402 1364:11406 V/BroadcastQueue ] XXXXXX</td></tr></tbody></table><h4 id="统计LOG输出"><a href="#统计LOG输出" class="headerlink" title="统计LOG输出"></a>统计LOG输出</h4><table><thead><tr><th>-S, –statistics</th><th>输出统计量。统计缓冲区，个进程占用情况</th></tr></thead></table><p>输出内容：</p><p><img src="/images/2021/08/adb/02.png"></p><h4 id="日志存储"><a href="#日志存储" class="headerlink" title="日志存储"></a>日志存储</h4><p>转储到计算机：<code>adb logcat &gt; d:\log.txt</code></p><p>转储到手机：<code>adb shell logcat &gt; /sdcard/log.txt</code></p><p><strong>使用参数存储到手机</strong></p><table><thead><tr><th>参数选项</th><th>说明</th></tr></thead><tbody><tr><td>-f &lt;file&gt;</td><td>将日志消息输出写入 &lt;filename&gt;。默认值为 stdout</td></tr><tr><td>-r &lt;kbytes&gt;</td><td>每输出 &lt;kbytes&gt; 时旋转日志文件。默认值为 16。需要使用 -f 选项。</td></tr><tr><td>-z &lt;conut&gt;</td><td>设置最大tarballs(tar压缩包)数量，默认为5</td></tr><tr><td>-n &lt;count&gt;</td><td>设置最大的分割日志数：count 默认为 4。需要使用 <code>-r</code> 选项。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        Logcat 是一个adb的一个工具命令，用于转储系统消息日志。</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求与响应</title>
    <link href="https://www.lauyongyi.cn/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.html"/>
    <id>https://www.lauyongyi.cn/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.html</id>
    <published>2021-08-12T10:16:00.000Z</published>
    <updated>2021-08-12T10:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）–由客户端发送用来触发一个服务器上的动作；响应（responses）–来自服务器的应答。</p><a id="more"></a><p>HTTP 请求和响应具有相似的结构，由以下部分组成︰</p><ol><li>一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。</li><li>一个可选的HTTP头集合指明请求或描述消息正文。</li><li>一个空行指示所有关于请求的元数据已经发送完毕。</li><li>一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。</li></ol><p>起始行和 HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。</p><p><img src="/images/2021/08/http/04.png" alt="img"></p><h4 id="HTTP请求消息-Request"><a href="#HTTP请求消息-Request" class="headerlink" title="HTTP请求消息(Request)"></a>HTTP请求消息(Request)</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p><h5 id="请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。"><a href="#请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。" class="headerlink" title="请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。"></a><strong>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</strong></h5><p><img src="/images/2021/08/http/2.jpg" alt="img"></p><p>Http请求消息结构.png</p><ul><li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li></ul><h5 id="Get请求例子，使用Charles抓取的request："><a href="#Get请求例子，使用Charles抓取的request：" class="headerlink" title="Get请求例子，使用Charles抓取的request："></a><strong>Get请求例子，使用Charles抓取的request：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;562f25980001b1b106000338.jpg HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">Host img.mukewang.com</span><br><span class="line"></span><br><span class="line">User-Agent Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36</span><br><span class="line"></span><br><span class="line">Accept image&#x2F;webp,image&#x2F;*,*&#x2F;*;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">Referer http:&#x2F;&#x2F;www.imooc.com&#x2F;</span><br><span class="line"></span><br><span class="line">Accept-Encoding gzip, deflate, sdch</span><br><span class="line"></span><br><span class="line">Accept-Language zh-CN,zh;q&#x3D;0.8</span><br></pre></td></tr></table></figure><h5 id="第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本"><a href="#第一部分：请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本" class="headerlink" title="第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本."></a><strong>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</strong></h5><p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p><h5 id="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"><a href="#第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息" class="headerlink" title="第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息"></a><strong>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</strong></h5><p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p><h5 id="第三部分：空行，请求头部后面的空行是必须的"><a href="#第三部分：空行，请求头部后面的空行是必须的" class="headerlink" title="第三部分：空行，请求头部后面的空行是必须的"></a><strong>第三部分：空行，请求头部后面的空行是必须的</strong></h5><p>即使第四部分的请求数据为空，也必须有空行。</p><h5 id="第四部分：请求数据也叫主体，可以添加任意的其他数据。"><a href="#第四部分：请求数据也叫主体，可以添加任意的其他数据。" class="headerlink" title="第四部分：请求数据也叫主体，可以添加任意的其他数据。"></a><strong>第四部分：请求数据也叫主体，可以添加任意的其他数据。</strong></h5><p>这个例子的请求数据为空。</p><h5 id="POST请求例子，使用Charles抓取的request："><a href="#POST请求例子，使用Charles抓取的request：" class="headerlink" title="POST请求例子，使用Charles抓取的request："></a><strong>POST请求例子，使用Charles抓取的request：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F; HTTP1.1</span><br><span class="line"></span><br><span class="line">Host:www.wrox.com</span><br><span class="line"></span><br><span class="line">User-Agent:Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line"></span><br><span class="line">Content-Type:application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">Content-Length:40</span><br><span class="line"></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name&#x3D;Professional%20Ajax&amp;publisher&#x3D;Wiley</span><br></pre></td></tr></table></figure><p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。</p><p>第二部分：请求头部，第二行至第六行。</p><p>第三部分：空行，第七行的空行。</p><p>第四部分：请求数据，第八行。</p><h4 id="HTTP之响应消息-Response"><a href="#HTTP之响应消息-Response" class="headerlink" title="HTTP之响应消息(Response)"></a>HTTP之响应消息(Response)</h4><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p><h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</h5><p><img src="/images/2021/08/http/03.jpg" alt="img"></p><p>http响应消息格式.jpg</p><p><strong>例子</strong></p><p>HTTP/1.1 200 OK</p><p>Date: Fri, 22 May 2009 06:07:21 GMT</p><p>Content-Type: text/html; charset=UTF-8</p><html><head></head><body><!--body goes here--></body></html><h5 id="第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。"><a href="#第一部分：状态行，由HTTP协议版本号，-状态码，-状态消息-三部分组成。" class="headerlink" title="第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。"></a><strong>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</strong></h5><p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p><h5 id="第二部分：消息报头，用来说明客户端要使用的一些附加信息"><a href="#第二部分：消息报头，用来说明客户端要使用的一些附加信息" class="headerlink" title="第二部分：消息报头，用来说明客户端要使用的一些附加信息"></a><strong>第二部分：消息报头，用来说明客户端要使用的一些附加信息</strong></h5><p>第二行和第三行为消息报头，</p><p>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p><h5 id="第三部分：空行，消息报头后面的空行是必须的"><a href="#第三部分：空行，消息报头后面的空行是必须的" class="headerlink" title="第三部分：空行，消息报头后面的空行是必须的"></a><strong>第三部分：空行，消息报头后面的空行是必须的</strong></h5><h5 id="第四部分：响应正文，服务器返回给客户端的文本信息。"><a href="#第四部分：响应正文，服务器返回给客户端的文本信息。" class="headerlink" title="第四部分：响应正文，服务器返回给客户端的文本信息。"></a><strong>第四部分：响应正文，服务器返回给客户端的文本信息。</strong></h5><p>空行后面的html部分为响应正文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）–由客户端发送用来触发一个服务器上的动作；响应（responses）–来自服务器的应答。&lt;/p&gt;</summary>
    
    
    
    <category term="测试基础" scheme="https://www.lauyongyi.cn/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="功能测试" scheme="https://www.lauyongyi.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Http" scheme="https://www.lauyongyi.cn/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Postman简易教程</title>
    <link href="https://www.lauyongyi.cn/postman%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B.html"/>
    <id>https://www.lauyongyi.cn/postman%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B.html</id>
    <published>2021-08-11T10:10:00.000Z</published>
    <updated>2021-08-29T07:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    postman是一款跨平台的接口调试及测试工具，界面清晰，功能全面，上手简单，适合刚接触接口测试的初学者作为入门工具使用<a id="more"></a></p><h4 id="Postman的安装"><a href="#Postman的安装" class="headerlink" title="Postman的安装"></a>Postman的安装</h4><p>到postman官网的<a href="https://www.postman.com/downloads/">download</a>页面下载对应系统的版本就可以了</p><h4 id="Postman界面"><a href="#Postman界面" class="headerlink" title="Postman界面"></a>Postman界面</h4><p><img src="/images/2021/08/postman/01.png"></p><p>postman的工作界如上图：</p><p>其中红色框框所在的就是请求方法的选择，常用的请求方式如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似GET请求，只不过返货的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求。数据被包含在请求体中。</td></tr><tr><td>PUT</td><td>从客户端向服务器传送数据取代指定的文档内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面或者数据</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>PATCH</td><td>是对PUT方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><p>黑色框框，就是请求连接输入框。</p><p>send为请求发送按钮。</p><p>灰色的框框圈起来的大范围为功能区域，用来填写和修改键值对、请求体、请求头、测试方法等。</p><p>底部的response区域为请求响应区域，用于展示请求结果。</p><h4 id="一个GET简单的请求"><a href="#一个GET简单的请求" class="headerlink" title="一个GET简单的请求"></a>一个GET简单的请求</h4><p><a href="https://www.baidu.com/">百度</a>人人都爱的测速网站，这里也可以用来做为第一个简单的接口请求演示</p><p><img src="/images/2021/08/postman/02.png"></p><p>用于测试的时候，需要把https请求换成http，这样response里才有完整的内容返回</p><p>如上图所示，成功的请求到百度的页面内容，状态码为200，请求耗时177ms，大小297.75KB</p><h4 id="一个简单的POST请求"><a href="#一个简单的POST请求" class="headerlink" title="一个简单的POST请求"></a>一个简单的POST请求</h4><p><a href="https://www.apishop.net/">apishop</a>一个API接口网站，提供各种接口（收费服务），这里就用其中一个接口用来演示。（也可以自己搭建，按需选择）。</p><p><img src="/images/2021/08/postman/03.png"></p><p>此外postman支持将现有的接口请求转换成代码形式，如java、python、php、C#等。但断言无法被转换</p><h4 id="简易接口测试"><a href="#简易接口测试" class="headerlink" title="简易接口测试"></a>简易接口测试</h4><p>Postman提供了一些测试功能，可以在运行接口的同时，进行一写测试校验。可以前往Postman的<a href="https://learning.postman.com/docs/writing-scripts/test-scripts/">测试教程</a>查看详细的说明。</p><p>Postman接口测试的模块位于主界面的<code>Test</code>，见下图，红色箭头所指就是Postman提供的基本测试方法，可以满足日常的测试需求</p><p><img src="/images/2021/08/postman/04.jpg"></p><p>例子：</p><p>使用v2ex的节点来举例</p><p>链接如下：<code>https://www.v2ex.com/api/nodes/show.json?name=python</code></p><p>判断示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = <span class="built_in">JSON</span>.parse(responseBody);</span><br><span class="line">pm.test(<span class="string">&quot;Status code is 200&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.test(<span class="string">&quot;返回值的name必须等于python&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.expect(jsonData.name).to.eql(<span class="string">&quot;python&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>编写好之后，点击运行，就可以看到测试结果</p><p><img src="/images/2021/08/postman/05.png"></p><p><code>Test</code>脚本基于JavaScript语言，使用postman自带的<code>Test</code>模板（可以减少编写断言代码了）， 可以快速的生成用例。</p><table><thead><tr><th align="left">模板</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">clear a global variable</td><td align="left">清除全局变量</td><td align="left">pm.globals.unset(“variable_key”);</td></tr><tr><td align="left">Clear an environment variable</td><td align="left">清除一个环境变量</td><td align="left">pm.environment.unset(“variable_key”);</td></tr><tr><td align="left">get a global variable</td><td align="left">得到一个全局变量</td><td align="left">pm.globals.get(“variable_key”);</td></tr><tr><td align="left">get a variable</td><td align="left">得到一个变量</td><td align="left">pm.variables.get(“variable_key”);</td></tr><tr><td align="left">Get an environment variable</td><td align="left">得到一个环境变量</td><td align="left">pm.environment.get(“variable_key”);</td></tr><tr><td align="left">response body:contains string</td><td align="left">检查response body包含字符串</td><td align="left">pm.test(“Body matches string”, function () { pm.expect(pm.response.text()).to.include(“string_you_want_to_search”); });</td></tr><tr><td align="left">response body:convert XML body to a JSON object</td><td align="left">response body：将XML转换为JSON对象</td><td align="left">var jsonObject = xml2Json(responseBody);</td></tr><tr><td align="left">response body:is equal to a string</td><td align="left">检查响应体等于一个字符串</td><td align="left">pm.test(“Body is correct”, function () { pm.response.to.have.body(“response_body_string”); });</td></tr><tr><td align="left">response body:JSON value check</td><td align="left">检查response body中JSON某字段值</td><td align="left">pm.test(“Your test name”, function () { var jsonData = pm.response.json(); pm.expect(jsonData.value).to.eql(100); });</td></tr><tr><td align="left">response headers:content-Type header check</td><td align="left">检查content-Type是否包含在header返回</td><td align="left">pm.test(“Content-Type is present”, function () { pm.response.to.have.header(“Content-Type”); });</td></tr><tr><td align="left">response time is than 200ms</td><td align="left">响应时间超过200ms</td><td align="left">pm.test(“Response time is less than 200ms”, function () { pm.expect(pm.response.responseTime).to.be.below(200); });</td></tr><tr><td align="left">send s request</td><td align="left">发送一个请求</td><td align="left">pm.sendRequest(“<a href="https://postman-echo.com/get&quot;">https://postman-echo.com/get&quot;</a>, function (err, response) { console.log(resp onse.json()); });</td></tr><tr><td align="left">set a global variable</td><td align="left">设置一个全局变量</td><td align="left">pm.globals.set(“variable_key”, “variable_value”);</td></tr><tr><td align="left">set an environment variable</td><td align="left">设置一个环境变量</td><td align="left">pm.environment.set(“variable_key”, “variable_value”);</td></tr><tr><td align="left">status code:Code is 200</td><td align="left">状态码：代码是200</td><td align="left">pm.test(“Status code is 200”, function () { pm.response.to.have.status(200); });</td></tr><tr><td align="left">status code:code name has string</td><td align="left">状态码：代码中有指定字符串</td><td align="left">pm.test(“Status code name has string”, function () { pm.response.to.have.status(“Created”); });</td></tr><tr><td align="left">status code：successful POST request</td><td align="left">状态码：成功的post请求</td><td align="left">pm.test(“Successful POST request”, function () { pm.expect(pm.response.code).to.be.oneOf([201,202]); });</td></tr><tr><td align="left">use tiny validator for JSON data</td><td align="left">为json数据使用tiny验证器</td><td align="left">var schema = { “items”: { “type”: “boolean” } }; var data1 = [true, false]; var data2 = [true, 123]; pm.test(‘Schema is valid’, function() { pm.expect(tv4.validate(data1, schema)).to.be.true; pm.expect(tv4.validate(data2, schema)).to.be.true; });</td></tr></tbody></table><p>常见模板用例：</p><ul><li>状态码判断</li><li>响应文本判断</li><li>json值判断</li><li>header判断</li><li>响应时间判断</li></ul><h4 id="变量设置"><a href="#变量设置" class="headerlink" title="变量设置"></a>变量设置</h4><p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p><p>对我们做接口测试来说，又是一个非常重要的功能 。</p><p>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</p><ul><li>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</li><li>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</li><li>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</li></ul><p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p><p>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</p><ol><li>定义变量（设置变量）</li><li>获取变量（访问变量）</li></ol><h5 id="全局和环境变量"><a href="#全局和环境变量" class="headerlink" title="全局和环境变量"></a>全局和环境变量</h5><p>旧版本的postman，在右上角有一个齿轮的标志，点击后弹出界面，就可以根据需求定义全局变量或者环境变量了。</p><p>但在新版本中，就需要点击眼睛的标志</p><p><img src="/images/2021/08/postman/06.jpg"></p><p>Environment：环境变量</p><p>Globals：全局变量</p><p>点击<code>adb</code>后会进入一个编辑页面，如下图</p><p><img src="/images/2021/08/postman/07.png"></p><p>New Environment ：环境变量的名称，可以随意命名<br>VARIAVLE: 变量名<br>INITIAL VALUE: 共享初始值, 用于团队共享时供别人使用的默认值<br>CURRENT VALUE: 当前值, 自己当前使用的变量值(一般我们只用设置这个值即可)<br>Perisit All: 保持所有, 将当前自己使用的值(CURRENT VALUE)替换所有的初始值<br>Reset All: 重置所有, 将当前所有的CURRENT VALUE重置为与当前初始值一样</p><p>添加完成后 ，点击界面上的<code>Save</code>或者快捷键<code>Ctrl + s</code>保存即可。</p><h6 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h6><p>点击眼睛旁边的下拉菜单就可以看到刚刚添加的环境变量</p><p><img src="/images/2021/08/postman/08.jpg"></p><p>点击需要使用的环境变量即可，然后在需要引用的位置上使用固定格式<code>&#123;&#123;变量名&#125;&#125;</code>即可。</p><h5 id="集合变量设置"><a href="#集合变量设置" class="headerlink" title="集合变量设置"></a>集合变量设置</h5><p>点击一个集合（文件夹）的菜单，选择<code>Edit</code></p><p>就会进入到集合（文件夹）的编辑页面，如下图</p><p><img src="/images/2021/08/postman/10.png"></p><p>在这里，可以设置这个集合通用的请求参数，前置方法、断言和变量。</p><p>添加完成后，在运行该集合的接口时，可以直接调用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    postman是一款跨平台的接口调试及测试工具，界面清晰，功能全面，上手简单，适合刚接触接口测试的初学者作为入门工具使用</summary>
    
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="接口测试" scheme="https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口测试</title>
    <link href="https://www.lauyongyi.cn/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.html"/>
    <id>https://www.lauyongyi.cn/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.html</id>
    <published>2021-08-10T15:00:00.000Z</published>
    <updated>2021-08-11T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="什么是接口和接口测试"><a href="#什么是接口和接口测试" class="headerlink" title="什么是接口和接口测试"></a>什么是接口和接口测试</h4><p>​    接口（软件类接口）是指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。</p><p>​    接口测试，顾名思义：是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖关系。<a id="more"></a></p><p>​    其中接口协议分为HTTP,WebService,Dubbo,Thrift,Socket等类型，测试类型又主要分为功能测试，性能测试，稳定性测试，安全性测试等。</p><p>​    在分层测试的“金字塔”模型中，接口测试属于第二层服务集成测试范畴。相比UI层（主要是WEB或APP）自动化测试而言，接口自动化测试收益更大，且容易实现，维护成本低，有着更高的投入产出比，是每个公司开展自动化测试的首选。</p><p>![](/images/2021/08/Interface Test/1.png)</p><h4 id="接口测试的意义"><a href="#接口测试的意义" class="headerlink" title="接口测试的意义"></a>接口测试的意义</h4><ol><li><p>更早的发现问题<br>随着敏捷测试的盛行，我们都知道测试工作要尽早的介入到项目开发周期中，因为越早的发现 bug，修复的成本就越低。<br>然而功能测试一般都要等到系统提供可测试的 UI 界面后才能进行，单元测试又要求较高的专业性和人力成本，所以选择接口测试来更早的介入测试。<br>接口测试可以在功能界面未开发出来之前对系统的接口进行测试，从而更早的发现总是并以更低的成本修复问题。</p></li><li><p>缩短产品周期<br>接口测试更早的介入，可以更早的发现并解决 bug，从而使得留到后期功能测试阶段的 bug 数量减少，最终缩短整个项目的上线时间，有助于实现敏捷测试。</p></li><li><p>发现更底层的问题<br>系统中的有些 bug 如果想通过 UI 层功能测试会比较困难，或者构造测试数据和测试条件非常复杂，而通过接口测试可以更简单、更全面的覆盖到底层的代码逻辑，从而发现一些隐藏 bug。</p></li></ol><p>尤其是一些异常的、极端的情况，可以用接口测试很容易的验证。</p><h4 id="常见的接口测试工具"><a href="#常见的接口测试工具" class="headerlink" title="常见的接口测试工具"></a>常见的接口测试工具</h4><ul><li>postman： 推荐。基本功能免费。最简单的基于http接口的调试和测试工具;</li><li>jmeter：后置处理器配合断言基本上可以满足接口测试需求，就是测试报告要做二次开发</li><li>自己撸代码：推荐。配合类似xunit测试框架，基本可以满足一切需求；</li><li>soapui: 收费的；</li><li>insomnia：强力推荐。postman的弱化版，基本功能免费，重要的是工具代码开源，可以自己改；</li><li>apifox：一款适用于 Mac 的API接口调试应用。官方介绍 Apifox = Postman + Swagger + Mock。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是接口和接口测试&quot;&gt;&lt;a href=&quot;#什么是接口和接口测试&quot; class=&quot;headerlink&quot; title=&quot;什么是接口和接口测试&quot;&gt;&lt;/a&gt;什么是接口和接口测试&lt;/h4&gt;&lt;p&gt;​    接口（软件类接口）是指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。&lt;/p&gt;
&lt;p&gt;​    接口测试，顾名思义：是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管理过程，以及相互逻辑依赖关系。</summary>
    
    
    
    <category term="自动化测试" scheme="https://www.lauyongyi.cn/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="接口测试" scheme="https://www.lauyongyi.cn/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>monkey命令</title>
    <link href="https://www.lauyongyi.cn/Monkey%E5%91%BD%E4%BB%A4.html"/>
    <id>https://www.lauyongyi.cn/Monkey%E5%91%BD%E4%BB%A4.html</id>
    <published>2021-08-07T14:29:00.000Z</published>
    <updated>2021-08-08T07:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>monkey 是一个运行在模拟器或者Android设备中可以产生类似用户点击、触摸、手势以及一些系统级的伪随机事件流的程序。</p><a id="more"></a><h4 id="为什么要用monkey？"><a href="#为什么要用monkey？" class="headerlink" title="为什么要用monkey？"></a>为什么要用monkey？</h4><p>Monkey=猴子，就是像猴子一样的乱点。</p><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p> 测试软件的稳定性，健壮性，压力。</p><h4 id="monkey的使用"><a href="#monkey的使用" class="headerlink" title="monkey的使用"></a>monkey的使用</h4><h5 id="monkey的基本用法"><a href="#monkey的基本用法" class="headerlink" title="monkey的基本用法"></a>monkey的基本用法</h5><p><code>adb shell monkey &lt;event&gt;</code></p><p>这里的<code>&lt;event&gt;</code>是指随机发送的事件数。</p><p>例如：发送200个随机事件，只需要运行：<code>adb shell monkey 200</code>。</p><p>运行结果如下图所示：</p><p><img src="/images/2021/08/monkey/01.png"></p><p>monkey正常结束（即成功运行完成）后也不会停止启动的进程，设备只是在结束事件之后，简单地保持在最后那个状态下，而不会回到主界面。</p><h6 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h6><p><code>adb shell monkey -h</code>monkey的帮助文档，里面详细的说明了monkey的用法。</p><p><img src="/images/2021/08/monkey/02.png"></p><h5 id="monkey命令参数"><a href="#monkey命令参数" class="headerlink" title="monkey命令参数"></a>monkey命令参数</h5><p>monkey自带了多个可选参数，可以满足不同场景下的使用需求，基础用法是：</p><p><code>adb shell monkey [options] &lt;events&gt;</code></p><p>这里的<code>[options]</code>是指monkey可传入的参数</p><h6 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h6><p>运行monkey时，程序可能出现异常，这时候就需要添加日志参数 <code>-v</code>，</p><p><strong>-v</strong>：打印出日志信息，每一个-v将增加反馈信息的级别。-v越多，日志越详细，不过目前最多支持3个。</p><p><code>adb shell monkey -v -v -v 200</code></p><p>-v：除启动提示，测试完成和最终结果外提供较少的信息。</p><p>-v -v：提供较详细的测试信息。</p><p>-v -v -v：提供更详细的信息，如测试中被选中或微被选中的Acticity等信息。</p><h5 id="事件类参数"><a href="#事件类参数" class="headerlink" title="事件类参数"></a>事件类参数</h5><h6 id="随机生成器"><a href="#随机生成器" class="headerlink" title="随机生成器"></a>随机生成器</h6><p>在执行monkey时，如果希望重复执行之前的随机操作，可以使用<code>-s</code>参数。</p><p><code>adb shell monkey -s&lt;seed&gt; &lt;events&gt;</code></p><p>-s 后接随机数生成器的seed值。可以是随机的任意整数。</p><h6 id="延迟时间"><a href="#延迟时间" class="headerlink" title="延迟时间"></a>延迟时间</h6><p>为了更真实的模拟用户可能的操作，执行monkey的时候，可以带上延迟时间：即每个指令之间的间隔时间。</p><p> <code>adb shell monkey --throttle &lt;milliseconds&gt;</code></p><p>–throttle后面接时间，单位ms。</p><h6 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h6><p><code>adb shell monkey --ptc-touch &lt;percent&gt;</code></p><p>–ptc-touch：触摸事件。</p><p>说明：触摸事件泛指在某一位置发生的一个down-up事件。</p><h6 id="动作事件"><a href="#动作事件" class="headerlink" title="动作事件"></a>动作事件</h6><p><code>adb shell monkey --ptc-motion &lt;percent&gt;</code></p><p>–ptc-motion：动作事件。</p><p>说明：动作事件泛指从某一位置按下后经过一系列随机事件后弹起的操作。包括但不限于手势操作。</p><h6 id="轨迹球事件"><a href="#轨迹球事件" class="headerlink" title="轨迹球事件"></a>轨迹球事件</h6><p><code>adb shell monkey --ptc-trackball &lt;percent&gt;</code></p><p>–ptc-trackball：接轨迹球事件。</p><p>说明：轨迹球事件包括一系列的随机移动，以及偶尔跟随在移动后面的点击事件。</p><h6 id="基本导航事件"><a href="#基本导航事件" class="headerlink" title="基本导航事件"></a>基本导航事件</h6><p><code>adb shell monkey --ptc-nav &lt;percent&gt;</code></p><p>–ptc-nav：基本导航事件。</p><p>说明：</p><p>基本导航事件是指来自方向输入设备的上、下、左、右事件。</p><h6 id="主要导航事件"><a href="#主要导航事件" class="headerlink" title="主要导航事件"></a>主要导航事件</h6><p><code>adb shell monkey --ptc-majornav &lt;percent&gt;</code></p><p>–ptc-majornav：主要导航事件。</p><p>说明：</p><p>主要导航事件是指引发图形界面的一些动作，如返回、确认、菜单键等。</p><h6 id="系统按键事件"><a href="#系统按键事件" class="headerlink" title="系统按键事件"></a>系统按键事件</h6><p><code>adb shell monkey --pct-syskeys &lt;percent&gt;</code></p><p>–pct-syskeys：系统按键事件</p><p>说明：系统按键事件指的是供系统使用的保留按键：如Home键、Back键、拨号键、挂断键、音量键等。</p><h6 id="app启动事件"><a href="#app启动事件" class="headerlink" title="app启动事件"></a>app启动事件</h6><p><code>adb shell monkey --pct-appswitch &lt;percent&gt;</code></p><p>–pct-appswitch：app启动事件</p><p>说明：app启动事件，俗称打开应用，通过调用startActivity()方法，最大限度的打开package下的所有应用。</p><h6 id="其他类型事件"><a href="#其他类型事件" class="headerlink" title="其他类型事件"></a>其他类型事件</h6><p><code>adb shell monkey --pct-anyevent &lt;percent&gt;</code></p><p>–pct-anyevent：其他类型事件</p><p>说明：其他类型事件包含除了上述几个事件外的所有事件。</p><h5 id="monkey约束类命令"><a href="#monkey约束类命令" class="headerlink" title="monkey约束类命令"></a>monkey约束类命令</h5><p>约束类命令可以将monkey的运行范围限制在特定范围，比如特定的包或者类。</p><h6 id="包名限制"><a href="#包名限制" class="headerlink" title="包名限制"></a>包名限制</h6><p><code>adb shell monkey -p &lt;PackageName&gt; &lt;events&gt;</code></p><p><code>-p</code>后面接一个或者多个包名，<code>-p &lt;PackageName&gt; </code>为固定形式，每个包名前都必须带 -p。</p><h6 id="类限制"><a href="#类限制" class="headerlink" title="类限制"></a>类限制</h6><p><code>adb shell monkey -c &lt;main-category&gt; &lt;events&gt;</code></p><p><code>-c</code>后面接一个或者多个类名，设置后monkey只允许系统启动这些类别中某个类别列出的Activity。同<code>-p</code>一样，一个<code>-c</code>带一个类名。如果不指定任何类别，monkey将选择Intent.CATEGORY_LAUNCHER和Intent.CATEGORY_monkey里的Activity。</p><p>例子：<code>adb shell monkey -c Intent.CATEGORY_LAUNCHER 1000</code></p><h5 id="调试类命令"><a href="#调试类命令" class="headerlink" title="调试类命令"></a>调试类命令</h5><p>通过调试类命令，可以对monkey进行一些简单调试，方便快速的定位monkey运行中遇到的问题问题。</p><h6 id="跳转监视命令"><a href="#跳转监视命令" class="headerlink" title="跳转监视命令"></a>跳转监视命令</h6><p><code>adb shell monkey --dbg-no-enents &lt;events&gt;</code></p><p>–dbg-no-events：在设置此选项后，monkey将进行初始启动，进入到某个测试Activity中不会进一步生成事件。</p><p>为了更好地跟踪，一般该选项会与<code>-v（日志）</code>、<code>-p&lt;allowed-package-name&gt;（包约束）</code>和<code>--throttle&lt;milliseconds&gt;（延迟）</code>等联合使用（延迟至少30s），从而提供一个可监视应用程序所调用包之间转换的环境。</p><h6 id="分析报告生成"><a href="#分析报告生成" class="headerlink" title="分析报告生成"></a>分析报告生成</h6><p><code>adb shell monkey --hprof &lt;events&gt;</code></p><p>–hprof：在设置此选项后，将在monkey事件序列前后立即生成profilfing report（分析报告）。该选项将在data/misc中生成5MB左右大小的文件，慎用！</p><h6 id="忽略crashes"><a href="#忽略crashes" class="headerlink" title="忽略crashes"></a>忽略crashes</h6><p><code>adb shell monkey --ignore-crashes &lt;events&gt;</code></p><p>–ignore-crashes：在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。</p><h6 id="忽略超时"><a href="#忽略超时" class="headerlink" title="忽略超时"></a>忽略超时</h6><p><code>adb shell monkey --ignore-timeouts &lt;events&gt;</code></p><p>–ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANP，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。</p><h6 id="忽略权限错误"><a href="#忽略权限错误" class="headerlink" title="忽略权限错误"></a>忽略权限错误</h6><p><code>adb shell monkey --ignore-security-exceptions &lt;events&gt;</code></p><p>–ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。</p><h6 id="忽略报错"><a href="#忽略报错" class="headerlink" title="忽略报错"></a>忽略报错</h6><p><code>adb shell moneky --kill-process-after-error &lt;events&gt;</code></p><p>–kill-process-after-error：在设置此选项后，当monkey因为应用程序发生错误而停止时，将会通知系统停止发生错误的进程。如果不设置此选项，在monkey停止时发生错误的应用程序将继续处于运行状态。</p><h6 id="错误汇报"><a href="#错误汇报" class="headerlink" title="错误汇报"></a>错误汇报</h6><p><code>adb shell monkey --monitor-native-crashes &lt;events&gt;</code></p><p>–monitor-native-crashes：在设置此选项后，monkey运行时native code(本地代码)的崩溃事件将被监视并报告。如果不设置此选项，将不会监视此类事件。</p><p><em>如果此时还设置了–kill-process-after-error命令，此类崩溃（system native code）系统也将停止运行。</em></p><h6 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h6><p><code>adb shell monkey --wait-dbg &lt;events&gt;</code></p><p>–wait-dbg：在设置此选项后，将暂停执行中的monkey，直到有调试器与它连接。</p><h5 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell  monkey -v -v -p com.test.testpackage --monitor-native-crashes --ignore-security-exceptions --kill-process-after-error --pct-trackball 0 --pct-nav 0 --pct-anyevent 0 --pct-appswitch 0 --pct-flip 0 --pct-majornav 10 --pct-touch 44 --pct-motion 30 --throttle 500 6000000 &gt;/sdcard/log/monkey_test.txt &amp;logcat -v time &gt; /sdcard/log/logcat.txt</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>monkey监控并特殊处理的3个事件如下。<br>1）如果指定测试包，限制测试在指定的包中。<br>2）如果应用crash或存在未捕获的异常，monkey停止并报告错误。<br>3）如果应用产生ANR（Application Not Responding）错误，monkey停止并报告错误。产生ANR的两个条件如下。<br>❑ 线程响应超过5s。<br>❑ HandleMessage回调函数超过10s。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;monkey 是一个运行在模拟器或者Android设备中可以产生类似用户点击、触摸、手势以及一些系统级的伪随机事件流的程序。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>安卓界面渲染检查</title>
    <link href="https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A3%80%E6%9F%A5.html"/>
    <id>https://www.lauyongyi.cn/%E5%AE%89%E5%8D%93%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A3%80%E6%9F%A5.html</id>
    <published>2021-07-30T15:00:00.000Z</published>
    <updated>2021-07-31T05:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。</p><a id="more"></a><p>​    Android 上的“设置”应用包含一个名为<strong>开发者选项</strong>的设置，您可以使用该屏幕配置一些系统行为来帮助您分析和调试应用性能。例如，您可以启用 USB 调试、捕获错误报告、启用点按的视觉反馈、在窗口 surface 更新时刷写 surface、使用 GPU 渲染 2D 图形，等等。</p><h4 id="开启GPU渲染分析"><a href="#开启GPU渲染分析" class="headerlink" title="开启GPU渲染分析"></a>开启GPU渲染分析</h4><p>​    GPU 渲染模式分析工具可以显示渲染流水线的每个阶段渲染前一帧所用的相对时间。这些信息有助于您确定流水线中的瓶颈所在，从而了解应该优化哪些方面来提高应用的渲染性能。</p><ol><li>在设备上，转到 <strong>Settings（设置）</strong> 点击 <strong>Developer Options（开发者选项）</strong>。</li><li>在 <strong>Monitoring（监控）</strong> 部分，选择 <strong>Profile GPU Rendering（HWUI呈现模式分析）</strong>。</li><li>在“HWUI呈现模式分析”对话框中，选择<strong>在屏幕上显示为竖条</strong>，以在设备的屏幕上叠加图形。</li><li>打开您要分析的应用。</li></ol><h5 id="在屏幕显示成条形图"><a href="#在屏幕显示成条形图" class="headerlink" title="在屏幕显示成条形图"></a>在屏幕显示成条形图</h5><p>​    染模式分析工具以图表（以颜色编码的直方图）的形式显示各个阶段及其相对时间。图1显示了此图表的一个示例。</p><p><img src="/images/2021/07/HWUI/01.png" alt="图1"></p><p>下面是有关输出的几点注意事项：</p><ul><li><p>对于每个可见应用，该工具将显示一个图形。</p></li><li><p>沿水平轴的每个竖条代表一个帧，每个竖条的高度表示渲染该帧所花的时间（以毫秒为单位）。</p></li><li><p>水平绿线表示 16 毫秒。要实现每秒 60 帧，代表每个帧的竖条需要保持在此线以下。当竖条超出此线时，可能会使动画出现暂停。</p></li><li><p>该工具通过加宽对应的竖条并降低透明度来突出显示超出 16 毫秒阈值的帧。</p></li><li><p>每个竖条都有与渲染管道中某个阶段对应的彩色区段。区段数因设备的 API 级别不同而异。</p></li></ul><h6 id="渲染和流畅概念"><a href="#渲染和流畅概念" class="headerlink" title="渲染和流畅概念"></a>渲染和流畅概念</h6><p>​    Google 定义：界面呈现是指从应用生成帧并将其显示在屏幕上的动作。要确保用户能够流畅地与应用互动，应用呈现每帧的时间不应超过 16ms，以达到每秒 60 帧的呈现速度（为什么是 60fps？）。<br>如果应用存在界面呈现缓慢的问题，系统会不得不跳过一些帧，这会导致用户感觉应用不流畅，我们将这种情况称为卡顿。</p><h6 id="为什么是-60fps-或-16ms？"><a href="#为什么是-60fps-或-16ms？" class="headerlink" title="为什么是 60fps 或 16ms？"></a>为什么是 60fps 或 16ms？</h6><p>​    16ms 意味着 1000/60hz，相当于 60fps。这是因为人眼与大脑之间的协作无法感知超过 60fps 的画面更新。12fps 大概类似手动快速翻动书籍的帧率， 这明显是可以感知到不够顺滑的。24fps 使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。 24fps 是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。 但是低于 30fps 是 无法顺畅表现绚丽的画面内容的，此时就需要用到 60fps 来达到想要的效果，超过 60fps 就没有必要了。如果我们的应用没有在 16ms 内完成屏幕刷新的全部逻辑操作，就会发生卡顿。</p><p>渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。图 2 说明了显示的每种颜色所代表的含义。</p><p><img src="/images/2021/07/HWUI/02.png" alt="图2"></p><p>图3介绍了使用运行 Android 6.0 及更高版本的设备时分析器输出中某个竖条的每个区段</p><p><img src="/images/2021/07/HWUI/03.png" alt="图3"></p><h5 id="使用ADB命令分析"><a href="#使用ADB命令分析" class="headerlink" title="使用ADB命令分析"></a>使用ADB命令分析</h5><p><strong>先开坑，后面再填</strong></p><h4 id="呈现-GPU-过度绘制"><a href="#呈现-GPU-过度绘制" class="headerlink" title="呈现 GPU 过度绘制"></a>呈现 GPU 过度绘制</h4><p><strong>过渡绘制</strong></p><p>所谓过渡绘制，就是指一帧画面上，某一个像素区域被绘制了多次。</p><p><strong>危害</strong></p><p>过度绘制会浪费大量的CPU以及GPU资源，最直观的影响就是会导致APP卡顿。</p><p>呈现 GPU 过度绘制是开发者选项中的另一个功能，通过对界面进行彩色编码来帮助识别过度绘制。当应用在同一帧中多次绘制相同像素时，便会发生过度绘制。</p><p>开启步骤：</p><ol><li>在设备上，转到 <strong>Settings（设置）</strong> 点击 <strong>Developer Options（开发者选项）</strong>。</li><li>向下滚动到<strong>硬件加速渲染</strong>部分，并选择<strong>调试 GPU 过度绘制</strong>。</li><li>在<strong>调试 GPU 过度绘制</strong>对话框中，选择<strong>显示过度绘制区域</strong>。</li></ol><p><img src="/images/2021/07/HWUI/04.png" alt="图4"></p><p>Android 会按照如下图所示的方式为界面元素着色，以确定过度绘制的次数：</p><p><img src="/images/2021/07/HWUI/05.png" alt="图5"></p><p><strong>这些颜色是半透明的，因此在屏幕上看到的确切颜色取决于界面的内容。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    Android 包含一些设备上的开发者选项，可帮助您直观地查看您的应用可能会在何处遇到界面渲染问题，如执行不必要的渲染工作，或执行长时间的线程和 GPU 操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用的Git命令</title>
    <link href="https://www.lauyongyi.cn/%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4.html"/>
    <id>https://www.lauyongyi.cn/%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4.html</id>
    <published>2021-07-23T14:37:00.000Z</published>
    <updated>2021-08-08T09:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。</p><p>git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自<a href="https://zh.wikipedia.org/wiki/Git">wikipedia</a>。</p><a id="more"></a><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><h5 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h5><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#39;git&#39; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>如果碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h5 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h5><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><h5 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h5><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/%E3%80%82">http://brew.sh/。</a></p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>（windows推荐使用Git自带的命令行工具：GitBash，可以避免很多问题。其次文件夹尽量避免使用中文或特殊符号）</p><p>​    因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h4 id="常用的Git命令"><a href="#常用的Git命令" class="headerlink" title="常用的Git命令"></a>常用的Git命令</h4><h5 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Documents % mkdir GitEx  #创建一个目录</span><br><span class="line">Documents % cd GitEx  #进入到目录</span><br><span class="line">GitEx % git init  #把这个目录变成Git可以管理的仓库</span><br></pre></td></tr></table></figure><p>​    执行之后，瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hint: Using &#x27;master&#x27; as the name for the initial branch. This default branch name</span><br><span class="line">hint: is subject to change. To configure the initial branch name to use in all</span><br><span class="line">hint: of your new repositories, which will suppress this warning, call:</span><br><span class="line">hint: </span><br><span class="line">hint: git config --global init.defaultBranch &lt;name&gt;</span><br><span class="line">hint: </span><br><span class="line">hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; and</span><br><span class="line">hint: &#x27;development&#x27;. The just-created branch can be renamed via this command:</span><br><span class="line">hint: </span><br><span class="line">hint: git branch -m &lt;name&gt;</span><br><span class="line">Initialized empty Git repository in /Users/tinenlau/Documents/GitEx/.git/</span><br></pre></td></tr></table></figure><p>​    通过<code>ls -a</code>可以看到目录结构。如果没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GitEx % ls -a</span><br><span class="line">....git</span><br></pre></td></tr></table></figure><h5 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h5><p>​    把一个文件放入到 “GitEx” 目录下，一定要放到 “GitEx” 目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>​    第一步：用命令<code>git add</code>告诉Git，把文件添加到仓库，例如一张图片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git add wallhaven-57ge21.jpeg</span><br></pre></td></tr></table></figure><p>​    执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>​    第二步：用命令<code>git commit</code>告诉Git，把文件提交到仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git commit -m &quot;add new pic&quot;</span><br><span class="line">[master (root-commit) 1983ca0] add new pic</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 wallhaven-57ge21.jpeg</span><br></pre></td></tr></table></figure><p>​    简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>​    嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p>​    <code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的wallhaven-57ge21.jpeg文件）；<code>0 insertions</code>：没有插入内容（因为上传的是图片）。</p><p>​    为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git add file1.txt</span><br><span class="line">GitEx % git add file2.txt file3.txt</span><br><span class="line">GitEx % git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><p>总结一下</p><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><h5 id="Git版本管理"><a href="#Git版本管理" class="headerlink" title="Git版本管理"></a>Git版本管理</h5><p>​    在Git中，用<code>git log</code>命令可以显示从最近到最远的提交日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git log                     </span><br><span class="line">commit 81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master)</span><br><span class="line">Author:  &lt;&gt;</span><br><span class="line">Date:   Sun Jul 25 20:41:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    版本演示管理</span><br><span class="line"></span><br><span class="line">commit 3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774</span><br><span class="line">Author:  &lt;&gt;</span><br><span class="line">Date:   Sun Jul 25 20:33:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    Git说明</span><br><span class="line"></span><br><span class="line">commit 1983ca011b008cda324a3c5d6da21571c8825857</span><br><span class="line">Author:  &lt;&gt;</span><br><span class="line">Date:   Fri Jul 23 23:41:13 2021 +0800</span><br></pre></td></tr></table></figure><p>​    如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git log --pretty=oneline</span><br><span class="line">81eca4214c46c22a7bc237e5055e52ce43053a32 (HEAD -&gt; master) 版本演示管理</span><br><span class="line">3dbfc11c54ffcc34eb4a8b8f0f7b952438ecc774 Git说明</span><br><span class="line">1983ca011b008cda324a3c5d6da21571c8825857 add new pic</span><br></pre></td></tr></table></figure><p>​    <strong>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</strong></p><p>​    要把仓库还原到上一版本，就必须先知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>​    要把当前版本回退到上一个版本就可以使用<code>git reset</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git reset --hard HEAD^</span><br><span class="line">HEAD is now at 3dbfc11 Git说明</span><br><span class="line">GitEx % git reset --hard HEAD^</span><br><span class="line">HEAD is now at 1983ca0 add new pic</span><br></pre></td></tr></table></figure><p>​    查看文件夹的内容，从返回的结果来看，新建的文件夹被删除了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitEx % ls -a</span><br><span class="line">..git</span><br><span class="line">..wallhaven-57ge21.jpeg</span><br></pre></td></tr></table></figure><p>​    用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git log</span><br><span class="line">commit 1983ca011b008cda324a3c5d6da21571c8825857 (HEAD -&gt; master)</span><br><span class="line">Author:  &lt;&gt;</span><br><span class="line">Date:   Fri Jul 23 23:41:13 2021 +0800</span><br><span class="line"></span><br><span class="line">    add new pic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    新提交的版本已经看不到了。但在不关闭命令行窗口的前提下，还是可以还原的，方法是：找到那个需要还原版本的<code>commit id</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git reset --hard 81eca4214c46c22a</span><br><span class="line">HEAD is now at 81eca42 版本演示管理</span><br><span class="line">tinenlau@TinendeAir GitEx % ls -a</span><br><span class="line">..gitwallhaven-57ge21.jpeg</span><br><span class="line">..readme.rtf</span><br></pre></td></tr></table></figure><p>​    版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 </p><p>总结一下：</p><ul><li><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p></li><li><p>用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h5 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h5><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。  所以，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>对工作区进行了文件操作，然后用<code>git status</code>查看一下状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> GitEx % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">deleted:    readme.rtf</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">newreadme.txt</span><br><span class="line">readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>Git非常清楚的显示了：<code>readme.rtf</code>被删除了，新增了两个文件，状态为<code>Untracked</code>即：没有被添加过。</p><p>分别使用<code>git add</code>添加新文件，然后使用<code>git rm</code>删除状态为delete的文件，然后再次使用<code>git status</code>查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git status           </span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">new file:   newreadme.txt</span><br><span class="line">deleted:    readme.rtf</span><br><span class="line">new file:   readme.txt</span><br></pre></td></tr></table></figure><p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git commit -m &quot;修改和新增多个文件&quot; </span><br><span class="line">[master 892a394] 修改和新增多个文件</span><br><span class="line"> 3 files changed, 2 insertions(+), 10 deletions(-)</span><br><span class="line"> create mode 100644 newreadme.txt</span><br><span class="line"> delete mode 100644 readme.rtf</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line">tinenlau@TinendeAir GitEx % git status                         </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h5 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h5><p>人非圣贤孰能无过，虽然写错或者修改错了文档的情况不一定会发生，但如果发生了，又还没有提交到暂存区的时候，就可以用<code>git checkout -- file</code>来丢弃一些修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GitEx % vi newreadme.txt </span><br><span class="line">GitEx % cat newreadme.txt </span><br><span class="line">添加一个新的readme文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">checkout 演示用</span><br><span class="line">GitEx % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   newreadme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">GitEx % git checkout -- newreadme.txt</span><br><span class="line">GitEx % cat newreadme.txt </span><br><span class="line">添加一个新的readme文档%                                                         </span><br></pre></td></tr></table></figure><p>从演示的代码可以看出，添加的内容被删除了，但原内容还在，又可以开心的搞事情了。</p><p>但是，你不小心修改或者写错了，还手贱的<code>git add</code>了，这时候<code>git checkout -- file</code>是救不了你了，这时候，不就需要用到<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉（unstage）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GitEx % vi newreadme.txt </span><br><span class="line">GitEx % cat newreadme.txt </span><br><span class="line">添加一个新的readme文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llaklshjdakjhsdkjakjf asdhksdbkbsdf</span><br><span class="line">asjkfksljhdfjkshf</span><br><span class="line">sjdfljkshdfkljklasdjs</span><br><span class="line">fjksfhvoixclvn se;fksp[fcv</span><br><span class="line">aksdjkfvoics dv </span><br><span class="line">GitEx % git add newreadme.txt </span><br><span class="line">GitEx % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   newreadme.txt</span><br><span class="line"></span><br><span class="line">GitEx % git reset Head newreadme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mnewreadme.txt</span><br><span class="line">GitEx % git status                  </span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   newreadme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">GitEx % git checkout -- newreadme.txt </span><br><span class="line">GitEx % git status                  </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">GitEx % cat newreadme.txt       </span><br><span class="line">添加一个新的readme文档%              </span><br></pre></td></tr></table></figure><p>嘿嘿，一顿操作之后，又可以愉快的搞事情了。</p><p>小结。</p><ul><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li></ul><ul><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li></ul><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p>在Git中，删除也是一个修改操作，可以先模拟添加一个文件，然后将它删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GitEx % touch delete.txt</span><br><span class="line">GitEx % git add delete.txt </span><br><span class="line">GitEx % git commit -m &quot;add delete.txt&quot;</span><br><span class="line">[master 88b28c9] add delete.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 delete.txt</span><br><span class="line">tinenlau@TinendeAir GitEx % ls -a</span><br><span class="line">.delete.txtwallhaven-57ge21.jpeg</span><br><span class="line">..newreadme.txt</span><br><span class="line">.gitreadme.txt</span><br><span class="line">GitEx % git log</span><br><span class="line">commit 88b28c9840bd9730816437b4d4710c5e86b3a449 (HEAD -&gt; master)</span><br><span class="line">Author:  &lt;&gt;</span><br><span class="line">Date:   Thu Jul 29 23:45:15 2021 +0800</span><br><span class="line"></span><br><span class="line">    add delete.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tinenlau@TinendeAir GitEx % rm delete.txt </span><br><span class="line">tinenlau@TinendeAir GitEx % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">deleted:    delete.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"> GitEx % git rm delete.txt             </span><br><span class="line">rm &#x27;delete.txt&#x27;</span><br><span class="line">GitEx % git commit -m &quot;del delete.txt&quot;</span><br><span class="line">[master b383f57] del delete.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 delete.txt</span><br><span class="line">GitEx % ls -a</span><br><span class="line">..gitreadme.txt</span><br><span class="line">..newreadme.txtwallhaven-57ge21.jpeg</span><br><span class="line">tinenlau@TinendeAir GitEx % git log</span><br><span class="line">commit b383f57e0ada97541d6757f918994d86c199d7bc (HEAD -&gt; master)</span><br><span class="line">Author: &lt;&gt;</span><br><span class="line">Date:   Thu Jul 29 23:49:14 2021 +0800</span><br><span class="line"></span><br><span class="line">    del delete.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</em> </p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GitEx % git reset HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Ddelete.txt</span><br><span class="line">GitEx % git checkout delete.txt</span><br><span class="line">Updated 1 path from the index</span><br><span class="line">GitEx % ls -a</span><br><span class="line">.delete.txtwallhaven-57ge21.jpeg</span><br><span class="line">..newreadme.txt</span><br><span class="line">.gitreadme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p> <em>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</em></p><h5 id="创建SSHkey"><a href="#创建SSHkey" class="headerlink" title="创建SSHkey"></a>创建SSHkey</h5><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><p><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><p>需要把<code>youremail@example.com</code>换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。当然了，你也可以选择设置密码，只要你不嫌麻烦。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登录GitHub或者Gitee，打开“Setting–SSH”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容就可以了。这里应该要有配图的但我懒得截图了，就这样吧。</p><h6 id="答疑时间"><a href="#答疑时间" class="headerlink" title="答疑时间"></a>答疑时间</h6><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。</p><h5 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h5><p>Git的在线仓库推荐：<a href="https://github.com/">GitHub</a>，<a href="https://gitee.com/">Gitee</a>，还有腾讯云旗下的<a href="https://coding.net/">Coding</a>等。</p><p>关于账号、仓库的创建可以进入这两个网站，然后按照相关指示进行操作，GitHub最好自带梯子。Gitee是国内的，可以多多支持。</p><h5 id="关联-添加远程仓库"><a href="#关联-添加远程仓库" class="headerlink" title="关联/添加远程仓库"></a>关联/添加远程仓库</h5><p>在线Git仓库创建好之后，需要和本地原有的仓库进行关联，需要使用的命令是：</p><p><code>git remote add origin git@github.com:[username]/[gitname].git</code></p><p>下面是关联远程仓库后拉取的操作过程记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Documents % mkdir GitLocal</span><br><span class="line">Documents % cd GitLocal </span><br><span class="line">GitLocal % git init</span><br><span class="line">hint: Using &#x27;master&#x27; as the name for the initial branch. This default branch name</span><br><span class="line">hint: is subject to change. To configure the initial branch name to use in all</span><br><span class="line">hint: of your new repositories, which will suppress this warning, call:</span><br><span class="line">hint: </span><br><span class="line">hint: git config --global init.defaultBranch &lt;name&gt;</span><br><span class="line">hint: </span><br><span class="line">hint: Names commonly chosen instead of &#x27;master&#x27; are &#x27;main&#x27;, &#x27;trunk&#x27; and</span><br><span class="line">hint: &#x27;development&#x27;. The just-created branch can be renamed via this command:</span><br><span class="line">hint: </span><br><span class="line">hint: git branch -m &lt;name&gt;</span><br><span class="line">Initialized empty Git repository in /Users/xxxxxxx/Documents/GitLocal/.git/</span><br><span class="line">GitLocal % ls -a</span><br><span class="line">....git</span><br><span class="line">GitLocal % git remote add origin git@gitee.com:lauyongyi/git-examples.git</span><br><span class="line">tinenlau@TinendeAir GitLocal % git pull origin master</span><br><span class="line">hint: Pulling without specifying how to reconcile divergent branches is</span><br><span class="line">hint: discouraged. You can squelch this message by running one of the following</span><br><span class="line">hint: commands sometime before your next pull:</span><br><span class="line">hint: </span><br><span class="line">hint:   git config pull.rebase false  # merge (the default strategy)</span><br><span class="line">hint:   git config pull.rebase true   # rebase</span><br><span class="line">hint:   git config pull.ff only       # fast-forward only</span><br><span class="line">hint: </span><br><span class="line">hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default</span><br><span class="line">hint: preference for all repositories. You can also pass --rebase, --no-rebase,</span><br><span class="line">hint: or --ff-only on the command line to override the configured default per</span><br><span class="line">hint: invocation.</span><br><span class="line">From gitee.com:lauyongyi/git-examples</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">GitLocal % ls -a</span><br><span class="line">..gitREADME.en.mdly.txt</span><br><span class="line">...gitignoreREADME.md</span><br></pre></td></tr></table></figure><p>这个是关联后推送的操作记录（因为懒得操作，所以直接从网上抄的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><h6 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h6><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><h5 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitLocal % git remote -v</span><br><span class="line">origingit@gitee.com:lauyongyi/git-examples.git (fetch)</span><br><span class="line">origingit@gitee.com:lauyongyi/git-examples.git (push)</span><br></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitLocal % git remote rm origin</span><br><span class="line">GitLocal % git remote -v    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h5 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h5><p>现在普遍都是面向GitHub编程的。遇到好的项目时，除了Star、Fork、DownloadZip外，还可以把项目完整的克隆到本地，包括分支结构、提交信息等，比Download更全面。</p><p>克隆的命令是：<code>git clone git@github.com:UserName/GitProjectName.git</code></p><p>克隆需要的连接可以从项目页面上找到，通常都在下图所示的位置</p><p><img src="/images/2021/08/Git/01.png"></p><p>GitHub给出的地址不止一个，还可以用<code>https://github.com/UserName/ProjectName.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><h5 id="推送提交"><a href="#推送提交" class="headerlink" title="推送提交"></a>推送提交</h5><p>要将本地的修改同步到仓库中，就需要用到<code>git push</code>命令。</p><p>完整命令格式如下：<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></p><p>结合前面的 <code>git add</code> ,<code>git commit</code>，最后一步就是<code>git push</code>，将本地的修改同步到远端。</p><p>操作举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果<code>master</code>不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete master</span></span><br></pre></td></tr></table></figure><p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure><p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p><p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做<code>simple</code>方式。此外，还有一种<code>matching</code>方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用<code>matching</code>方法，现在改为默认采用<code>simple</code>方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global push.default matching</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global push.default simple</span></span><br></pre></td></tr></table></figure><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>–all</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --all origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。<br>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>–force</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --force origin</span></span><br></pre></td></tr></table></figure><p>上面命令使用<code>-–force</code>选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用<code>–-force</code>选项。</p><p>最后，<code>git push</code>不会推送标签(tag)，除非使用<code>–tags</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure><p>将当前分支推送到远程的同名的简单方法，如下 - </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin HEAD</span></span><br></pre></td></tr></table></figure><p>将当前分支推送到源存储库中的远程引用匹配主机。 这种形式方便推送当前分支，而不考虑其本地名称。如下 - </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin HEAD:master</span></span><br></pre></td></tr></table></figure><h5 id="拉取新的内容"><a href="#拉取新的内容" class="headerlink" title="拉取新的内容"></a>拉取新的内容</h5><p><code>git pull</code>命令用于从另一个存储库或本地分支获取并集成(整合)。<code>git pull</code>命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂</p><p><code>git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><p>比如，要取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样 -</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next:master</span></span><br></pre></td></tr></table></figure><p>如果远程分支(<code>next</code>)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再执行<code>git merge</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/next</span></span><br></pre></td></tr></table></figure><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p><p>Git也允许手动建立追踪关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream master origin/next</span></span><br></pre></td></tr></table></figure><p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br></pre></td></tr></table></figure><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”(remote-tracking branch)进行合并。</p><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p><p>如果合并需要采用<code>rebase</code>模式，可以使用<code>–rebase</code>选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>一个项目在开发过程中，会有不同的阶段，可能需要不同分支来进行管理。这时候就需要用到git分支管理的功能。</p><h5 id="创建和切换分支"><a href="#创建和切换分支" class="headerlink" title="创建和切换分支"></a>创建和切换分支</h5><p>创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev  <span class="comment">#创建分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev <span class="comment">#切换分支</span></span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git branch       </span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git-examples % touch dev.txt</span><br><span class="line">git-examples % vi dev.txt </span><br><span class="line">git-examples % git add dev.txt </span><br><span class="line">git-examples % git commit -m &quot;dev分支首个提交&quot;</span><br><span class="line">[dev 6feff02] dev分支首个提交</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 dev.txt</span><br><span class="line">git-examples % git push -u origin dev</span><br><span class="line">Enumerating objects: 8, done.</span><br><span class="line">Counting objects: 100% (8/8), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (7/7), done.</span><br><span class="line">Writing objects: 100% (8/8), 1.69 KiB | 1.69 MiB/s, done.</span><br><span class="line">Total 8 (delta 1), reused 4 (delta 0), pack-reused 0</span><br><span class="line">remote: Powered by GITEE.COM [GNK-6.0]</span><br><span class="line">remote: Create a pull request for &#x27;dev&#x27; on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/lauyongyi/git-examples/pull/new/lauyongyi:dev...lauyongyi:master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line">git-examples % git branch                     </span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">git-examples % ls -a</span><br><span class="line">..gitREADME.en.md</span><br><span class="line">...gitignoreREADME.md</span><br></pre></td></tr></table></figure><p>我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git merge dev</span><br><span class="line">Updating d1a8baf..6feff02</span><br><span class="line">Fast-forward</span><br><span class="line"> dev.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 dev.txt</span><br><span class="line">git-examples % ls -a</span><br><span class="line">..gitREADME.en.mddev.txt</span><br><span class="line">...gitignoreREADME.md</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>dev.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：(用完就丢，真实)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git branch -d dev</span><br><span class="line">Deleted branch dev (was 6feff02).</span><br><span class="line">git-examples % git branch       </span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h6 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h6><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git switch -c dev</span><br><span class="line">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git-examples % git switch master</span><br><span class="line">Already on &#39;master&#39;    </span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        Git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似Norton Commander界面的文件管理器）不同。&lt;/p&gt;
&lt;p&gt;git最初的开发动力来自于BitKeeper和Monotone。git最初只是作为一个可以被其他前端（比如Cogito或Stgit）包装的后端而开发的，但后来git内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用git进行版本控制，其中包括Linux内核、X.Org服务器和OLPC内核等项目的开发流程。介绍摘抄自&lt;a href=&quot;https://zh.wikipedia.org/wiki/Git&quot;&gt;wikipedia&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>adb 命令播放音视频</title>
    <link href="https://www.lauyongyi.cn/adb%E6%92%AD%E6%94%BE%E9%9F%B3%E8%A7%86%E9%A2%91.html"/>
    <id>https://www.lauyongyi.cn/adb%E6%92%AD%E6%94%BE%E9%9F%B3%E8%A7%86%E9%A2%91.html</id>
    <published>2021-06-26T14:50:00.000Z</published>
    <updated>2021-06-26T15:01:52.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下</p><a id="more"></a><h5 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n com.android.music/com.android.music.MediaPlaybackActivity -d /sdcard/test.mp3</span><br></pre></td></tr></table></figure><p>/sdcard/timian.mp3为音乐地址</p><p>或</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a &quot;android.intent.action.VIEW&quot; -t &quot;audio/mp3&quot; -d &quot;file:///storage/sdcard0/Music/hello.mp3&quot;</span><br></pre></td></tr></table></figure><p>/storage/sdcard0/Music/hello.mp3为音乐地址</p><h5 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d   &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; </span><br></pre></td></tr></table></figure><p>/mnt/sdcard/DCIM/Camera/test.3gp为视频文件地址</p><p>或</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -a android.intent.action.VIEW -d &quot;file:///mnt/sdcard/DCIM/Camera/test.3gp&quot; -t &quot;video/*&quot; -n &quot;com.alensw.PicFolder/.PlayerActivity&quot; </span><br></pre></td></tr></table></figure><p><code>/mnt/sdcard/DCIM/Camera/test.3gp</code>为视频文件地址</p><p><code>com.alensw.PicFolder/.PlayerActivity</code>是播放器的播放页面</p><h5 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h5><p>对屏幕进行操作，可以用ADB命令模拟按键</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 24 #增加音量</span><br><span class="line">adb shell input keyevent 25 #降低音量</span><br><span class="line">adb shell input keyevent 85 #暂停/播放</span><br><span class="line">adb shell input keyevent 126 #恢复播放</span><br><span class="line">adb shell input keyevent 127 #停止播放</span><br></pre></td></tr></table></figure><p>关闭可以采用杀死进程的方式进行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep music</span><br><span class="line">#找到music的pid</span><br><span class="line">kill pid</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;android系统测试过程中需要自动播放视频与音乐，可以使用ADB命令进行操作，方法如下&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 运行npm报错</title>
    <link href="https://www.lauyongyi.cn/Mac%20OS%20npm%E6%8A%A5%E9%94%99.html"/>
    <id>https://www.lauyongyi.cn/Mac%20OS%20npm%E6%8A%A5%E9%94%99.html</id>
    <published>2021-06-22T15:17:00.000Z</published>
    <updated>2021-06-22T15:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    使用Mac OS 运行<code>npm install -g npm</code> 出现如下图所示错误<a id="more"></a></p><p>报错如下：</p><p><img src="/images/2021/06/npmerror.png"></p><p>图中，方框圈起的报错信息，主要是说没有权限，关键词：<strong>permission denied</strong></p><p>底部椭圆圈起的内容，大概翻译一下，意思是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permissions of the file and its containing directories, or try running</span><br><span class="line">npm ERR! the command again as root&#x2F;Administrator. </span><br><span class="line">文件及其包含的目录的权限，或尝试运行npm犯错!再次以root&#x2F;管理员的身份执行该命令。</span><br></pre></td></tr></table></figure><p>会报错是因为执行命令没有获取管理员权限，只需要<strong>在原有的命令前面加上sudo获取权限</strong>，然后回车时候需要输入管理员密码即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    使用Mac OS 运行&lt;code&gt;npm install -g npm&lt;/code&gt; 出现如下图所示错误</summary>
    
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用python编写Uiautomator2.0脚本</title>
    <link href="https://www.lauyongyi.cn/Uiautomatou%202.0%20python%E7%AF%87.html"/>
    <id>https://www.lauyongyi.cn/Uiautomatou%202.0%20python%E7%AF%87.html</id>
    <published>2021-06-19T10:29:00.000Z</published>
    <updated>2021-06-21T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目<a href="https://github.com/openatx/uiautomator2" title="Uiautomator2.0">Uiautomaotr2.0</a>，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。</p><a id="more"></a><h5 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h5><p>首先，必须确保本地安装了python环境，然后按照[README][<a href="https://github.com/openatx/uiautomator2/blob/master/README.md]%E7%9A%84%E8%AF%B4%E6%98%8E%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/openatx/uiautomator2/blob/master/README.md]的说明进行安装。</a></p><p>安装命令如下：<code>pip3 install -U uiautomator2</code>或者<code>pip install -U uiautomator2</code>，</p><p>pip3 针对的是python2和python3共存的环境，例如自带python2.x的Mac os，Linux。</p><p>测试是否安装成功可以执行 <code>uiautomator2 --help</code></p><h5 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h5><p>打开pycharm，新建一个工程，创建python文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2</span><br><span class="line"></span><br><span class="line">d = uiautomator2.connect()</span><br><span class="line">print(d.info)</span><br></pre></td></tr></table></figure><p>运行python文件，在控制台会有一个倒计时输出。从打印信息可以看出，是在安装需要用到的APP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[D 210619 18:46:21 __init__:634] kill process(ps): uiautomator</span><br><span class="line">[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator.apk-d3f17174fb/app-uiautomator.apk</span><br><span class="line">[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator.apk</span><br><span class="line">[D 210619 18:46:22 init:59] Use cached assets: /Users/tinenlau/.uiautomator2/cache/app-uiautomator-test.apk-652bf9e13c/app-uiautomator-test.apk</span><br><span class="line">[D 210619 18:46:22 __init__:365] pm install /data/local/tmp/app-uiautomator-test.apk</span><br></pre></td></tr></table></figure><p>安装结束后，就会打印出连接的设备的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;currentPackageName&#x27;: &#x27;net.oneplus.launcher&#x27;, &#x27;displayHeight&#x27;: 2297, &#x27;displayRotation&#x27;: 0, &#x27;displaySizeDpX&#x27;: 384, &#x27;displaySizeDpY&#x27;: 853, &#x27;displayWidth&#x27;: 1080, &#x27;productName&#x27;: &#x27;OnePlus8T_CH&#x27;, &#x27;screenOn&#x27;: True, &#x27;sdkInt&#x27;: 30, &#x27;naturalOrientation&#x27;: True&#125;</span><br></pre></td></tr></table></figure><h5 id="启动和停止APP运行"><a href="#启动和停止APP运行" class="headerlink" title="启动和停止APP运行"></a>启动和停止APP运行</h5><p>来源于[原文档][<a href="https://github.com/openatx/uiautomator2#launch-an-app]">https://github.com/openatx/uiautomator2#launch-an-app]</a></p><h6 id="Launch-an-app"><a href="#Launch-an-app" class="headerlink" title="Launch an app"></a>Launch an app</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的这种方法是先通过atx-agent解析apk包的mainActivity，然后调用am start -n $package/$activity启动</span></span><br><span class="line">d.app_start(<span class="string">&quot;com.example.hello_world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 monkey -p com.example.hello_world -c android.intent.category.LAUNCHER 1 启动</span></span><br><span class="line"><span class="comment"># 这种方法有个副作用，它自动会将手机的旋转锁定给关掉</span></span><br><span class="line">d.app_start(<span class="string">&quot;com.example.hello_world&quot;</span>, use_monkey=<span class="literal">True</span>) <span class="comment"># start with package name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定main activity的方式启动应用，等价于调用am start -n com.example.hello_world/.MainActivity</span></span><br><span class="line">d.app_start(<span class="string">&quot;com.example.hello_world&quot;</span>, <span class="string">&quot;.MainActivity&quot;</span>)</span><br></pre></td></tr></table></figure><h6 id="Stop-an-app"><a href="#Stop-an-app" class="headerlink" title="Stop an app"></a>Stop an app</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于 `am force-stop`, 可能会丢失部分数据</span></span><br><span class="line">d.app_stop(<span class="string">&quot;com.example.hello_world&quot;</span>) </span><br><span class="line"><span class="comment"># 相当于 `pm clear`，清理APP相关的数据</span></span><br><span class="line">d.app_clear(<span class="string">&#x27;com.example.hello_world&#x27;</span>)</span><br></pre></td></tr></table></figure><h6 id="Stop-all-running-apps"><a href="#Stop-all-running-apps" class="headerlink" title="Stop all running apps"></a>Stop all running apps</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有APP的运行，但不清空后台任务</span></span><br><span class="line">d.app_stop_all()</span><br><span class="line"><span class="comment"># 停止除了 com.examples.demo 以外的其他APP</span></span><br><span class="line">d.app_stop_all(excludes=[<span class="string">&#x27;com.examples.demo&#x27;</span>])</span><br></pre></td></tr></table></figure><h6 id="获取APP详情"><a href="#获取APP详情" class="headerlink" title="获取APP详情"></a>获取APP详情</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">info = d.app_info(<span class="string">&quot;com.oneplus.gallery&quot;</span>)</span><br><span class="line">print(info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expect output</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="string">&#x27;packageName&#x27;</span>: <span class="string">&#x27;com.oneplus.gallery&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;mainActivity&#x27;</span>: <span class="string">&#x27;com.oneplus.gallery2.OPGalleryActivity&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;Gallery&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;versionName&#x27;</span>: <span class="string">&#x27;4.0.180&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;versionCode&#x27;</span>: <span class="number">24190720</span>,</span><br><span class="line"><span class="string">&#x27;size&#x27;</span>: <span class="number">137659606</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打印正在运行的APP"><a href="#打印正在运行的APP" class="headerlink" title="打印正在运行的APP"></a>打印正在运行的APP</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2</span><br><span class="line"></span><br><span class="line">d = uiautomator2.connect()</span><br><span class="line">print(d.app_list_running())</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;net.oneplus.odm.provider&#x27;, &#x27;com.heytap.market&#x27;, &#x27;org.ifaa.aidl.manager&#x27;, &#x27;com.tencent.mm&#x27;, &#x27;com.android.cellbroadcastreceiver&#x27;, &#x27;com.numberrecognition&#x27;, &#x27;com.qualcomm.qti.workloadclassifier&#x27;, &#x27;com.oneplus.opbugreportlite&#x27;, &#x27;com.google.android.gms&#x27;, &#x27;com.oneplus.coreservice&#x27;, &#x27;com.heytap.mcs&#x27;, &#x27;com.oneplus.sound.tuner&#x27;, &#x27;com.redteamobile.virtual.softsim&#x27;, &#x27;com.oneplus.instant.local.service&#x27;, &#x27;com.oneplus.communication.sync&#x27;, &#x27;com.github.uiautomator&#x27;, &#x27;com.qualcomm.qcrilmsgtunnel&#x27;, &#x27;com.android.permissioncontroller&#x27;, &#x27;com.oneplus.orm&#x27;, &#x27;org.codeaurora.ims&#x27;, &#x27;com.oneplus.camera&#x27;, &#x27;com.android.se&#x27;, &#x27;com.android.nfc&#x27;, &#x27;com.android.settings&#x27;, &#x27;com.oneplus.gamespace&#x27;, &#x27;com.oneplus.brickmode&#x27;, &#x27;com.amap.android.location&#x27;, &#x27;com.google.android.ext.services&#x27;, &#x27;com.oneplus.config&#x27;, &#x27;com.oneplus.account&#x27;, &#x27;com.android.systemui&#x27;, &#x27;com.qualcomm.qti.devicestatisticsservice&#x27;, &#x27;com.qualcomm.qtil.aptxals&#x27;, &#x27;com.oneplus.camera.service&#x27;, &#x27;com.nearme.instant.platform&#x27;, &#x27;com.oneplus.permissionutil&#x27;, &#x27;com.oneplus.share&#x27;, &#x27;com.tencent.soter.soterserver&#x27;, &#x27;com.oneplus&#x27;, &#x27;com.google.android.providers.media.module&#x27;, &#x27;com.heytap.cloud&#x27;, &#x27;com.oneplus.screenrecord&#x27;, &#x27;com.oneplus.gallery&#x27;, &#x27;net.oneplus.weather&#x27;, &#x27;com.qualcomm.location&#x27;, &#x27;com.google.android.inputmethod.latin&#x27;, &#x27;com.android.cellbroadcastservice&#x27;, &#x27;com.qualcomm.qti.telephonyservice&#x27;, &#x27;com.android.providers.calendar&#x27;, &#x27;com.oneplus.camera.pictureprocessing&#x27;, &#x27;com.oneplus.mms&#x27;, &#x27;com.android.vending&#x27;, &#x27;com.android.phone&#x27;, &#x27;com.dolby.daxservice&#x27;, &#x27;net.oneplus.launcher&#x27;, &#x27;com.oneplus.voicewakeup&#x27;, &#x27;com.qualcomm.qti.uim&#x27;, &#x27;com.heytap.openid&#x27;]</span><br></pre></td></tr></table></figure><h6 id="等待指定app运行"><a href="#等待指定app运行" class="headerlink" title="等待指定app运行"></a>等待指定app运行</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2</span><br><span class="line"></span><br><span class="line">d = uiautomator2.connect()</span><br><span class="line">pid = d.app_wait(<span class="string">&quot;com.oneplus.camera&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> pid:</span><br><span class="line">    print(<span class="string">&quot;com.oneplus.camera is not running&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;com.oneplus.camera pid is %d&quot;</span> % pid)</span><br><span class="line"></span><br><span class="line">d.app_wait(<span class="string">&quot;com.oneplus.camera&quot;</span>, front=<span class="literal">True</span>)   <span class="comment"># 等待应用前台运行</span></span><br><span class="line"><span class="comment"># d.app_wait(&quot;com.oneplus.camera&quot;, timeout=20.0)  #app_wait 默认等待时间就是20s</span></span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.oneplus.camera pid is 5577  #app运行时的打印</span><br><span class="line"></span><br><span class="line">com.oneplus.camera is not running  #app没有运行时的打印</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        近期研究 uiautomator2.0版本编写测试脚本，功能很强大，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。在逛github的时候，看到了一个项目&lt;a href=&quot;https://github.com/openatx/uiautomator2&quot; title=&quot;Uiautomator2.0&quot;&gt;Uiautomaotr2.0&lt;/a&gt;，可以使用python编写uiautomator脚本，并在电脑上看到运行情况。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="python" scheme="https://www.lauyongyi.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler的使用</title>
    <link href="https://www.lauyongyi.cn/Fiddler%C2%A0%E8%BF%87%E6%BB%A4.html"/>
    <id>https://www.lauyongyi.cn/Fiddler%C2%A0%E8%BF%87%E6%BB%A4.html</id>
    <published>2021-06-04T14:37:00.000Z</published>
    <updated>2021-06-14T07:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能<strong>Filters</strong>。</p><a id="more"></a><h5 id="User-Filters启用"><a href="#User-Filters启用" class="headerlink" title="User Filters启用"></a>User Filters启用</h5><p>​        一般情况下，User Filter 是没有启动，状态如下图所示</p><p><img src="/images/2021/06/userfilters.png" alt="默认状态"></p><p>点击选择后，状态变成已启用，如下图所示</p><p><img src="/images/2021/06/1622820426.png" alt="启用状态"></p><h5 id="Action的功能"><a href="#Action的功能" class="headerlink" title="Action的功能"></a>Action的功能</h5><p>Action：Run Filterset now是否运行，Load Filterset加载，Save Filterset保存；</p><p><img src="/images/2021/06/1622820620.png" alt="Action的功能"></p><h5 id="Hosts-过滤"><a href="#Hosts-过滤" class="headerlink" title="Hosts 过滤"></a>Hosts 过滤</h5><p><strong>Zone</strong>：指定只显示内网（Intranet）或互联网（Internet）的内容；</p><p><img src="/images/2021/06/1622820880.png" alt="Zone"></p><p><strong>Host</strong>：指定显示某个域名下的会话；</p><p>-No Host Filter：无HOST过滤；<br>Hide the following Hosts：隐藏以下HOST；<br>Show only the following Hosts：仅显示以下Hosts<br>Flag the following Hosts：标记以下HOST；<br>输入多个HOST，多个之前用 <strong>;</strong> 或 <strong>,</strong> 或 <strong>回车键</strong> 分隔；<br>支持通配符如：*,baidu.com；</p><p><img src="/images/2021/06/1622820955.png" alt="Host"></p><p>步骤：选择Hosts—&gt;输入过滤条件单条件<code>ir.baidu.com</code>或多条件<code>ir.baidu.com;www.baidu.com</code>或通配符<code>*.baidu.com</code>—&gt;Changes not yet saved—&gt;选择Ations中Run Filterset now；</p><p><img src="/images/2021/06/fiddler01.png" alt="Hosts过滤"></p><h5 id="Client-Process-过滤"><a href="#Client-Process-过滤" class="headerlink" title="Client Process 过滤"></a>Client Process 过滤</h5><p>客户端进程过滤规则：</p><p> Show only traffic from：你可以指定只捕获哪个Windows进程中的请求；<br> Show only Internet Explorer traffic：只显示IE发出的请求；<br> Hide Windows RSS platform traffic：隐藏Windows RSS平台发出的请求；</p><p><img src="/images/2021/06/fiddler02.png" alt="ClientProcess过滤"></p><h5 id="Request-Headers-过滤"><a href="#Request-Headers-过滤" class="headerlink" title="Request Headers 过滤"></a>Request Headers 过滤</h5><p>Request header过滤规则：</p><p> 经常使用：Show only if URL contains：只显示包含特定字符的请求；<br> Hide if URL contains：隐藏包含特定字符的请求；<br> Flag requests with headers：标记带有特定header的请求；<br> Delete request headers：删除请求header；<br> Set request header：设置请求的header；</p><p><img src="/images/2021/06/fiddler03.png" alt="headers过滤"></p><h5 id="Breakpoints"><a href="#Breakpoints" class="headerlink" title="Breakpoints"></a>Breakpoints</h5><p>断点设置规则：</p><p> Break request on HTTP POST：给所有POST请求设置断点；<br> Break request on HTTP GET with QueryString：给所有带参数的GET请求设置断点；<br> Break on XMLHttpRequest：给所有XML请求设置断点；<br> Break response on Content-Type：给包含特定的Content-Type返回设置断点；<br><img src="/images/2021/06/fiddler04.png" alt="断点设置"></p><h5 id="Response-Status-Code-过滤"><a href="#Response-Status-Code-过滤" class="headerlink" title="Response Status Code 过滤"></a>Response Status Code 过滤</h5><p>响应HTTP状态过滤规则：</p><p> Hide success(2xx)：隐藏响应成功的session(2xx)；<br> Hide Authentication demands(401,407)：隐藏未经授权被拒绝的session(401,407；<br> Hide redirects(300,301,302,303,307)：隐藏重定向的session(300,301,302,303,307)；<br> Hide Not Modified(304)：隐藏无变更的session(304)；</p><p><img src="/images/2021/06/fiddler05.png"></p><h5 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h5><p>Response header过滤规则：</p><p> Flag response that set cookies：标记会设置cookie的响应；<br> Flag response with headers：标记带有特定header的响应；<br> Delete response headers：删除响应header；<br> Set response header：设置响应的header；</p><p><img src="/images/2021/06/fiddler06.png" alt="Response header"></p><h5 id="Response-Type-and-Size"><a href="#Response-Type-and-Size" class="headerlink" title="Response Type and Size"></a>Response Type and Size</h5><p>响应类型和大小过滤规则：</p><p> Show all Content-Type：显示所有响应类型；<br> Hide smaller than ？KB：隐藏小于指定大小的session；<br> Hide larger than ？KB：隐藏大于指定大小的session；<br> Time HeatMap：获得即时数据（绿色阴影代表响应时间在50毫秒以内；超过50毫秒但在300毫秒之内的响应条目没有颜色；响应时间在300至500毫秒之间的会涂以黄色；超过500毫秒的用红色底纹显示）；<br> Block script files：阻止脚本文件，显示为404；<br> Block image files：阻止图片文件；<br> Block SWF files：阻止SWF文件；<br> Block CSS files：阻止CSS文件；</p><p><img src="/images/2021/06/fiddler07.png"></p><p><img src="/images/2021/06/fiddler08.png"></p><p><img src="/images/2021/06/fiddler09.png"></p><p><img src="/images/2021/06/fiddler10.png"></p><p><img src="/images/2021/06/fiddler11.png"></p><h5 id="鼠标右键菜单过滤功能"><a href="#鼠标右键菜单过滤功能" class="headerlink" title="鼠标右键菜单过滤功能"></a>鼠标右键菜单过滤功能</h5><p><img src="/images/2021/06/fiddler12.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        使用Fiddler抓包的时候，常常会把其他不需要的链接也一并抓取显示，这时候就需要用到过滤功能&lt;strong&gt;Filters&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具使用" scheme="https://www.lauyongyi.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>常见的运行异常</title>
    <link href="https://www.lauyongyi.cn/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8.html"/>
    <id>https://www.lauyongyi.cn/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8.html</id>
    <published>2021-05-28T15:37:00.000Z</published>
    <updated>2021-06-18T15:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。</p><a id="more"></a><h5 id="NullPointerException（空指针异常）"><a href="#NullPointerException（空指针异常）" class="headerlink" title="NullPointerException（空指针异常）"></a>NullPointerException（空指针异常）</h5><p>​         俗称NPE。调用了未经初始化的对象或者是不存在的对象。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。<br>         目前，客户端页面显示很多需要依赖服务端返回数据，当网络异常时，没有获取到对象，此时为null，就很容易出现nullpointerException异常。有可能也是代码错误，没有new造成的。</p><h6 id="如何检测java-lang-NullPointerException"><a href="#如何检测java-lang-NullPointerException" class="headerlink" title="如何检测java.lang.NullPointerException"></a>如何检测java.lang.NullPointerException</h6><p>检测<code>NullPointerException</code>非常简单，只需查看异常跟踪，它将显示异常的类名和行号。然后查看代码并查看可能为<code>null</code>。只要看一下上面的所有例子，从堆栈跟踪中可以清楚地看出是什么导致了<code>null</code>指针异常。</p><h6 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h6><p><strong>1. 调用实例方法时出现NullPointerException</strong></p><p>示例代码 - </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Temp t = initT();</span><br><span class="line"></span><br><span class="line">        t.foo(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Temp <span class="title">initT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行上面的程序时，它会抛出<code>NullPointerException</code>异常错误消息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at Temp.main(Temp.java:7)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在语句<code>t.foo(&quot;Hi&quot;)</code>中抛出<code>NullPointerException</code>异常; 因为<code>t</code>在这里为<code>null</code>。</p><p><strong>2. 访问/修改null对象的字段时出现NullPointerException</strong></p><p>示例代码 - </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Temp t = initT();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = t.x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Temp <span class="title">initT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 - </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at Temp.main(Temp.java:9)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>语句<code>int i = t.x</code>中抛出<code>NullPointerException</code>异常; 因为<code>t</code>在这里为<code>null</code>。</p><p><strong>3. 在方法参数中传递null时NullPointerException</strong></p><p>示例代码 - </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        foo(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是<code>java.lang.NullPointerException</code>最常见的情况之一，因为它传递<code>null</code>参数给调用者。错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">at NPE.foo(NPE.java:9)</span><br><span class="line">at NPE.main(NPE.java:4)</span><br></pre></td></tr></table></figure><p><strong>4. 抛出null时抛出java.lang.NullPointerException</strong></p><p>示例代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是上面程序的异常堆栈跟踪，由于<code>throw null</code>所以抛出<code>NullPointerException</code>异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at Temp.main(Temp.java:5)</span><br></pre></td></tr></table></figure><p><strong>5. 获取null数组的长度时抛出java.lang.NullPointerException</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = data.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 - </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at Temp.main(Temp.java:7)</span><br></pre></td></tr></table></figure><p><strong>6. 访问null数组的索引值时出现NullPointerException</strong></p><p>示例代码 - </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = data[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面示例代码，得到以下结果 - </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at Temp.main(Temp.java:7)</span><br></pre></td></tr></table></figure><p><strong>7. 在null对象上同步时出现java.lang.NullPointerException</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String mutex = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mutex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized(mutex)</code>将抛出<code>NullPointerException</code>，因为<code>mutex</code>对象为<code>null</code>。</p><p><strong>8. java.lang.NullPointerException引发HTTP状态500</strong></p><p>有时会将错误页面作为java Web应用程序响应发送，错误消息为“HTTP状态500  - 内部服务器错误”，根本原因就是<code>java.lang.NullPointerException</code>异常。</p><p>下面是一段编辑了Spring MVC Example项目并更改了<code>HomeController</code>方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(<span class="meta">@Validated</span> User user, Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Page Requested&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User Name: &quot;</span>+user.getUserName().toLowerCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;User ID: &quot;</span>+user.getUserId().toLowerCase());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;userName&quot;</span>, user.getUserName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下图显示了Web应用程序响应引发的错误消息。<br><img src="/images/2021/06/NPE01.png" alt="NullPointerException引发HTTP状态500"></p><p>下面是异常堆栈跟踪 - </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HTTP Status <span class="number">500</span> – Internal Server Error</span><br><span class="line"></span><br><span class="line">Type Exception Report</span><br><span class="line"></span><br><span class="line">Message Request processing failed; nested exception is java.lang.NullPointerException</span><br><span class="line"></span><br><span class="line">Description The server encountered an unexpected condition that prevented it from fulfilling the request.</span><br><span class="line"></span><br><span class="line">Exception</span><br><span class="line"></span><br><span class="line">org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException</span><br><span class="line">    org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:<span class="number">982</span>)</span><br><span class="line">    org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:<span class="number">872</span>)</span><br><span class="line">    javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="number">661</span>)</span><br><span class="line">    org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:<span class="number">846</span>)</span><br><span class="line">    javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="number">742</span>)</span><br><span class="line">    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:<span class="number">52</span>)</span><br><span class="line">Root Cause</span><br><span class="line"></span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">    com.journaldev.spring.controller.HomeController.user(HomeController.java:<span class="number">38</span>)</span><br><span class="line">    sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">    java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br></pre></td></tr></table></figure><p>根本原因是语句<code>user.getUserId().toLowerCase()</code>中引发了<code>NullPointerException</code>，因为<code>user.getUserId()</code>返回<code>null</code>。</p><h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p>​        这种异常通常是调用一个对象的接口方法抛出的，在调用接口方法之前，要进行判空或者进行try-catch，这样基本可以规避大部分空指针异常。<br>​        最常见是在 回调接口, 如 网络请求回调，第三方登录回调 返回的时候 调用 context.startActivity 时 context 为空导致。可以在 context 为空的时候使用 Application Context， 加上<br> if (!(context instanceof Activity)) {<br> intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br> }</p><h5 id="ArrayindexOutOfBoundsExceptions（数组越界异常）"><a href="#ArrayindexOutOfBoundsExceptions（数组越界异常）" class="headerlink" title="ArrayindexOutOfBoundsExceptions（数组越界异常）"></a>ArrayindexOutOfBoundsExceptions（数组越界异常）</h5><h6 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h6><p>​        如果访问数组元素的时候，索引编号并不存在</p><p>错误示例</p><p>使用不合法的索引访问数组时会报数组越界这种错误，数组arr的合法错误范围是[0, arr.length-1];当你访问这之外的索引时会报这个错。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出的错误提示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">3</span></span><br><span class="line">at Test.main(Test.java:<span class="number">5</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)</span><br><span class="line">at edu.rice.cs.drjava.model.compiler.JavacCompiler.runCommand(JavacCompiler.java:<span class="number">272</span>)</span><br></pre></td></tr></table></figure><h6 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h6><p>​        这种情况一般要在数组循环前做好length判断，index超出length上限和下限时都会报错。举例如下：一个数组int test[N]，一共有N个元素分别是test[0]~test[N-1]，如果调用test[N]，将会报错。建议读取时，不要超过数组的长度（array.length）。<a href="https://blog.csdn.net/qq_34646449/article/details/76146659">参考链接</a><br><strong>Android中一种常见情形就是上拉刷新中header也会作为listview的第0个位置，如果判断失误很容易造成越界。</strong></p><h5 id="indexOutOfBoundsException（越界异常）"><a href="#indexOutOfBoundsException（越界异常）" class="headerlink" title="indexOutOfBoundsException（越界异常）"></a>indexOutOfBoundsException（越界异常）</h5><h6 id="出现的原因-1"><a href="#出现的原因-1" class="headerlink" title="出现的原因"></a>出现的原因</h6><p>​        该异常表示不合法下标，通常是因为访问了list不合法的位置，建议检查数据是否越界。</p><h6 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h6><p> 1.遍历数组/字符串等集合前，要判断遍历对象的长度；<br> 2.操作数组/字符串等集合前，要检查角标是否在长度允许范围内；<br> 3.ListView操作不当也会引起该异常，这种情况下一般是由于List渲染的时候，外面的数据源发生变化导致的。举例如ListView滚动时点击刷新将会报错，解决方法是ListView滚动时将刷新置为不可点击。</p><h5 id="outOfMemory（内存溢出）"><a href="#outOfMemory（内存溢出）" class="headerlink" title="outOfMemory（内存溢出）"></a>outOfMemory（内存溢出）</h5><p>​        指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存，俗称<a href="https://blog.csdn.net/eff666/article/details/52071873">OOM</a></p><h6 id="出现的原因-2"><a href="#出现的原因-2" class="headerlink" title="出现的原因"></a>出现的原因</h6><p>​    （1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；<br>​    （2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；<br>​    （3）代码中存在死循环或循环产生过多重复的对象实体；<br>​    （4）使用的第三方软件中的BUG；<br>​    （5）启动参数内存值设定的过小；</p><p>​        通俗解释：系统已经不能再分配出你所需要的空间，比如系统现在只有1G的空间，但是你偏偏要2个G空间，这就叫内存溢出 例子：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。</p><h6 id="常见错误提示"><a href="#常见错误提示" class="headerlink" title="常见错误提示"></a>常见错误提示</h6><p>​        [相关例子说明][<a href="https://segmentfault.com/a/1190000017226359]">https://segmentfault.com/a/1190000017226359]</a></p><p>​        1、OOM fo heap ：<code>java.lang:OutOfMemoryError: Java heap space</code>，此OOM是由于JVM中heap的最大值不满足需要，将设置heap的最大值调高即可。</p><p>​        2、OOM for Perm：<code>java.lang:OutOfMemoryError: Java perm space</code>，此OOM是由于JVM中perm的最大值不满足需要，将设置perm的最大值调高即可，参数样例为：-XX:MaxPermSize=512M</p><p>​        3、OOM for GC=&gt;例如：<code>java.lang:OutOfMemoryError: GC overhead limit exceeded</code>，此OOM是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略</p><p>​        4、OOM for native thread created：<code>java.lang.OutOfMemoryError: unable to create new native threa</code>，此OOM是由于进程剩余的空间不足，导致创建进程失败</p><p>​        5、OOM for allocate huge array：<code>Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>，此类信息表明应用程序（或者被应用程序调用的APIs）试图分配一个大于堆大小的数组</p><p>​        6、OOM for small swap：<code>Exception in thread &quot;main&quot;: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?</code>,抛出这类错误，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽</p><p>​        7、OutOfMemoryError： <code>thrown while trying to throw OutOfMemoryError; no stack trace available</code>，抛出这类错误，一般是由于方法重复调用、死循环引起，直至内存耗尽</p><h5 id="内存泄漏：-Memory-Leak"><a href="#内存泄漏：-Memory-Leak" class="headerlink" title="内存泄漏：  (Memory Leak)"></a>内存泄漏：  (Memory Leak)</h5><p>​        指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p><strong>以产生的方式来分类，内存泄漏可以分为四类：</strong><br><strong>（1）常发性内存泄漏：</strong>发生内存泄漏的代码会被多次执行到，每次被执行时都会导致一块内存泄漏。<br><strong>（2）偶发性内存泄漏：</strong>发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。<br><strong>（3）一次性内存泄漏：</strong>发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏。<br><strong>（4）隐式内存泄漏：</strong>程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。</p><p><strong>memory leak会最终会导致out of memory！</strong></p><p>内存泄漏和内存溢出的相关说明例子：[博客园][<a href="https://www.cnblogs.com/xiaoxi/p/7354857.html]%EF%BC%8C[%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA]%EF%BC%8C[%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%EF%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F]">https://www.cnblogs.com/xiaoxi/p/7354857.html]，[百度百科：内存泄漏][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA]，[百度百科：内存溢出][https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F]</a></p><h6 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h6><p>​        jvm管理的内存大致包括三种不同类型的内存区域：Permanent Generation space（永久保存区域）、Heap space(堆区域)、Java Stacks(Java栈）。其中永久保存区域主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGen space区域，Class需要存储的内容主要包括方法和静态属性。堆区域用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。而Java栈跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。</p><h5 id="illegalStateException（非法状态异常）"><a href="#illegalStateException（非法状态异常）" class="headerlink" title="illegalStateException（非法状态异常）"></a>illegalStateException（非法状态异常）</h5><h6 id="常见错误提示-1"><a href="#常见错误提示-1" class="headerlink" title="常见错误提示"></a>常见错误提示</h6><p><code>java.lang.IllegalStateException：Cannot forward a response that is already committed </code><br><code>IllegalStateException：response already commited </code><br><code>IllegalStateException：getOutputStream() has already been called for this request</code></p><p>出现原因</p><p>​        该异常表示，当前对客户端的响应已经结束，不能在响应已经结束（或说消亡）后再向客户端（实际上是缓冲区）输出任何内容。</p><p>​        这里涉及到java的io流：<a href="https://juejin.cn/post/6844904033656782856">flush()</a>，我们知道在使用读写流的时候数据先被读入内存这个缓冲区中，然后再写入文件，但是当数据读完时不代表数据已经写入文件完毕，因为可能还有一部分仍未写入文件而留在内存中，这时调用flush()方法就会把缓冲区的数据强行清空输出，因此flush()的作用就是保证缓存清空输出。</p><p>　　 response是服务端对客户端请求的一个响应，其中封装了响应头、状态码、内容等，服务端在把response提交到客户端之前，会向缓冲区内写入响应头和状态码，然后将所有内容flush。这就标志着该次响应已经committed(提交)。对于当前页面中已经committed(提交)的response，就不能再使用这个response向缓冲区写任何东西（注：同一个页面中的response.XXX()是同一个response的不同方法，只要其中一个已经导致了committed，那么其它类似方式的调用都会导致 IllegalStateException异常）。</p><h5 id="illegalArguementException（非法参数异常）"><a href="#illegalArguementException（非法参数异常）" class="headerlink" title="illegalArguementException（非法参数异常）"></a>illegalArguementException（非法参数异常）</h5><h6 id="常见错误提示-2"><a href="#常见错误提示-2" class="headerlink" title="常见错误提示"></a>常见错误提示</h6><p><code> java.lang.IllegalArgumentException</code></p><h6 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h6><p>​        参数不匹配异常，通常由于传递了不正确的参数导致。</p><p>常见于：</p><ol><li>Activity、Service状态异常；</li><li>非法URL；</li><li>UI线程操作</li><li>Fragment中嵌套了子Fragment，Fragment被销毁，而内部Fragment未被销毁，所以导致再次加载时重复，在onDestroyView() 中将内部Fragment销毁即可</li><li>在请求网络的回调中使用了glide.into(view),view已经被销毁会导致该错误</li></ol><h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><p>​        因为参数不合法导致抛出IllegalArgumentException，请根据堆栈信息描述的出错的函数参数，按照要求传入正确的参数。</p><h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p><a href="https://www.jianshu.com/p/65cbe8872c1b">错误堆栈信息</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot locate declared field <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">http</span>.<span class="title">impl</span>.<span class="title">client</span>.<span class="title">HttpClientBuilder</span>.<span class="title">sslContext</span></span></span><br><span class="line">    at org.apache.commons.lang3.Validate.isTrue(Validate.java:155)</span><br><span class="line">    at org.apache.commons.lang3.reflect.FieldUtils.readDeclaredField(FieldUtils.java:<span class="number">512</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.HttpWebConnection.getField(HttpWebConnection.java:<span class="number">1095</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.HttpWebConnection.createConnectionManager(HttpWebConnection.java:<span class="number">1017</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.HttpWebConnection.getResponse(HttpWebConnection.java:<span class="number">174</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.loadWebResponseFromWebConnection(WebClient.java:<span class="number">1397</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.loadWebResponse(WebClient.java:<span class="number">1315</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:<span class="number">394</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:<span class="number">315</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:<span class="number">463</span>)</span><br><span class="line">    at com.gargoylesoftware.htmlunit.WebClient.getPage(WebClient.java:<span class="number">448</span>)</span><br><span class="line">    at com.epoint.dzdamanager.login.DnetDefaultLoginForUrlImpl.doLogin(DnetDefaultLoginForUrlImpl.java:<span class="number">87</span>)</span><br><span class="line">    at com.epoint.ztb.htmlutil.HtmlToPdf.getHtmlPageFromUrlF9(vb:<span class="number">80</span>)</span><br><span class="line">    at com.epoint.dzdamanager.domain.DownZtbData.pageToPdf(DownZtbData.java:<span class="number">446</span>)</span><br><span class="line">    at com.epoint.dzdamanager.domain.DownZtbData.genFileList(DownZtbData.java:<span class="number">319</span>)</span><br><span class="line">    at com.epoint.dzdamanager.domain.DownZtbData.workForBarStep(DownZtbData.java:<span class="number">152</span>)</span><br><span class="line">    at com.epoint.dzdamanager.pack.job.DoPackServiceImp.doPack(DoPackServiceImp.java:<span class="number">87</span>)</span><br><span class="line">    at com.epoint.dzdamanager.pack.job.DoPackJob.execute(DoPackJob.java:<span class="number">35</span>)</span><br><span class="line">    at org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">202</span>)</span><br><span class="line">    at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:<span class="number">573</span>)</span><br></pre></td></tr></table></figure><h6 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h6><p>重点提示<code>Cannot locate declared field class org.apache.http.impl.client.HttpClientBuilder.sslContext</code><br>经排查，htmlunit.jar包在4.4.1版本中HttpClientBuilder该类无sslContext属性，属性名称为sslcontext，从而引发参数报错。</p><h5 id="ClassCastException（类型强制转换异常）"><a href="#ClassCastException（类型强制转换异常）" class="headerlink" title="ClassCastException（类型强制转换异常）"></a>ClassCastException（类型强制转换异常）</h5><h6 id="常见错误提示-3"><a href="#常见错误提示-3" class="headerlink" title="常见错误提示"></a>常见错误提示</h6><p><code>java.lang.ClassCastException</code></p><h6 id="出现原因-1"><a href="#出现原因-1" class="headerlink" title="出现原因"></a>出现原因</h6><p>​        当试图将对某个对象强制执行向下转型，但该对象又不可转换为其子类的实例时将引发该异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。<a href="https://www.cnblogs.com/coder-zyc/p/10573005.html">例子</a></p><h5 id="java-lang-ArithmeticException-（算术条件异常）"><a href="#java-lang-ArithmeticException-（算术条件异常）" class="headerlink" title="java.lang.ArithmeticException （算术条件异常）"></a>java.lang.ArithmeticException （算术条件异常）</h5><p>​    异常算术条件时抛出。 例如，“除以零”的整数会抛出。</p><h6 id="错误示例-1"><a href="#错误示例-1" class="headerlink" title="错误示例"></a>错误示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EXDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x/y;     <span class="comment">//此处出现异常</span></span><br><span class="line">        System.out.println(x/y);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">at EXDemo.main(EXDemo.java:5)</span><br></pre></td></tr></table></figure><p>在以上例子中,因为被除数为0,所以程序中出现了异常,从运行结果可以发现,如果不对异常进行处理,则一旦出现了异常后,程序就立刻推出,所以后面的语句并没有打印输出.</p><p>   在计算机的发展中有两大计算机”杀手”,一个是断电,另外一个是被除数为0;因为被除数为0在数学上的解是无穷大,对于计算机来说,意味着内存将被全部占满.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        安卓常见的异常主要有两种：编译时的异常和运行是的异常。当前主要说明的是运行时的异常。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="Android开发" scheme="https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>adb shell am 命令解析</title>
    <link href="https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--pm%20.html"/>
    <id>https://www.lauyongyi.cn/adb%E5%91%BD%E4%BB%A4--pm%20.html</id>
    <published>2021-05-16T02:42:00.000Z</published>
    <updated>2021-08-28T15:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。</p><a id="more"></a><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><table><thead><tr><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>输出到电脑</td><td>adb   shell  pm &lt;command&gt;</td></tr><tr><td>shell连接执行</td><td>pm &lt;command&gt;</td></tr><tr><td>例子</td><td>adb shell am list packages</td></tr></tbody></table><h4 id="包名信息查询"><a href="#包名信息查询" class="headerlink" title="包名信息查询"></a>包名信息查询</h4><h5 id="包状态分类"><a href="#包状态分类" class="headerlink" title="包状态分类"></a>包状态分类</h5><p>安卓系统中，包的状态分为：停用、启用、系统、三方和卸载</p><p>语法：<code>list packages [options] [filter]</code></p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>filter</td><td>过滤文字，仅输出包名称包含 filter 中的文本的软件包</td></tr><tr><td>-f</td><td>查看它们的关联文件</td></tr><tr><td>-d</td><td>进行过滤以仅显示已停用的软件包</td></tr><tr><td>-e</td><td>进行过滤以仅显示已启用的软件包</td></tr><tr><td>-s</td><td>进行过滤以仅显示系统软件包</td></tr><tr><td>-3</td><td>进行过滤以仅显示第三方软件包</td></tr><tr><td>-i</td><td>查看软件包的安装程序</td></tr><tr><td>-u</td><td>包括卸载的软件包</td></tr></tbody></table><h4 id="权限查询"><a href="#权限查询" class="headerlink" title="权限查询"></a>权限查询</h4><p>​    <code>权限</code>（Permission），顾名思义是一种对信息访问的申请。Android的权限有上百种，例如应用程序尝试调用拨号权限、调用摄像头权限、调用读取短信权限、调用读取通讯录权限等等。对于这些权限，Android将其按照危险等级进行了划分分组，分成如下的三种类别：</p><ul><li><code>正常权限（PROTECTION_NORMAL）</code>：指的是应用程序需要访问的一些数据资源，但并不涉及到用户的隐私或者对其他应用程序无害。例如设置闹钟就是属于正常权限。<strong>Android在处理正常权限时并不会提示用户，而用户也没有办法取消这些正常权限</strong></li><li><code>签名权限（PROTECTION_SIGNATURE）</code>：指的是Android在安装时授予应用程序的权限，利用签名权限，两个签名相同的应用程序就可以进行安全的数据共享。</li><li><code>危险权限（PROTECTION_DANGEROUS ）</code>：指的是直接触碰到用户隐私或者影响其他程序操作的权限，对于这一类的权限，Android会以弹窗的方式向用户进行问询，<strong>应用程序必须要经过用户的授权后才可以进行相应的行为</strong>。</li></ul><h5 id="危险权限组"><a href="#危险权限组" class="headerlink" title="危险权限组"></a>危险权限组</h5><p><img src="/images/2021/08/adb/03.png"></p><h5 id="权限查询语法"><a href="#权限查询语法" class="headerlink" title="权限查询语法"></a>权限查询语法</h5><p>基本语法：</p><p><code>adb shell pm list permission-groups</code>，输出所有已知的权限组。</p><p><code>list permissions [options] group</code>，输出所有已知的权限，或者，仅输出 <code>group</code> 中的权限。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>group</td><td>仅输出 group 中的权限</td></tr><tr><td>-g</td><td>按组加以组织</td></tr><tr><td>-f</td><td>输出所有信息</td></tr><tr><td>-s</td><td>简短摘要</td></tr><tr><td>-d</td><td>仅列出危险权限</td></tr><tr><td>-u</td><td>仅列出用户将看到的权限</td></tr></tbody></table><h4 id="权限授权取消"><a href="#权限授权取消" class="headerlink" title="权限授权取消"></a>权限授权取消</h4><h5 id="权限授权语法"><a href="#权限授权语法" class="headerlink" title="权限授权语法"></a>权限授权语法</h5><p><code>grant &lt;package_name&gt; &lt;permission&gt;</code></p><p>说明：向应用授予权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。</p><h5 id="权限撤销语法"><a href="#权限撤销语法" class="headerlink" title="权限撤销语法"></a>权限撤销语法</h5><p><code>revoke &lt;package_name&gt; &lt;permission&gt;</code></p><p>说明：从应用中撤销权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。</p><h5 id="重置权限语法"><a href="#重置权限语法" class="headerlink" title="重置权限语法"></a>重置权限语法</h5><p><code>reset-permissions</code></p><p>说明：重置所有运行时权限到默认最初的默认状态</p><h4 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h4><h5 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h5><p>语法：<code>adb shell pm install [options] &lt;path&gt;</code>，作用同<code>adb install </code></p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>path</td><td>安装包路径</td></tr><tr><td>-r</td><td>重新安装现有应用，保留其数据</td></tr><tr><td>-d</td><td>允许版本代码降级</td></tr></tbody></table><h5 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h5><p>语法：<code>adb shell pm uninstall [options] &lt;package&gt;</code>，作用同<code>adb uninstall </code></p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>package</td><td>需要卸载的应用包名</td></tr><tr><td>-k</td><td>移除软件包后保留数据和缓存目录</td></tr></tbody></table><h4 id="启停隐显应用"><a href="#启停隐显应用" class="headerlink" title="启停隐显应用"></a>启停隐显应用</h4><h5 id="停用-启用应用"><a href="#停用-启用应用" class="headerlink" title="停用/启用应用"></a>停用/启用应用</h5><table><thead><tr><th>停用语法</th><th>disable  <package_or_component></th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>停用给定软件包或组件</strong></td></tr></tbody></table><table><thead><tr><th>启用语法</th><th>enable <package_or_component></th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>停用给定软件包或组件</strong></td></tr></tbody></table><h5 id="隐藏-显示应用"><a href="#隐藏-显示应用" class="headerlink" title="隐藏/显示应用"></a>隐藏/显示应用</h5><table><thead><tr><th>隐藏语法</th><th>hide <package_or_component></th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>停用给定软件包或组件</strong></td></tr></tbody></table><table><thead><tr><th>显示语法</th><th>unhide <package_or_component></th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>停用给定软件包或组件</strong></td></tr></tbody></table><h5 id="挂起-解冻应用"><a href="#挂起-解冻应用" class="headerlink" title="挂起/解冻应用"></a>挂起/解冻应用</h5><table><thead><tr><th>挂起语法</th><th>suspend &lt;TARGET-PACKAGE&gt;</th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>挂起指定应用</strong></td></tr></tbody></table><table><thead><tr><th>解冻语法</th><th>unsuspend  &lt;TARGET-PACKAGE&gt;</th></tr></thead><tbody><tr><td><strong>说明</strong></td><td><strong>解冻指定应用</strong></td></tr></tbody></table><h4 id="清除数据"><a href="#清除数据" class="headerlink" title="清除数据"></a>清除数据</h4><table><thead><tr><th>语法</th><th>clear  &lt;package&gt;</th></tr></thead><tbody><tr><td>说明</td><td>删除与软件包关联的所有数据</td></tr></tbody></table><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>list  instrumentation [options]</td><td>列出所有测试软件包。</td></tr><tr><td>list  features</td><td>输出系统的所有功能。</td></tr><tr><td>list  libraries</td><td>输出当前设备支持的所有库。</td></tr><tr><td>list  users</td><td>输出系统上的所有用户。</td></tr><tr><td>path  package</td><td>输出给定 package 的 APK 的路径</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;​        pm命令 为包管理（package manager）的简称，是Android开发与测试后过程中必不可少的命令，可以使用pm命令来执行应用的安装和查询应用信息、系统权限以及控制应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="adb命令" scheme="https://www.lauyongyi.cn/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Crash详解</title>
    <link href="https://www.lauyongyi.cn/Crash%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.lauyongyi.cn/Crash%E8%AF%A6%E8%A7%A3.html</id>
    <published>2021-05-10T13:59:00.000Z</published>
    <updated>2020-05-10T14:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Android APP Crash通常是由未捕获的<code>Exception</code>或<code>signal</code>引起<code>app</code>异常退出。</p><a id="more"></a><p>如果<code>app</code>使用<code>Java</code>语言编写，那么，当<code>Throwable</code>抛出未处理的异常时，此时就会引起 <code>app Crash</code>。</p><p>如果app 使用<code>native-code</code>编写，那么，当执行时遇到未处理的<code>signal</code>（例如<code>SIGSEGV</code>）时，<code>app</code>就会 <code>Crash</code>并退出。</p><p>当应用程序崩溃时，<code>Android</code>终止应用程序的进程并显示一个对话框，让用户知道应用程序已经停止。如下图。</p><p><img src="/images/2021/05/crash-example-framed.png"></p><p><code>App Crash</code> 不仅发生在前台进程，任何<code>app</code>组件，例如<code>Broadcast Receivers</code>,<code>Content Providers</code>,<code>Service</code>等在后台运行的组件，也可以引起<code>App Crash</code>。这些<code>Crash</code>很容易引起用户混淆，因为他们没有直接参与到你的<code>app</code>中。</p><h5 id="分析App-Crash"><a href="#分析App-Crash" class="headerlink" title="分析App Crash"></a>分析App Crash</h5><p>解决崩溃可能很困难。 但是，如果您能够确定崩溃的根本原因，则很可能可以找到解决方案。</p><p>有很多情况可能会导致应用程序崩溃。 一些原因是显而易见的，比如检查一个空值或空字符串，而另外一些更微妙，比如将无效参数传递给API甚至是复杂的多线程交互。</p><h6 id="读取堆栈信息"><a href="#读取堆栈信息" class="headerlink" title="读取堆栈信息"></a>读取堆栈信息</h6><p>解决App Crash，首先要找到在那些代码发生的。你可以通过<code>logcat</code>或者收集工具如<em>play Console</em>，<em>bugly</em>等输出的堆栈信息进行分析查看。</p><p>下面是一个Crash示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------- beginning of crash</span><br><span class="line">    AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.android.developer.crashsample, PID: <span class="number">3686</span></span><br><span class="line">    java.lang.NullPointerException: crash sample</span><br><span class="line">    at com.android.developer.crashsample.MainActivity$<span class="number">1.</span>onClick(MainActivity.java:<span class="number">27</span>)</span><br><span class="line">    at android.view.View.performClick(View.java:<span class="number">6134</span>)</span><br><span class="line">    at android.view.View$PerformClick.run(View.java:<span class="number">23965</span>)</span><br><span class="line">    at android.os.Handler.handleCallback(Handler.java:<span class="number">751</span>)</span><br><span class="line">    at android.os.Handler.dispatchMessage(Handler.java:<span class="number">95</span>)</span><br><span class="line">    at android.os.Looper.loop(Looper.java:<span class="number">156</span>)</span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6440</span>)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">    at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:<span class="number">240</span>)</span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">746</span>)</span><br><span class="line">    --------- beginning of system</span><br></pre></td></tr></table></figure><p>上述Crash 堆栈信息包含 以下信息</p><ul><li>1.Crash app 包名</li><li>2.Crash app PID</li><li>3.引起Crash的异常信息（此异常时引起Crash的重要原因）</li><li>4.引起Crash 的代码位置，行号，哪个函数调用等等</li><li>5.对于被调用的每个函数，另一行显示前面的调用站点（称为栈帧）。</li></ul><p>通过走栈和检查代码，你可能会发现一个地方传递了一个不正确的值。 如果您的代码没有出现在堆栈跟踪中，则可能是在某处将异常操作传递给了一个无效的参数。 您可以经常通过检查堆栈跟踪的每一行，找到您使用的任何API类，并确认您传递的参数是正确的，并且从允许的地方调用该类来判断发生了什么。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android APP Crash通常是由未捕获的&lt;code&gt;Exception&lt;/code&gt;或&lt;code&gt;signal&lt;/code&gt;引起&lt;code&gt;app&lt;/code&gt;异常退出。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="Android开发" scheme="https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android Uiantomator2.0脚本编写基础知识</title>
    <link href="https://www.lauyongyi.cn/Android%20Uiantomator2.0%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80.html"/>
    <id>https://www.lauyongyi.cn/Android%20Uiantomator2.0%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-03-10T12:16:00.000Z</published>
    <updated>2021-06-18T10:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://developer.android.com/training/testing/ui-automator.html">UiAutomator</a>是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。        </p><a id="more"></a><h4 id="UiautomatorViewer工具"><a href="#UiautomatorViewer工具" class="headerlink" title="UiautomatorViewer工具"></a>UiautomatorViewer工具</h4><p>​        uiautomatorviewer是android SDK自带的一个元素定位工具。通过截屏并分析XML布局文件的方式，为用户提供控件信息查看服务。<br>使用uiautomatorviewer，你可以检查一个应用的UI来查看应用的布局和组件以及相关的属性。该工具位于SDK目录下的tools\bin子目录下。</p><h5 id="启动UiUiautomatorViewer"><a href="#启动UiUiautomatorViewer" class="headerlink" title="启动UiUiautomatorViewer"></a>启动UiUiautomatorViewer</h5><p>​    方法一：直接进入进入SDK目录下的tools\bin目录下双击uiautomatorviewer.bat就可以启动。（旧版本的在SDK目录下的tools）</p><p>​    方法二：将环境变量配置到SDK目录下的tools\bin目录，在命令行工具执行：uiautomatorviewer</p><h4 id="核心定位元素"><a href="#核心定位元素" class="headerlink" title="核心定位元素"></a>核心定位元素</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resource-id</td><td>资源ID，需要操作的组件基本都会有ID</td></tr><tr><td>text</td><td>文字属性，显示在组件上的文字</td></tr><tr><td>content-desc</td><td>描述，常用于提示操作</td></tr><tr><td>checken</td><td>选择属性，常见开关、单/复选和开关状态</td></tr><tr><td>focused</td><td>焦点属性，如输入框光标的闪动，说明焦点在输入框</td></tr></tbody></table><h4 id="搜索对象"><a href="#搜索对象" class="headerlink" title="搜索对象"></a>搜索对象</h4><table><thead><tr><th>属性</th><th>返回值</th><th>API By类</th></tr></thead><tbody><tr><td>resource-id</td><td>static BySelector</td><td>res(java.lang.String resourceName)</td></tr><tr><td>text</td><td>static BySelector</td><td>text(java.lang.String text)</td></tr><tr><td>content-desc</td><td>static BySelector</td><td>decs(java.lang.String contentDescription)</td></tr><tr><td>checken</td><td>static BySelector</td><td>checked(boolean isChecked)</td></tr><tr><td>focused</td><td>static BySelector</td><td>focused(boolean isFocused)</td></tr></tbody></table><h4 id="常见组件操作"><a href="#常见组件操作" class="headerlink" title="常见组件操作"></a>常见组件操作</h4><table><thead><tr><th>常见组件操作</th><th>类（UiObject2）</th></tr></thead><tbody><tr><td>点击</td><td>public boolean click()</td></tr><tr><td>长按</td><td>public boolean longclick()</td></tr><tr><td>拖动</td><td>public void drag(Point dest)</td></tr><tr><td>输入</td><td>public boolean setText(String text)</td></tr></tbody></table><h4 id="常见设备操作"><a href="#常见设备操作" class="headerlink" title="常见设备操作"></a>常见设备操作</h4><table><thead><tr><th>常见设备操作</th><th>类（UiDevice）</th></tr></thead><tbody><tr><td>点击</td><td>click(int x, int y)</td></tr><tr><td>按键</td><td>pressKeyCode(int KeyCode)</td></tr><tr><td>滑动</td><td>swipe(int startX, int StartY, int endX, int endY, int steps)</td></tr></tbody></table><p>1个steps等于5ms。</p><h4 id="用例注释生命周期"><a href="#用例注释生命周期" class="headerlink" title="用例注释生命周期"></a>用例注释生命周期</h4><p>@Before  每次用例开始前都执行</p><p>@Test 测试用例 </p><p>@After 每次用例结束后都执行</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/testing/ui-automator.html&quot;&gt;UiAutomator&lt;/a&gt;是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作，但有两个缺点：1. 测试脚本只能使用Java语言 2. 测试脚本要打包成jar或者apk包上传到设备上才能运行。        &lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://www.lauyongyi.cn/categories/Android/"/>
    
    
    <category term="Android开发" scheme="https://www.lauyongyi.cn/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
